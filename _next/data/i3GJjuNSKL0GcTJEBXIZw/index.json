{"pageProps":{"posts":[{"title":"Unveiling bottlenecks of couchbase sub-documents operations","link":"https://blog.allegro.tech/2024/05/couchbase-subdocuments-bottleneck.html","pubDate":"Thu, 16 May 2024 00:00:00 +0200","authors":{"author":[{"name":["Tomasz Ziółkowski"],"photo":["https://blog.allegro.tech/img/authors/tomasz.ziolkowski.jpg"],"url":["https://blog.allegro.tech/authors/tomasz.ziolkowski"]}]},"content":"<p>This story shows our journey in addressing a platform stability issue related to autoscaling, which, paradoxically, added some additional overhead instead\nof reducing the load. A pivotal part of this narrative is how we used <a href=\"https://www.couchbase.com/\">Couchbase</a> — a distributed NoSQL database. If you find\nyourself intrigued by another enigmatic story involving Couchbase, don’t miss my\n<a href=\"/2024/02/couchbase-expired-docs-tuning.html\">blog post on tuning expired doc settings</a>.</p>\n\n<p>This post unfolds our quest to discover the root cause of the bottleneck. Initially, I will outline the symptoms of the issue. Subsequently, you will be\nintroduced to how Couchbase is utilized by the aforementioned service. Equipped with this knowledge, I will recount our attempts to diagnose the problem and\nindicate which observations raised our suspicions. The following section is dedicated to conducting benchmarks to verify our predictions using\na custom benchmarking tool. Ultimately, we will explore the source code of Couchbase to uncover how the problematic operations are executed. This section\naims to provide a deep understanding of Couchbase’s inner workings. I firmly believe that the knowledge shared in that part is its most valuable asset and may\nenable you to swiftly identify and address some of the potential performance issues when using Couchbase.</p>\n\n<h2 id=\"set-the-scene\">Set the scene</h2>\n\n<p>The service at the heart of the stability issues handles external HTTP traffic; for the purpose of this discussion, we’ll refer to it as\n“the gateway service”. The traffic routed to the gateway service reflects a pattern similar to organic traffic on <a href=\"https://allegro.tech\">Allegro</a>,\ncharacterized by significant fluctuations in throughput between day and night hours. To efficiently utilize resources, the gateway service employs an autoscaler\nto dynamically adjust the number of instances based on current demands. It’s also important to note that spawning a new instance involves a warm-up phase,\nduring which the instance retrieves some data from Couchbase to populate its in-memory cache. The gateway service relies on a Couchbase cluster\ncomprised of <strong>three</strong> nodes.</p>\n\n<h2 id=\"observations\">Observations</h2>\n\n<p>The team managing the service encountered a series of errors in communication with Couchbase. These errors indicated that 3-second timeouts occurred while\nfetching data from Couchbase:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>com. couchbase.client.core.error.UnambiguousTimeoutException: SubdocGetRequest, Reason: TIMEOUT {\n    \"cancelled\":true,\n    \"completed\":true,\n    ... IRRELEVANT METADATA ...\n    \"timeoutMs\":3000,\n    \"timings\":{\"totalMicros\":3004052}\n}\n</code></pre></div></div>\n<p>Interestingly, during these incidents, the Couchbase cluster did not exhibit high CPU or RAM usage. Furthermore, the traffic to Couchbase, measured in\noperations per second, was not exceptionally high. I mean that other Couchbase clients (different microservices) were generating an order of magnitude more\noperations per second without encountering stability issues.</p>\n\n<p>Additional key observations related to the issue include:</p>\n<ul>\n  <li>The instability primarily occurred during the service scaling-up process, initially triggered by the autoscaler.</li>\n  <li>Newly spawned instances were predominantly affected.</li>\n  <li>The issues were reported solely for operations directed to a specific node within the cluster.</li>\n  <li>A temporary mitigation of the problems involved repeatedly restarting the failing application instances.</li>\n  <li>There was a noticeable pattern on the driver side that preceded the widespread errors, including timeouts and the inability to send requests due to\na non-writable channel.</li>\n</ul>\n\n<h3 id=\"temporary-solution\">Temporary solution</h3>\n\n<p>As a temporary measure, the team overseeing the gateway service implemented the following workarounds:</p>\n\n<ul>\n  <li>Disabled certain types of requests to reduce the overall traffic volume directed to Couchbase.</li>\n  <li>Deactivated the autoscaler, and manually scaled up the application to manage peak traffic loads.</li>\n</ul>\n\n<p>These actions successfully halted the problems, but they also had repercussions, including business impacts and decreased efficiency in resource utilization.</p>\n\n<h2 id=\"raising-suspicions\">Raising suspicions</h2>\n\n<p>A pivotal aspect of this issue was the use of the <a href=\"https://docs.couchbase.com/go-sdk/2.4/concept-docs/subdocument-operations.html\">Couchbase sub-document API</a>\nwithin the gateway service, an approach not widely adopted across our internal microservice landscape, yet notable for its efficiency. According to\nthe documentation, this API significantly reduces traffic by allowing the fetching or mutating only specific parts of a Couchbase document.\nEssentially, it acts as a substitute for the concept of <a href=\"https://en.wikipedia.org/wiki/Projection_(relational_algebra)\">projection</a>, familiar to SQL users.</p>\n\n<p>In our investigation we closely examined the data collected on the Couchbase node, the operational dynamics of the gateway service’s cache, and insights\nfrom scrutinizing both the Couchbase driver and server code. We hypothesized that the crux of the problem might be linked to the cache warm-up process for\nnewly launched instances.</p>\n\n<p>Our investigation uncovered several indicators pointing toward the core of the issue:</p>\n\n<ul>\n  <li>A disproportionately large number of requests targeted a single document, inevitably directing traffic to a specific node.</li>\n  <li>The node hosting this heavily queried document corresponded with the one mentioned in timeout-related logs.</li>\n  <li>Instances that had been running for an extended period reported virtually no errors.</li>\n  <li>The volume of requests to Couchbase from the affected instances was extraordinarily high, not aligning with the number of requests registered on\nthe Couchbase side. This discrepancy suggested that if the cache warming process was at fault, the sheer magnitude of attempted requests was overwhelming\neven the local network buffers.</li>\n</ul>\n\n<p>However, these observations were merely pieces of a larger puzzle. We noticed a “snowball effect” where the system’s inability to process an initial set\nof requests for newly initiated instances triggered a cascade of failures. But the question remained: Why? What made these instances different,\nand why didn’t other clients on the same cluster experience similar issues? This was the crucial moment to take a closer examination of the sub-document\noperations to determine their efficiency and optimization.</p>\n\n<h2 id=\"lets-benchmark-it\">Let’s benchmark it</h2>\n\n<p>Despite an extensive search, we were unable to locate any tools capable of reliably testing our hypothesis—that sub-document operations executed during\nthe warm-up phase could significantly challenge Couchbase’s handling capabilities. As a result, we developed a simple tool and made it\n<a href=\"https://github.com/ziollek/cb-perf-tester\">available in on <em>GitHub</em></a>.\nThis tool is designed to create a sample document and then execute parallel sub-document fetch operations concurrently.\nThe sample document is structured as follows:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>{\n    \"key\": \"test-subdoc\",\n    \"data\": {\n        \"subkey-000000\": \"value-000000\",\n        \"subkey-000001\": \"value-000001\",\n        . . .\n        \"subkey-0….N\": \"value-0…..N\",\n    }\n}\n</code></pre></div></div>\n\n<p>The tool allows manipulating several knobs, which includes:</p>\n\n<ul>\n  <li><strong>Parallelism</strong>: Determines the number of parallel <a href=\"https://gobyexample.com/goroutines\">goroutines</a> that will attempt to fetch the same sub-documents concurrently.</li>\n  <li><strong>Document Size</strong>: Defined by the number of sub-keys, this directly affects the document’s binary size.</li>\n  <li><strong>Level of Search Difficulty</strong>: This essentially refers to how deep or how far into the main document the target sub-document is located.\nThe concept is illustrated in the diagram below:</li>\n</ul>\n\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-sub-difficulty.png\" alt=\"Difficulty of sub-document search\" /></p>\n\n<h3 id=\"caveats\">Caveats</h3>\n\n<p>The primary objective of this exercise was to identify potential bottlenecks, not to conduct a highly accurate performance assessment of Couchbase clusters.\nTherefore, we opted to run our experiments using a local Docker container (<code class=\"language-plaintext highlighter-rouge\">couchbase:community-6.6.0</code>), rather than on a dedicated, well-isolated cluster.\nWe acknowledge that hosting both the server and the benchmarking tool on the same machine may compromise the reliability and accuracy of the results.\nConsequently, we advise against using the findings from these tests for comprehensive assessments or comparisons with other technologies.</p>\n\n<h3 id=\"benchmark-steps\">Benchmark steps</h3>\n\n<p>The procedure for each experiment follows a similar framework, outlined in the steps below:</p>\n\n<ul>\n  <li><strong>Document Preparation</strong>: Initiate the document with the desired number of sub-documents, as dictated by one of the experimental variables.</li>\n  <li><strong>Document Storage</strong>: Save this document under a predetermined key.</li>\n  <li><strong>Goroutine Initialization</strong>: Launch a specified number of goroutines, the quantity of which is determined by another experimental variable.</li>\n  <li><strong>Fetch Operations</strong>: Each goroutine executes a series of fetch operations, which can be either regular (retrieving the entire sample document) or\nsub-document (accessing a set of sub-documents). It’s important to note that these requests are executed in a blocking manner; a new fetch operation is\nperformed only after the completion of the preceding one. In sub-document mode, the difficulty of the fetch operation is controlled through\nan experiment variable.</li>\n  <li><strong>Completion Wait</strong>: Await the termination of all goroutines.</li>\n  <li><strong>Results Reporting</strong>: Calculate and display the estimated RPS (requests per second).</li>\n</ul>\n\n<h3 id=\"estimate-baseline\">Estimate baseline</h3>\n\n<p>Prior to delving into sub-document operations, we sought to establish the maximum number of regular get operations that our local Couchbase Server instance\ncould handle. Through testing at various levels of concurrency, we determined the maximum throughput for our specific setup.\nIt was approximately 6,000 to 7,000 RPS, regardless of whether the requests were for small documents (less than 200 bytes)\nor for non-existent documents. These findings were further validated by the statistics available through the Couchbase UI.</p>\n\n<p>Benchmark Command: Attempting to fetch a non-existent document yielded a rate of <em>6388 RPS</em>.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>./cb-perf-tester regular  --parallel 200 --repeat 1000 --keys 5 --search-non-existent\nUsing config file: /Users/tomasz.ziolkowski/.cb-perf-tester.yaml\nbenchmark params: keys=5, not-existent=true, repeats=1000, parallel=200\nGenerated doc with subkeys: 5, byte size is: 195\n\nsearch for key: not-exists\n\nregular report: successes: 0, errors: 200000, duration: 31.306684977s, rps: 6388.411937, success rps: 0.000000\n</code></pre></div></div>\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-baseline-non-exitstent.png\" alt=\"Baseline - fetch a not-existent document\" /></p>\n\n<p>Benchmark Command: Fetching an existing small (195 bytes) document yielded a rate of <em>6341 rps</em>.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>./cb-perf-tester regular  --parallel 200 --repeat 1000 --keys 5\nUsing config file: /Users/tomasz.ziolkowski/.cb-perf-tester.yaml\nbenchmark params: keys=5, not-existent=false, repeats=1000, parallel=200\nGenerated doc with subkeys: 5, byte size is: 195\n\nsearch for key: test-regular\n\nregular report: successes: 200000, errors: 0, duration: 31.536538682s, rps: 6341.850068, success rps: 6341.850068\n</code></pre></div></div>\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-baseline-hits.png\" alt=\"Baseline - fetch an existing document\" /></p>\n\n<h3 id=\"testing-scenarios\">Testing scenarios</h3>\n\n<p>Now that we have a baseline for comparison, we’re set to evaluate it against the outcomes of various scenarios. To ensure the tests are comparable,\nwe’ll maintain constant parallelism across all tests, specifically using 200 goroutines. The variables that will differ across scenarios include:</p>\n\n<ul>\n  <li><strong>Total Number of Sub-Documents</strong>: This determines the overall size of the sample document, as the document’s size is directly related to the number\nof sub-documents it contains.</li>\n  <li><strong>Number of Searched Sub-Documents</strong>: This refers to how many sub-paths within the sample document will be targeted in a single fetch operation.</li>\n  <li><strong>Search Difficulty</strong>: This aspect dictates the difficulty of locating the searched sub-paths within the document.</li>\n</ul>\n\n<p>It’s important to highlight that in each scenario, we will manipulate only one variable at a time while keeping the other parameters constant.</p>\n\n<h4 id=\"scenario-a-the-impact-of-document-size-on-performance\">Scenario A: The impact of document size on performance</h4>\n\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-doc-size-vs-performance-all.png\" alt=\"Document size vs performance - aggregated\" /></p>\n\n<p>To better visualize the impact, let’s look at the diagram for HARD scenario:</p>\n\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-doc-size-vs-performance-hard.png\" alt=\"Document size vs performance - hard\" /></p>\n\n<p>It is clearly visible that there is a strict correlation between document size and performance.</p>\n\n<h4 id=\"scenario-b-the-impact-of-the-number-of-searched-sub-documents-on-performance\">Scenario B: The impact of the number of searched sub-documents on performance</h4>\n\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-subdocs-num-vs-performance-all.png\" alt=\"Number of searched sub-documents vs performance - aggregated\" /></p>\n\n<p>To better visualize the impact, let’s look at the diagram for HARD scenario:</p>\n\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-subdocs-num-vs-performance-hard.png\" alt=\"Number of searched sub-documents vs performance - hard\" /></p>\n\n<p>As observed in the previous scenario, there is a clear correlation between the number of sub-documents accessed and the system’s performance.</p>\n\n<h2 id=\"further-analysis\">Further analysis</h2>\n\n<p>Given the evident correlation between the document size/number of queried sub-paths and performance degradation, we delve into the mechanics to understand\nthe root cause of these test results. A notable observation during the tests relates to CPU utilization within the Docker environment, where, despite having\nsix cores available, only a single core was actively utilized. Intriguingly, this usage was monopolized by a single thread (<code class=\"language-plaintext highlighter-rouge\">mc:worker_X</code>).\nThis phenomenon directly stems from Couchbase’s handling of Key-Value (KV) connections. By default, the Couchbase driver initiates only a single connection to\neach cluster node for KV operations. However, this configuration can be adjusted in certain Software Development Kits (SDKs)—the Java SDK,\nfor instance, allows modification through <a href=\"https://docs.couchbase.com/java-sdk/current/ref/client-settings.html#io-options\">IoConfig.numKvConnections</a>.</p>\n\n<p>When a connection is established, Couchbase assigns it to\na <a href=\"https://github.com/couchbase/kv_engine/blob/master/docs/in-depth/C10k.md#current-approach-why-not-both\">specific worker thread</a>) using\na <a href=\"https://github.com/couchbase/kv_engine/blob/master/daemon/front_end_thread.h#L84\">Round-Robin (RR)</a>) algorithm. As a result, the Couchbase Server does not\nfully utilize available CPU power for a single connection, even when a lot of resources are free. This behavior can be seen as beneficial, serving to mitigate\nthe <a href=\"https://en.wikipedia.org/wiki/Cloud_computing_issues#Performance_interference_and_noisy_neighbors\">“noisy neighbor” effect</a>, provided there are sufficient\nspare cores available to manage new connections. This mechanism ensures balanced resource use across connections, as illustrated in the diagram below:</p>\n\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-dispatch-ok.png\" alt=\"Handling connections - free cores scenario\" /></p>\n\n<p>Conversely, one may encounter fluctuating performance due to instances of misfortune, where if other clients significantly burden certain worker threads,\nand your connection is allocated to one of these overloaded threads, performance inconsistencies arise. This scenario, where a client experiences higher than\nusual response times due to an imbalanced distribution of workload across worker threads, is depicted in the diagram below:</p>\n\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-dispatch-bad.png\" alt=\"Handling connections - overloaded core scenario\" /></p>\n\n<p>This behavior explains the apparent paradox observed during the stability issues: the Couchbase node showed no clear signs of being overloaded, yet certain\nanomalous symptoms were present, such as a metric indicating the minimum <a href=\"https://en.wikipedia.org/wiki/Idle_(CPU)\">idle</a> percentage across all cores plummeting\nto 0% during the disturbances. This leaves no doubt that operations on sub-documents have the potential to overburden worker threads within\nthe Couchbase Server. With this understanding we are now ready to delve deeper into the root cause of such behavior.</p>\n\n<h3 id=\"what-documentation-says\">What documentation says</h3>\n\n<p>The documentation for Couchbase, housed alongside the server’s source code, is notably comprehensive, including a dedicated section on\n<a href=\"https://github.com/couchbase/kv_engine/blob/master/docs/SubDocument.md\">sub-documents</a>. However, it falls short of providing detailed insights into\nthe internal workings of these operations. Additionally, there is a lack of discussion on the performance implications of sub-document operations,\nwith only a few remarks on data typing and float numbers that do not apply to the cases we tested. Attempts to find answers on the Couchbase forum were also\nunfruitful, yielding no substantial information on the performance issues we encountered. Despite this, there is confirmation from others in the community who\nhave observed\n<a href=\"https://www.couchbase.com/forums/t/frequent-timeouts-and-requests-over-threshold-for-subdocgetrequests-via-reactive-java-sdk/30211\">similar problems</a>.</p>\n\n<h3 id=\"what-source-code-says\">What source code says</h3>\n\n<p>A thorough analysis of the codebase reveals a definitive cause for the performance degradation observed. It’s important to note that Couchbase requires\n<a href=\"https://docs.couchbase.com/server/current/learn/buckets-memory-and-storage/compression.html\">decompression</a> of a document for any lookup or manipulation\noperation, whether the document is retrieved from RAM or disk. Let’s start from a point where Couchbase starts doing\n<a href=\"https://github.com/couchbase/kv_engine/blob/cf020888d2e09b132a02c90b99e160044ddabb11/daemon/subdocument.cc#L568\">lookups</a> on a decompressed object:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// 2. Perform each of the operations on document.\nfor (auto&amp; op : operations) {\n    switch (op.traits.scope) {\n    case CommandScope::SubJSON:\n        if (cb::mcbp::datatype::is_json(doc_datatype)) {\n            // Got JSON, perform the operation.\n            op.status = subdoc_operate_one_path(context, op, current.view);\n        }\n</code></pre></div></div>\n<p>A critical observation from our analysis is that each operation (lookup) is executed sequentially through the invocation of <code class=\"language-plaintext highlighter-rouge\">subdoc_operate_one_path</code>.\nTo understand the performance implications, let’s examine\n<a href=\"https://github.com/couchbase/kv_engine/blob/cf020888d2e09b132a02c90b99e160044ddabb11/daemon/subdocument.cc#L413C5-L414C76\">the implementation</a> of this lookup\nprocess:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// ... and execute it.\nconst auto subdoc_res = op.op_exec(spec.path.data(), spec.path.size());\n</code></pre></div></div>\n\n<p>The Investigation reveals that the lookup functionality is powered by a specialized library,\n<a href=\"https://github.com/couchbase/subjson/blob/4b93d966f791209209a0825e46f7049df0673e8f/subdoc/operations.cc#L757\">library <code class=\"language-plaintext highlighter-rouge\">subjson</code></a>, which in turn\n<a href=\"https://github.com/couchbase/subjson/blob/4b93d966f791209209a0825e46f7049df0673e8f/subdoc/match.cc#L371\">uses</a>\nthe <a href=\"https://github.com/mnunberg/jsonsl\"><code class=\"language-plaintext highlighter-rouge\">jsonsl</code> library</a> for parsing JSON in a streaming manner. An enlightening piece of information about performance can be found in\nthe README of the <code class=\"language-plaintext highlighter-rouge\">subjson</code> library, which is integral to Couchbase’s solution. The direct quote from the README is as follows:</p>\n\n<blockquote>\n  <p>Because the library does not actually build a JSON tree, the memory usage and CPU consumption is constant, regardless of the size of the actual JSON object\nbeing operated upon, and thus the only variable performance factor is the amount of actual time the library can seek to the location in the document to\nbe modified.</p>\n\n  <p>On a single Xeon E5520 core, this library can process about 150MB/s-300MB/s of JSON. This processing includes the search logic as well as any\nreplacement logic.</p>\n</blockquote>\n\n<p>This analysis clearly demonstrates that lookups targeting paths situated towards the end of a document are markedly slower compared to those aimed\nat the beginning. Moreover, each sequential lookup <strong>needs to repeat document parsing</strong>. The impact of this implementation on performance is significant.\nFor a more intuitive understanding of these effects, please refer to the diagram below:</p>\n\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-processing-sub-documents.png\" alt=\"Processing sub-documents in details\" /></p>\n\n<p>The performance characteristics we’ve outlined align with the outcomes observed in our experiments. To illustrate, consider a detailed examination of\na single <code class=\"language-plaintext highlighter-rouge\">HARD</code> test scenario—specifically, a case where the sub-documents targeted for search were positioned towards the end of the JSON document:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>./cb-perf-tester subdoc  --parallel 200 --repeat 50 --search-keys 10 --difficulty hard\nUsing config file: /Users/tomasz.ziolkowski/.cb-perf-tester.yaml\nbenchmark params: keys=10000, level=Hard, search-keys=10, repeats=50, parallel=200\nGenerated doc with subkeys: 10000, byte size is: 310043\n\nsearch for subkeys [level=Hard]: [data.subkey-009999 data.subkey-009998 data.subkey-009997 data.subkey-009996 data.subkey-009995 data.subkey-009994 data.subkey-009993 data.subkey-009992 data.subkey-009991 data.subkey-009990]\n\nsubdoc report: successes: 10000, errors: 0, duration: 1m19.784865193s, rps: 125.337055, success rps: 125.337055\n</code></pre></div></div>\n\n<p>By multiplying the size of the document by the number of sub-documents queried, we can determine the total stream size that the library must process, which,\nin this case, approximates to <code class=\"language-plaintext highlighter-rouge\">~3MB</code>. Further multiplying this figure by the RPS gives us an insight into the overall throughput of\nthe stream processing:</p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">3MB x 125 RPS ~= 375 MBps</code></p>\n\n<p>The calculated throughput slightly exceeds the benchmarks outlined in the README. Moreover, the estimated throughput remains nearly constant across\nvarious tests. For a comprehensive view of these findings, please refer to the diagram below, which displays the estimated throughput for tests conducted under\nthe HARD level with a document size of approximately <code class=\"language-plaintext highlighter-rouge\">300KB</code>:</p>\n\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-estimated-subdocs-throughput.png\" alt=\"Estimated throughput\" /></p>\n\n<h2 id=\"conclusions\">Conclusions</h2>\n\n<p>The Couchbase sub-document API, while designed to optimize network throughput, introduces significant performance trade-offs. Notably, even\n<em>under optimal conditions</em>, operations on sub-documents are noticeably slower compared to regular get operations fetching\nsmall documents—evidenced by a comparison of the baseline performance; approximately 4-5k RPS for sub-document operations vs. 6-7k RPS for\nregular get operations.</p>\n\n<p>The method Couchbase employs for executing lookups directly influences performance, manifesting declines as either the document size increases or the number of\nlookups per request raises. This slowdown affects all requests over the same connection due to the high CPU demand of sub-document lookup operations.\nParticularly in environments utilizing reactive/asynchronous clients, this can overload the Couchbase worker thread, leading to a halt in request servicing.\nImportantly, an overloaded worker may manage connections from multiple clients, potentially exacerbating the “noisy neighbor” effect.</p>\n\n<p>While there are strategies to mitigate these issues from the perspective of a client, such as the gateway service, these considerations warrant\na separate discussion, which I plan to address in a future blog post.</p>\n","contentSnippet":"This story shows our journey in addressing a platform stability issue related to autoscaling, which, paradoxically, added some additional overhead instead\nof reducing the load. A pivotal part of this narrative is how we used Couchbase — a distributed NoSQL database. If you find\nyourself intrigued by another enigmatic story involving Couchbase, don’t miss my\nblog post on tuning expired doc settings.\nThis post unfolds our quest to discover the root cause of the bottleneck. Initially, I will outline the symptoms of the issue. Subsequently, you will be\nintroduced to how Couchbase is utilized by the aforementioned service. Equipped with this knowledge, I will recount our attempts to diagnose the problem and\nindicate which observations raised our suspicions. The following section is dedicated to conducting benchmarks to verify our predictions using\na custom benchmarking tool. Ultimately, we will explore the source code of Couchbase to uncover how the problematic operations are executed. This section\naims to provide a deep understanding of Couchbase’s inner workings. I firmly believe that the knowledge shared in that part is its most valuable asset and may\nenable you to swiftly identify and address some of the potential performance issues when using Couchbase.\nSet the scene\nThe service at the heart of the stability issues handles external HTTP traffic; for the purpose of this discussion, we’ll refer to it as\n“the gateway service”. The traffic routed to the gateway service reflects a pattern similar to organic traffic on Allegro,\ncharacterized by significant fluctuations in throughput between day and night hours. To efficiently utilize resources, the gateway service employs an autoscaler\nto dynamically adjust the number of instances based on current demands. It’s also important to note that spawning a new instance involves a warm-up phase,\nduring which the instance retrieves some data from Couchbase to populate its in-memory cache. The gateway service relies on a Couchbase cluster\ncomprised of three nodes.\nObservations\nThe team managing the service encountered a series of errors in communication with Couchbase. These errors indicated that 3-second timeouts occurred while\nfetching data from Couchbase:\n\ncom. couchbase.client.core.error.UnambiguousTimeoutException: SubdocGetRequest, Reason: TIMEOUT {\n    \"cancelled\":true,\n    \"completed\":true,\n    ... IRRELEVANT METADATA ...\n    \"timeoutMs\":3000,\n    \"timings\":{\"totalMicros\":3004052}\n}\n\n\nInterestingly, during these incidents, the Couchbase cluster did not exhibit high CPU or RAM usage. Furthermore, the traffic to Couchbase, measured in\noperations per second, was not exceptionally high. I mean that other Couchbase clients (different microservices) were generating an order of magnitude more\noperations per second without encountering stability issues.\nAdditional key observations related to the issue include:\nThe instability primarily occurred during the service scaling-up process, initially triggered by the autoscaler.\nNewly spawned instances were predominantly affected.\nThe issues were reported solely for operations directed to a specific node within the cluster.\nA temporary mitigation of the problems involved repeatedly restarting the failing application instances.\nThere was a noticeable pattern on the driver side that preceded the widespread errors, including timeouts and the inability to send requests due to\na non-writable channel.\nTemporary solution\nAs a temporary measure, the team overseeing the gateway service implemented the following workarounds:\nDisabled certain types of requests to reduce the overall traffic volume directed to Couchbase.\nDeactivated the autoscaler, and manually scaled up the application to manage peak traffic loads.\nThese actions successfully halted the problems, but they also had repercussions, including business impacts and decreased efficiency in resource utilization.\nRaising suspicions\nA pivotal aspect of this issue was the use of the Couchbase sub-document API\nwithin the gateway service, an approach not widely adopted across our internal microservice landscape, yet notable for its efficiency. According to\nthe documentation, this API significantly reduces traffic by allowing the fetching or mutating only specific parts of a Couchbase document.\nEssentially, it acts as a substitute for the concept of projection, familiar to SQL users.\nIn our investigation we closely examined the data collected on the Couchbase node, the operational dynamics of the gateway service’s cache, and insights\nfrom scrutinizing both the Couchbase driver and server code. We hypothesized that the crux of the problem might be linked to the cache warm-up process for\nnewly launched instances.\nOur investigation uncovered several indicators pointing toward the core of the issue:\nA disproportionately large number of requests targeted a single document, inevitably directing traffic to a specific node.\nThe node hosting this heavily queried document corresponded with the one mentioned in timeout-related logs.\nInstances that had been running for an extended period reported virtually no errors.\nThe volume of requests to Couchbase from the affected instances was extraordinarily high, not aligning with the number of requests registered on\nthe Couchbase side. This discrepancy suggested that if the cache warming process was at fault, the sheer magnitude of attempted requests was overwhelming\neven the local network buffers.\nHowever, these observations were merely pieces of a larger puzzle. We noticed a “snowball effect” where the system’s inability to process an initial set\nof requests for newly initiated instances triggered a cascade of failures. But the question remained: Why? What made these instances different,\nand why didn’t other clients on the same cluster experience similar issues? This was the crucial moment to take a closer examination of the sub-document\noperations to determine their efficiency and optimization.\nLet’s benchmark it\nDespite an extensive search, we were unable to locate any tools capable of reliably testing our hypothesis—that sub-document operations executed during\nthe warm-up phase could significantly challenge Couchbase’s handling capabilities. As a result, we developed a simple tool and made it\navailable in on GitHub.\nThis tool is designed to create a sample document and then execute parallel sub-document fetch operations concurrently.\nThe sample document is structured as follows:\n\n{\n    \"key\": \"test-subdoc\",\n    \"data\": {\n        \"subkey-000000\": \"value-000000\",\n        \"subkey-000001\": \"value-000001\",\n        . . .\n        \"subkey-0….N\": \"value-0…..N\",\n    }\n}\n\n\nThe tool allows manipulating several knobs, which includes:\nParallelism: Determines the number of parallel goroutines that will attempt to fetch the same sub-documents concurrently.\nDocument Size: Defined by the number of sub-keys, this directly affects the document’s binary size.\nLevel of Search Difficulty: This essentially refers to how deep or how far into the main document the target sub-document is located.\nThe concept is illustrated in the diagram below:\n\nCaveats\nThe primary objective of this exercise was to identify potential bottlenecks, not to conduct a highly accurate performance assessment of Couchbase clusters.\nTherefore, we opted to run our experiments using a local Docker container (couchbase:community-6.6.0), rather than on a dedicated, well-isolated cluster.\nWe acknowledge that hosting both the server and the benchmarking tool on the same machine may compromise the reliability and accuracy of the results.\nConsequently, we advise against using the findings from these tests for comprehensive assessments or comparisons with other technologies.\nBenchmark steps\nThe procedure for each experiment follows a similar framework, outlined in the steps below:\nDocument Preparation: Initiate the document with the desired number of sub-documents, as dictated by one of the experimental variables.\nDocument Storage: Save this document under a predetermined key.\nGoroutine Initialization: Launch a specified number of goroutines, the quantity of which is determined by another experimental variable.\nFetch Operations: Each goroutine executes a series of fetch operations, which can be either regular (retrieving the entire sample document) or\nsub-document (accessing a set of sub-documents). It’s important to note that these requests are executed in a blocking manner; a new fetch operation is\nperformed only after the completion of the preceding one. In sub-document mode, the difficulty of the fetch operation is controlled through\nan experiment variable.\nCompletion Wait: Await the termination of all goroutines.\nResults Reporting: Calculate and display the estimated RPS (requests per second).\nEstimate baseline\nPrior to delving into sub-document operations, we sought to establish the maximum number of regular get operations that our local Couchbase Server instance\ncould handle. Through testing at various levels of concurrency, we determined the maximum throughput for our specific setup.\nIt was approximately 6,000 to 7,000 RPS, regardless of whether the requests were for small documents (less than 200 bytes)\nor for non-existent documents. These findings were further validated by the statistics available through the Couchbase UI.\nBenchmark Command: Attempting to fetch a non-existent document yielded a rate of 6388 RPS.\n\n./cb-perf-tester regular  --parallel 200 --repeat 1000 --keys 5 --search-non-existent\nUsing config file: /Users/tomasz.ziolkowski/.cb-perf-tester.yaml\nbenchmark params: keys=5, not-existent=true, repeats=1000, parallel=200\nGenerated doc with subkeys: 5, byte size is: 195\n\nsearch for key: not-exists\n\nregular report: successes: 0, errors: 200000, duration: 31.306684977s, rps: 6388.411937, success rps: 0.000000\n\n\n\nBenchmark Command: Fetching an existing small (195 bytes) document yielded a rate of 6341 rps.\n\n./cb-perf-tester regular  --parallel 200 --repeat 1000 --keys 5\nUsing config file: /Users/tomasz.ziolkowski/.cb-perf-tester.yaml\nbenchmark params: keys=5, not-existent=false, repeats=1000, parallel=200\nGenerated doc with subkeys: 5, byte size is: 195\n\nsearch for key: test-regular\n\nregular report: successes: 200000, errors: 0, duration: 31.536538682s, rps: 6341.850068, success rps: 6341.850068\n\n\n\nTesting scenarios\nNow that we have a baseline for comparison, we’re set to evaluate it against the outcomes of various scenarios. To ensure the tests are comparable,\nwe’ll maintain constant parallelism across all tests, specifically using 200 goroutines. The variables that will differ across scenarios include:\nTotal Number of Sub-Documents: This determines the overall size of the sample document, as the document’s size is directly related to the number\nof sub-documents it contains.\nNumber of Searched Sub-Documents: This refers to how many sub-paths within the sample document will be targeted in a single fetch operation.\nSearch Difficulty: This aspect dictates the difficulty of locating the searched sub-paths within the document.\nIt’s important to highlight that in each scenario, we will manipulate only one variable at a time while keeping the other parameters constant.\nScenario A: The impact of document size on performance\n\nTo better visualize the impact, let’s look at the diagram for HARD scenario:\n\nIt is clearly visible that there is a strict correlation between document size and performance.\nScenario B: The impact of the number of searched sub-documents on performance\n\nTo better visualize the impact, let’s look at the diagram for HARD scenario:\n\nAs observed in the previous scenario, there is a clear correlation between the number of sub-documents accessed and the system’s performance.\nFurther analysis\nGiven the evident correlation between the document size/number of queried sub-paths and performance degradation, we delve into the mechanics to understand\nthe root cause of these test results. A notable observation during the tests relates to CPU utilization within the Docker environment, where, despite having\nsix cores available, only a single core was actively utilized. Intriguingly, this usage was monopolized by a single thread (mc:worker_X).\nThis phenomenon directly stems from Couchbase’s handling of Key-Value (KV) connections. By default, the Couchbase driver initiates only a single connection to\neach cluster node for KV operations. However, this configuration can be adjusted in certain Software Development Kits (SDKs)—the Java SDK,\nfor instance, allows modification through IoConfig.numKvConnections.\nWhen a connection is established, Couchbase assigns it to\na specific worker thread) using\na Round-Robin (RR)) algorithm. As a result, the Couchbase Server does not\nfully utilize available CPU power for a single connection, even when a lot of resources are free. This behavior can be seen as beneficial, serving to mitigate\nthe “noisy neighbor” effect, provided there are sufficient\nspare cores available to manage new connections. This mechanism ensures balanced resource use across connections, as illustrated in the diagram below:\n\nConversely, one may encounter fluctuating performance due to instances of misfortune, where if other clients significantly burden certain worker threads,\nand your connection is allocated to one of these overloaded threads, performance inconsistencies arise. This scenario, where a client experiences higher than\nusual response times due to an imbalanced distribution of workload across worker threads, is depicted in the diagram below:\n\nThis behavior explains the apparent paradox observed during the stability issues: the Couchbase node showed no clear signs of being overloaded, yet certain\nanomalous symptoms were present, such as a metric indicating the minimum idle percentage across all cores plummeting\nto 0% during the disturbances. This leaves no doubt that operations on sub-documents have the potential to overburden worker threads within\nthe Couchbase Server. With this understanding we are now ready to delve deeper into the root cause of such behavior.\nWhat documentation says\nThe documentation for Couchbase, housed alongside the server’s source code, is notably comprehensive, including a dedicated section on\nsub-documents. However, it falls short of providing detailed insights into\nthe internal workings of these operations. Additionally, there is a lack of discussion on the performance implications of sub-document operations,\nwith only a few remarks on data typing and float numbers that do not apply to the cases we tested. Attempts to find answers on the Couchbase forum were also\nunfruitful, yielding no substantial information on the performance issues we encountered. Despite this, there is confirmation from others in the community who\nhave observed\nsimilar problems.\nWhat source code says\nA thorough analysis of the codebase reveals a definitive cause for the performance degradation observed. It’s important to note that Couchbase requires\ndecompression of a document for any lookup or manipulation\noperation, whether the document is retrieved from RAM or disk. Let’s start from a point where Couchbase starts doing\nlookups on a decompressed object:\n\n// 2. Perform each of the operations on document.\nfor (auto& op : operations) {\n    switch (op.traits.scope) {\n    case CommandScope::SubJSON:\n        if (cb::mcbp::datatype::is_json(doc_datatype)) {\n            // Got JSON, perform the operation.\n            op.status = subdoc_operate_one_path(context, op, current.view);\n        }\n\n\nA critical observation from our analysis is that each operation (lookup) is executed sequentially through the invocation of subdoc_operate_one_path.\nTo understand the performance implications, let’s examine\nthe implementation of this lookup\nprocess:\n\n// ... and execute it.\nconst auto subdoc_res = op.op_exec(spec.path.data(), spec.path.size());\n\n\nThe Investigation reveals that the lookup functionality is powered by a specialized library,\nlibrary subjson, which in turn\nuses\nthe jsonsl library for parsing JSON in a streaming manner. An enlightening piece of information about performance can be found in\nthe README of the subjson library, which is integral to Couchbase’s solution. The direct quote from the README is as follows:\nBecause the library does not actually build a JSON tree, the memory usage and CPU consumption is constant, regardless of the size of the actual JSON object\nbeing operated upon, and thus the only variable performance factor is the amount of actual time the library can seek to the location in the document to\nbe modified.\nOn a single Xeon E5520 core, this library can process about 150MB/s-300MB/s of JSON. This processing includes the search logic as well as any\nreplacement logic.\nThis analysis clearly demonstrates that lookups targeting paths situated towards the end of a document are markedly slower compared to those aimed\nat the beginning. Moreover, each sequential lookup needs to repeat document parsing. The impact of this implementation on performance is significant.\nFor a more intuitive understanding of these effects, please refer to the diagram below:\n\nThe performance characteristics we’ve outlined align with the outcomes observed in our experiments. To illustrate, consider a detailed examination of\na single HARD test scenario—specifically, a case where the sub-documents targeted for search were positioned towards the end of the JSON document:\n\n./cb-perf-tester subdoc  --parallel 200 --repeat 50 --search-keys 10 --difficulty hard\nUsing config file: /Users/tomasz.ziolkowski/.cb-perf-tester.yaml\nbenchmark params: keys=10000, level=Hard, search-keys=10, repeats=50, parallel=200\nGenerated doc with subkeys: 10000, byte size is: 310043\n\nsearch for subkeys [level=Hard]: [data.subkey-009999 data.subkey-009998 data.subkey-009997 data.subkey-009996 data.subkey-009995 data.subkey-009994 data.subkey-009993 data.subkey-009992 data.subkey-009991 data.subkey-009990]\n\nsubdoc report: successes: 10000, errors: 0, duration: 1m19.784865193s, rps: 125.337055, success rps: 125.337055\n\n\nBy multiplying the size of the document by the number of sub-documents queried, we can determine the total stream size that the library must process, which,\nin this case, approximates to ~3MB. Further multiplying this figure by the RPS gives us an insight into the overall throughput of\nthe stream processing:\n3MB x 125 RPS ~= 375 MBps\nThe calculated throughput slightly exceeds the benchmarks outlined in the README. Moreover, the estimated throughput remains nearly constant across\nvarious tests. For a comprehensive view of these findings, please refer to the diagram below, which displays the estimated throughput for tests conducted under\nthe HARD level with a document size of approximately 300KB:\n\nConclusions\nThe Couchbase sub-document API, while designed to optimize network throughput, introduces significant performance trade-offs. Notably, even\nunder optimal conditions, operations on sub-documents are noticeably slower compared to regular get operations fetching\nsmall documents—evidenced by a comparison of the baseline performance; approximately 4-5k RPS for sub-document operations vs. 6-7k RPS for\nregular get operations.\nThe method Couchbase employs for executing lookups directly influences performance, manifesting declines as either the document size increases or the number of\nlookups per request raises. This slowdown affects all requests over the same connection due to the high CPU demand of sub-document lookup operations.\nParticularly in environments utilizing reactive/asynchronous clients, this can overload the Couchbase worker thread, leading to a halt in request servicing.\nImportantly, an overloaded worker may manage connections from multiple clients, potentially exacerbating the “noisy neighbor” effect.\nWhile there are strategies to mitigate these issues from the perspective of a client, such as the gateway service, these considerations warrant\na separate discussion, which I plan to address in a future blog post.","guid":"https://blog.allegro.tech/2024/05/couchbase-subdocuments-bottleneck.html","categories":["tech","couchbase","sub-documents","performance","bottlenecks"],"isoDate":"2024-05-15T22:00:00.000Z"},{"title":"Ten Years and Counting: My Affair with Microservices","link":"https://blog.allegro.tech/2024/04/ten-years-microservices.html","pubDate":"Fri, 12 Apr 2024 00:00:00 +0200","authors":{"author":[{"name":["Michał Kosmulski"],"photo":["https://blog.allegro.tech/img/authors/michal.kosmulski.jpg"],"url":["https://blog.allegro.tech/authors/michal.kosmulski"]}]},"content":"<p>In early 2024, I hit ten years at <a href=\"https://allegro.tech/\">Allegro</a>, which also happens to be how long I’ve been working with <a href=\"https://martinfowler.com/microservices/\">microservices</a>.\nThis timespan also roughly corresponds to how long the company as a whole has been using them, so I think it’s a good time to outline the story of project\nRubicon: a very ambitious gamble which completely changed how we work and what our software is like. The idea probably seemed rather extreme at the time, yet I\nam certain that without this change, Allegro would not be where it is today, or perhaps would not be there at all.</p>\n\n<h2 id=\"background\">Background</h2>\n\n<p>Allegro is <a href=\"https://about.allegro.eu/who-we-are/at-a-glance\">one of the largest e-commerce sites in Central Europe</a>, with 20 million users and over 300 million\noffers. It was founded in 1999, originally with just the Polish market in mind. The story I want to tell you starts in 2013, a year before I joined.</p>\n\n<p><img src=\"/img/articles/2024-04-12-ten-years-microservices/allegro-site.png\" alt=\"Allegro website showing some offers\" class=\"small-image\" style=\"box-shadow: 0 0 4px 0 #D7DBD6;\" /></p>\n\n<p>In 2013, the site was already large and relevant, but its commercial success and further growth led to development bottlenecks emerging. The codebase was a\nmonolithic PHP application, with some auxiliary processes written in C. Checked out, the git monorepo weighed about 2 GB, and the number of pull requests\nproduced daily by a few hundred developers was so large that if you started a new branch in the morning, you were almost sure to get some conflicts if you\nwanted to merge in the afternoon. The system was centered around a single, huge database, with all the performance and architectural challenges you can imagine.\nTests were brittle and took ages to finish. Deployment was a mostly manual and thus time-consuming processes that required lots of attention and ran the risk of\ncausing a serious problem in production if something went wrong. It was so demanding and stressful I still remember my team having to run the deployment once\n(in place of the usual deployers) as a big event.</p>\n\n<h2 id=\"rubicon-rises\">Rubicon Rises</h2>\n\n<p><img src=\"/img/articles/2024-04-12-ten-years-microservices/Tabula_Peutingeriana_Rubicon.png\" alt=\"Rubicon river on an old map\" class=\"small-image-right\" />\nIt was becoming clear that we would hit a wall if we continued working this way. So, around 2012/2013, the idea for a complete overhaul of the architecture\nstarted to emerge. We began experimenting with <a href=\"https://en.wikipedia.org/wiki/Service-oriented_architecture\">SOA (Service-Oriented Architecture)</a> by\ncreating a small side project, the so-called New Platform, in PHP, as a proof-of-concept. We also decided we would start doing\n<a href=\"https://en.wikipedia.org/wiki/Agile_software_development\">Agile</a>, <a href=\"https://en.wikipedia.org/wiki/Test-driven_development\">TDD</a>, and\n<a href=\"https://en.wikipedia.org/wiki/Cloud_computing\">Cloud</a>. After a short while, on top of this, we decided to switch to Java for backend development.\nIt was becoming clear that <a href=\"/2015/02/Evolution-of-our-platform-architecture.html\">it would be a revolution indeed</a>, requiring everyone to change\nthe way they worked, and to switch out the whole development ecosystem, starting with the core programming language. Once we got this going, there would be\nno turning back, so a matching name also appeared: Project <a href=\"https://en.wikipedia.org/wiki/Crossing_the_Rubicon\">Rubicon</a>.</p>\n\n<p>The project had such a broad scope that it even came with its own constitution, a set of high-level guidelines to be used in case of doubt. It focused mostly\non ways of working and highlighted the value of learning (on personal, team, and company level), testing, reuse, empirical approach to software development,\nand active participation in the open-source community both as users and as contributors. Specific technical assumptions included:</p>\n<ul>\n  <li>focus on quality</li>\n  <li>microservices</li>\n  <li>distributed, multi-regional, active-active architecture</li>\n  <li>Java</li>\n  <li>cloud deployment</li>\n  <li>using open-source technologies</li>\n</ul>\n\n<p>There was also a list of success criteria for the project:</p>\n<ul>\n  <li>the monolith is gone</li>\n  <li>we have Java gurus on board</li>\n  <li>we have services</li>\n  <li>development is faster</li>\n  <li>we have continuous delivery</li>\n  <li>we don’t have another monolith</li>\n  <li>we still make money</li>\n</ul>\n\n<p>Faster development was probably the most important goal, since slow delivery was the direct reason we embarked on this long journey.</p>\n\n<p>On top of these lists, more detailed plans were made as well, of course. For example, various parts of the system were prioritized for moving out of the\nmonolith as we were well aware we would not be able to work on everything at once. Being Agile does not mean planning is to be avoided, only that plans have\nto be flexible. So, armed with a plan, we got off to work.</p>\n\n<h2 id=\"execution\">Execution</h2>\n\n<p><img src=\"/img/articles/2024-04-12-ten-years-microservices/tim-gouw-1K9T5YiZ2WU-unsplash.jpg\" alt=\"Man sitting at a laptop, overwhelmed by what he sees on the screen\" class=\"small-image-right\" />\nToo much has happened during the 10+ years to report here. The initial period was really frantic since we had to set up everything, and, first of all, teams had\nto switch to a new mindset. This was also a period of intense hiring, and the time I joined the recently opened office in Warsaw. Microservices were at that\ntime only starting to gain traction, so while we used the experiences of others as much has possible, we had to learn many things ourselves, sometimes learning\nthem the hard way.</p>\n\n<p>To give you an idea of the pace, here are just some of the things that happened in 2013:</p>\n<ul>\n  <li>outline of the common architecture (service discovery, logging) created</li>\n  <li>a set of common libraries created (<a href=\"https://youtu.be/PeioFobaq94\">presentation from 2016</a>)</li>\n  <li>training in Java and JVM for PHP developers</li>\n  <li>recruitment of Java developers started</li>\n  <li>first Java code got written</li>\n  <li>fierce discussions about technology choices (Guice vs Spring, Maven vs Gradle, Jetty vs Undertow)</li>\n</ul>\n\n<p>What followed in 2014 (this is the part I could already experience in person):</p>\n<ul>\n  <li>various self-service tools allowing developers to handle common tasks such as creating databases themselves rather than by involving specialized support teams</li>\n  <li>automation tools</li>\n  <li>development of <a href=\"https://hermes.allegro.tech/\">Hermes</a>, our open-source message broker built on top of Kafka, started</li>\n  <li>strategic DDD training with Eric Evans</li>\n  <li><a href=\"/2014/12/How-to-migrate-to-Java-8.html\">migration to Java 8</a></li>\n  <li>global architecture improvements</li>\n  <li><a href=\"https://allegro.tech/\">allegro.tech</a>, the project to coordinate the visibility of our tech division online and offline, of which this blog is a part,\nstarted</li>\n  <li>SRE team created</li>\n  <li><a href=\"/2016/09/CQK-TOP-10.html\">CQK (Code Quality Keepers) guild</a> opened</li>\n  <li>first Java services deployed to production</li>\n  <li>intense recruitment and learning</li>\n</ul>\n\n<p>The number of both production services and of tools supporting developers’ work that got created thereafter is staggering. It should be clear from just the\nlist above that this was a huge investment, and could only proceed due to full buy-in of both technology and business parts of the company. It was indeed a\ngamble, well-informed, but still a gamble that carried big risk should it fail, but an even greater risk if we were to stay with the old architecture.</p>\n\n<p>At this point you probably can see that actually building microservices seems like a minor part of the whole undertaking. There was a lot of work to\nwriting so many parts of this huge system anew, but indeed the amount of work that we had to invest into\n<a href=\"/2016/02/datacenter-migration-great-adventure.html\">infrastructure</a>,\n<a href=\"/2018/10/turnilo-lets-change-the-way-people-explore-big-data.html\">tooling</a>, and\n<a href=\"/2016/09/are-code-reviews-worth-your-time.html\">learning</a>, was immense. It was also absolutely critical for the project’s success. A lot has been\nsaid about microservices, and it is true that for them to be beneficial, you need the right scale and the right kind of system. We had both, and so the decision\nto move to microservices proved to be worthwhile, but despite knowing the theory, I think no one expected the amount of auxiliary work to be so huge. Indeed,\nwhile microservices themselves may be simple, the glue that holds them together is not.</p>\n\n<h2 id=\"flashbacks\">Flashbacks</h2>\n\n<p>Summarizing ten years of rapid development is tough, so instead of trying to tell you the full story, I decided to share a few flashbacks: moments which I\nremembered for one reason or another.</p>\n\n<h3 id=\"no-ing-sql\">No-ing SQL</h3>\n\n<p><img src=\"/img/articles/2024-04-12-ten-years-microservices/tobias-fischer-PkbZahEG2Ng-unsplash.jpg\" alt=\"Huge modern library filled with books\" class=\"small-image-right\" />\nWhen <a href=\"/2015/01/working-with-legacy-architecture.html\">refactoring our huge monolith into smaller microservices</a>, we needed to also choose the\ndatabase to use for each of them. Since horizontal scalability was our focus, we preferred <a href=\"https://en.wikipedia.org/wiki/NoSQL\">NoSQL databases</a> when possible.\nThis was a big change since the monolithic solution relied on a single, huge SQL database. On top of that, it was not modularized well, and in many places\nthere was little or no separation between domain and persistence layers. If the monolith was structured well, splitting it into separate services would have\nbeen much easier. Unfortunately, this was not the case, so we had to perform the transition to NoSQL together with other refactorings and cleanup. Usually,\nwe had to deeply remodel data and operations handling it, especially transactional, so that they could be executed in the new environment. This was often\na significant effort even if we could divide the code in such way that the transaction or set of related operations ended up within the same service. Things\nbecame even more complicated if an operation spanned multiple services (and databases) in the new architecture. This is one of the reasons why dividing a\nbig application into smaller chunks is much harder than it may seem at first.</p>\n\n<p><a href=\"https://cassandra.apache.org/\">Cassandra</a> was initially our preferred NoSQL database for most tasks. Only after a while did we learn that each database is good\nfor some use cases and bad for others, and that we needed <a href=\"https://en.wikipedia.org/wiki/Polyglot_persistence\">polyglot persistence</a> to achieve high performance\nand get the required flexibility in all cases. The team I worked on was among the first Cassandra adopters at the company, and as is often the case when\nyou run something in production for the first time, we uncovered a number of issues in our Cassandra deployment which was “ready” but not tested in production\nyet. The team responsible for the DB was learning completely new stuff just as we were.</p>\n\n<p>An argument sometimes put up against the need to separate your application’s persistence layer from the domain logic is “you’re never going to switch out the\nDB for another one anyway”. Most of the time that’s true, but in one service we did have to switch from Cassandra to <a href=\"https://www.mongodb.com/\">MongoDB</a>\nafter we found out our access patterns were not very well aligned with Cassandra’s data model. We managed to do it inside a single two-week sprint, and\napart from the service becoming faster, its clients would not notice any difference as the external API stayed the same. While the (usually theoretical)\nprospect of switching databases is not the only reason for decoupling domain and persistence layers, it did help a lot in this case, and it is about this\ntime I started to understand why we were creating so many classes even though you could just cram all that code into one.</p>\n\n<p>I also managed to kill our Cassandra instance once when I was learning about big data processing and created a job that was supposed to process some data from\nthe DB. The job was so massively parallel that the barrage of requests it generated overwhelmed even Cassandra. Fortunately, this situation also showed the\nadvantage of having separate databases for each service, as only that single service experienced an outage.</p>\n\n<h3 id=\"into-the-cloud\">Into the cloud</h3>\n\n<p><img src=\"/img/articles/2024-04-12-ten-years-microservices/thisisengineering-raeng-zBLtU0zbJcU-unsplash.jpg\" alt=\"Engineer plugging in network cables into servers\" class=\"small-image-right\" />\nBefore joining Allegro, I had only deployed to physical servers, so moving to the cloud was a big change. At first, we deployed our services to virtual\nmachines configured in <a href=\"https://www.openstack.org/\">OpenStack</a>. What a convenience it was to be able to just set up a complete virtual server with a few\nclicks rather than wait days for a physical machine. We used <a href=\"https://www.puppet.com/\">Puppet</a> to fully configure the virtual machines for each service, so\nwhile you had to write some configuration once, you could spin up a new server configured for your service almost instantly afterwards.</p>\n\n<p>This <a href=\"https://en.wikipedia.org/wiki/Infrastructure_as_a_service\">IaaS (Infrastructure as a Service)</a> approach was very convenient, and quite a change, but in\nmany ways it still resembled what I had known before: you had a machine, even if virtual, and you could <code class=\"language-plaintext highlighter-rouge\">ssh</code> and run any commands there if you wanted, even\nif it was rarely needed since Puppet set up everything for you.</p>\n\n<p>The real revolution came when we switched to <a href=\"https://en.wikipedia.org/wiki/Platform_as_a_service\">PaaS (Platform as a Service)</a> model, at that time based on\n<a href=\"https://mesos.apache.org/\">Mesos</a> and <a href=\"https://mesosphere.github.io/marathon/\">Marathon</a>. Suddenly, there were no more virtual machines, and you could not <code class=\"language-plaintext highlighter-rouge\">ssh</code>\nto the server where your software was running. For me, this was a real culture shock, and even though up to this point I was very enthusiastic about all the\ncool technology we were introducing, the thought of <em>no more <code class=\"language-plaintext highlighter-rouge\">ssh</code></em> freaked me out. How would I know what was going on in the system if I couldn’t even access\nit? Despite my reservations, I gradually found out you could indeed deploy and monitor software despite not being able to access the machine via <code class=\"language-plaintext highlighter-rouge\">ssh</code>. It\nsounds weird in retrospect, but this was one of the most difficult technological transitions in my career.</p>\n\n<p>After a while, we built some abstraction layers on top of Mesos, including a custom <em>app console</em> that allows you to deploy a service and perform all\nmaintenance tasks. It isolates you from most details of the underlying system, and is so effective that when we migrated from Mesos to <a href=\"https://kubernetes.io/\">Kubernetes</a>\nlater on, the impact on most teams was much smaller that you could imagine for such a big change. Our App Console is an internal project, but if you are\nfamiliar with <a href=\"https://backstage.spotify.com/learn/backstage-for-all/backstage-for-all/1-introduction/\">Backstage</a>, it should give you an idea of what kind\nof tool we’re talking about here.</p>\n\n<h3 id=\"monitoring\">Monitoring</h3>\n\n<p><img src=\"/img/articles/2024-04-12-ten-years-microservices/carlos-muza-hpjSkU2UYSU-unsplash.jpg\" alt=\"Laptop displaying various charts\" class=\"small-image-right\" />\nBelieve it or not, initially all monitoring was centralized and handled by a single team. If you wanted to have any non-standard charts in\n<a href=\"https://www.zabbix.com/\">Zabbix</a> or any custom alerts (and obviously, you wanted to), you had to create a ticket in JIRA, describe exactly what you wanted,\nand after a while, the monitoring team would set it up for you. The whole process took about a week, and quite often, right after seeing the new chart you\nknew you wanted to improve it, so you would file another ticket and wait another week. Needless to say, this was incredibly frustrating, and I consider it\none of my early big successes when I kept pushing the monitoring team until they finally gave in and allowed development teams to configure all of their\nobservability settings themselves.</p>\n\n<h3 id=\"going-polyglot\">Going polyglot</h3>\n\n<p><img src=\"/img/articles/2024-04-12-ten-years-microservices/azamat-e-FP_N_InBPdg-unsplash.jpg\" alt=\"Man working on two laptops at the same time\" class=\"small-image-right\" />\nWhile Rubicon started out with the premise of rewriting our software in Java, we quickly started experimenting with other JVM languages. The team I worked\non considered Scala for a while, but after some experimentation decided against using it as our main language. Some other teams, however, did choose it, and\neven though they are a minority at Allegro, we have some microservices written in Scala to this day. On the other hand, Scala is the dominant language at\nAllegro when it comes to writing <a href=\"https://spark.apache.org/\">Spark</a> jobs.</p>\n\n<p>Some time around 2015, a teammate found out there was a relatively new, but promising, language called <a href=\"https://kotlinlang.org/\">Kotlin</a>. It so happened that we\nwere just starting work on a new microservice which was still very simple and not quite critical. He decided to use it as a testbed, and within I think two days\nrewrote the whole thing in Kotlin. Thanks to the services being independent and this one not being very important yet, we could safely experiment in production\nand assess the stability of the rewritten service. Learning the language by writing actual production-ready code rather than just playing with throw-away code\nallowed us to check what advantages and disadvantages the language offered under realistic usage scenarios. Kotlin caught on, and gradually we started to use\nit for more and more new services and to use it for new features in existing Java services as mixing the two was easy. Many services already used\n<a href=\"https://groovy-lang.org/\">Groovy</a> and <a href=\"https://spockframework.org/\">Spock</a> for tests anyway. At this point, Kotlin is more popular than Java at Allegro, and\non our blog we published <a href=\"/2016/06/kotlin-null-safety-part1.html\">some</a> articles <a href=\"/2021/04/kotlin-scripting.html\">about Kotlin</a>,\nincluding <a href=\"/2018/05/From-Java-to-Kotlin-and-Back-Again.html\">one</a> which unfortunately stirred a lot of controversy, and caused a (deserved IMO)\nshitstorm both inside and outside the company.</p>\n\n<p>Besides JVM languages, we by now have also microservices written in <a href=\"/2020/03/dotnet-new-templates.html\">C#</a>,\n<a href=\"/2016/03/writing-fast-cache-service-in-go.html\">Go</a>, <a href=\"/2022/01/how-do-coroutines-work-internally-in-python.html\">Python</a>,\n<a href=\"https://elixir-lang.org/\">Elixir</a>, and probably a few more languages I forgot to mention. This is just the backend, but our\n<a href=\"/2016/03/Managing-Frontend-in-the-microservices-architecture.html\">frontend architecture</a> also allows for components written in various\nlanguages. And besides customer-facing business code, there are also internal tools and utilities, sometimes written using yet other general-purpose languages\nand <a href=\"https://en.wikipedia.org/wiki/Domain-specific_language\">DSL</a>s. Finally, there’s the whole world of AI, including prompting for generative AI that you\ncan also consider a programming language of sorts.</p>\n\n<p>The main point I want to make here is that using microservices has allowed us to safely experiment with various programming languages, to consciously limit\nthe blast radius of those experiments should anything go wrong, and to perform all transitions gradually. Of course, this all has a purpose: finding the\nbest tool for the job, and using all the different languages’ strengths where they can help us most. It is not about introducing new tools just for the sake\nof it, which would cause but chaos and introduce risks related to future maintenance. I think the autonomy teams get in making technical decisions, yet\ncombined with responsibility for the outcomes, is what allows us to learn and find new ways of doing things while at the same time it limits the risks\nassociated with experimenting. As in many other cases, things work well when the organization’s ways of working (team autonomy) are aligned with technical\nsolutions (microservices).</p>\n\n<h3 id=\"using-antipatterns-wisely\">Using antipatterns wisely</h3>\n\n<p><img src=\"/img/articles/2024-04-12-ten-years-microservices/alexander-schimmeck-kpihcevjT5w-unsplash.jpg\" alt=\"Two men performing a dangerous stunt on a bicycle\" class=\"small-image-right\" />\n<a href=\"/2016/01/microservices-and-macro-mistakes.html\">Good practices</a> are heuristics: most of the time, following them is a good idea. For example,\ntwo microservices should not share database tables since this introduces tight coupling: you can’t introduce a change to the schema and deploy just one service\nbut not the other. Your two services are not independent, but form a distributed monolith instead. Avoiding such situations is just common sense.</p>\n\n<p>Still, you should always keep in mind the reasons why a good practice exists, what it protects you from and what costs it introduces. At one point we had a\ndiscussion within our team about how to best handle a peculiar performance issue. Our service connected to an Elasticsearch instance and performed two kinds\nof operations: reads and writes. Reads were much more numerous, but writes introduced heavy load (on the service itself — Elastic could handle it). Writes\ncame in bursts, so most of the time things worked well, but when a burst of writes arrived, performance of the whole service suffered and read times were\naffected. We tried various mechanisms for isolating the two kinds of operation, but couldn’t do it effectively.</p>\n\n<p>A colleague suggested we split the service in two, one responsible for handling reads and the other for writes. We had a long discussion, in which I\npresented arguments for having a single service as the owner of the data, responsible for both reads and writes, and highlighted what issues could arise due to\nthe split. While keeping the service intact seemed to be the elegant thing to do, I didn’t have a good solution for the performance issue. My colleague’s\nidea to split the service, on the other hand, while somewhat messy, did offer a chance to solve it.</p>\n\n<p>So, we decided to just try it and see whether this approach would solve the performance issue and how bad the side effects would be. We did just that, and the\nantipattern-based solution worked great: performance hiccups went away, and despite sharing the common Elasticsearch cluster, the two services remained\nmaintainable. We were not able to fully assess this aspect right away, but time proved my colleague right as well: during the 3+ years we worked with that\ncodebase later on, we only ran into issues related to sharing Elasticsearch once, and we managed to fix that case quickly. It certainly did help, though, that\nboth services kept being developed by the same team, and that by the time we introduced the split, the schema was already quite stable and did not change often.\nNonetheless, had I insisted on keeping things clean, we would have probably spent much more time fighting performance issues than we lost during the single\nissue that resulted from sharing Elasticsearch between services. Know when to use patterns, know when to use antipatterns, and use both wisely.</p>\n\n<h3 id=\"one-size-does-not-fit-all\">One size does not fit all</h3>\n\n<p><img src=\"/img/articles/2024-04-12-ten-years-microservices/brianna-r-_-54wJzpH6Q-unsplash.jpg\" alt=\"Adult lion with cub\" class=\"small-image-right\" />\nI think we’ve always been quite pragmatic about sizing our microservices. It’s hard to define a set of specific rules for finding the right size, but going\ntoo far in one direction or the other causes considerable pain. Make a service huge, and it becomes too hard for a single team to maintain and develop, or\nscaling issues arise similar to those you could experience with a monolith. Make it very small, and you might get overwhelmed by the overhead of having your\nlogic split between too many places, issues with debugging, and the performance penalty of the system being distributed to the extreme.</p>\n\n<p>Most services I got to work on at Allegro were not too tiny, and contained some non-trivial amount of logic. There were sometimes agitated discussions about\nwhere to implement a certain feature, in particular whether it should be in an existing service or in a new one. In hindsight, I think most decisions made\nsense, but there were certainly cases where a feature that we believed would grow ended up in a new service which then never took off and remained too small,\nand cases where something was bolted onto an existing service because it was easier to implement this way, but which caused some pain later on.</p>\n\n<p>I think I only once saw a team fall into the nanoservice trap where services were designed so small the split caused more trouble than it was worth. On the\nother hand, there were certainly services which you could no longer call <em>micro</em> by any stretch. This was not necessarily a bad thing. As long as a service\nfulfilled a well-defined role, a single team was enough to take care of it, and it was OK that you had to deploy and scale the whole thing together, things\nwere fine. In some cases of services which grew really much too big (indicators being that they contained pieces of logic only very loosely related to each\nother, and that at some point multiple teams were regularly interested in contributing), we did get back to them and split them up. It was not very easy,\nbut doable, and the second-hardest part was usually finding the right lines along which to divide. The only thing harder was finding the time to perform\nsuch operations, but with a bit of negotiation and persistence, after a while we usually succeeded.</p>\n\n<p>There is an ongoing discussion of whether we have too many microservices. It’s not an urgent thing, but there are reasons to not go too high, such as\ncertain technical limitations in the infrastructure and the cost of overprovisioning (each service allocates resources such as memory or CPUs with a margin,\nand those margins add up). Still, the fact that we are well above a thousand services and yet their number is only a minor nuisance, speaks well of our\ntooling and organization. Indeed, thanks to some custom tools, creating a new service is very easy (maybe too easy?), and managing those already there is\nalso quite pleasant. This is possible due to huge investments we made early on (and continue): we knew right from the start that while each microservice may\nbe relatively simple, a lot of complexity goes into the glue that holds the whole system together. Without it, things would not quite work so well. Another\nfactor is, obviously, that our system has an actual use case for microservices: we have hundreds of teams, a system that keeps growing in capacity and\ncomplexity, and scale that makes a truly distributed system necessary. I think much of the anti-microservice sentiment you see around the internet today\nstems from treating microservices as a silver bullet that you can apply to any problem regardless of whether they actually make sense in given situation, or\nfrom not being aware that they can bring huge payoffs but also require great investments. There is a good summary of the advantages and disadvantages of\nmicroservices <a href=\"https://about.gitlab.com/blog/2022/09/29/what-are-the-benefits-of-a-microservices-architecture/\">in this Gitlab blog post</a>.</p>\n\n<h3 id=\"service-mesh-and-common-libraries\">Service Mesh and common libraries</h3>\n\n<p><img src=\"/img/articles/2024-04-12-ten-years-microservices/nasa-Q1p7bh3SHj8-unsplash.jpg\" alt=\"City lights visible from space\" class=\"small-image-right\" />\nProbably the most recent really significant change related to our microservice ecosystem was the <a href=\"/2020/05/migrating-to-service-mesh.html\">migration to service mesh</a>.\nFrom developers’ perspective it did not seem all that radical, but it required a lot of work from infrastructure teams. The most important gain is the\npossibility to control some aspects of services’ behavior in a single place. For example, originally if you wanted to have secure connections between\nservices, you had to support <a href=\"https://en.wikipedia.org/wiki/Transport_Layer_Security\">TLS</a> in code, using common libraries. With service mesh, you can just\nenable it globally without the developers even having to know. This makes maintaining the huge ecosystem that consists of more than a thousand services much\nmore bearable.</p>\n\n<p>Each microservice needs certain behaviors in order to work well within our environment. For example, it needs a healthcheck endpoint which allows Kubernetes\nto tell if the service instance is working or not. We have a written Microservice Contract which defines those requirements. There are also features that are\nnot strictly necessary, but which many services will find useful, for example various metrics. Our initial approach was to have a set of common libraries\nthat provided both the required and many of the nice-to-have features. Of course, if you can’t or don’t want to use those libraries, you are free to do so, as\nlong as your service implements the Microservice Contract some other way.</p>\n\n<p>Over time, the role of those libraries has changed, with the general direction being that of reducing their scope. There are several reasons.</p>\n\n<p>Reason number one is more and more features can be moved to infrastructure layer, of which Service Mesh is an important part. For example, originally\ncommunicating with another service required a service discovery client, implemented in a shared library.  Now, all this logic has been delegated to the\nService Mesh and requires no special support in shared libraries or service code.</p>\n\n<p>Another reason is that open source libraries have caught on and some features we used to need to implement ourselves, such as certain metrics, are now\navailable out of the box in Spring Boot or other frameworks. There is no point in reinventing the wheel and having more code to maintain.</p>\n\n<p>Finally, the problem with libraries is that updating a library in 1000+ services is a slow and costly process. Meanwhile, a feature that the Service Mesh\nprovides can be switched on or reconfigured for all services almost instantly.</p>\n\n<p>Despite common libraries falling out of favor with us, there are some features that are hard to implement in infrastructure alone. Even with a simple\nfeature such as logging, sometimes we need data that only code running within the services has access to. When we want to fill in certain standard fields in\norder to make searching logs easier, some fields, such as <code class=\"language-plaintext highlighter-rouge\">host</code> or <code class=\"language-plaintext highlighter-rouge\">dc</code>, can easily be filled in by the infrastructure, but some, such as <code class=\"language-plaintext highlighter-rouge\">thread_name</code> are\nonly known inside the service and can’t be handled externally. Thus, the role of libraries is diminished but not completely eliminated. In order to make\nworking with shared libraries less cumbersome, we are working on ways to automate upgrades as much as possible so that we can keep all versions up to date\nwithout it costing too much developers’ time.</p>\n\n<h3 id=\"learning\">Learning</h3>\n\n<p><img src=\"/img/articles/2024-04-12-ten-years-microservices/thought-catalog-mmWqrsjZ4Lw-unsplash.jpg\" alt=\"Person reading\" class=\"small-image-right\" />\nDuring the transition, Allegro invested in learning and development heavily. Daily work was full of learning opportunities since everything we were doing\nwas quite new, and many approaches and technologies were not mature yet. We were really on the cutting edge of technology, so for many problems there were\nsimply no run-of-the-mill solutions yet. We were already several years into the microservice transition when microservices became a global hype.</p>\n\n<p>Since everybody was well aware of what an ambitious plan we were pursuing, it was also well understood that some things took experimenting, and while of\ncourse we were expected to ship value, there was a company-wide understanding that time for learning, <a href=\"/2019/09/team-tourism-at-allegro.html\">team tourism</a>,\ntrying out new things, and sometimes failing, were necessary for success. One of the things I really enjoyed was the focus on quality and doing things right.\nBusiness understood this as well, and actually at one point when Rubicon was quite advanced, developers were granted a 6-month grace period during which we\ncould focus on just technical changes without having to deliver any business value. As a matter of fact, many business logic changes were delivered anyway. For\nexample, the team I was on created a microservice-based approach to handling payments which was much more flexible than the old solution, so it was not just a\nrefactoring, but rather a rewrite that took new business requirements into account.</p>\n\n<p>Apart from learning by doing, we also invested in organized training and conferences. We bought a number of dedicated training sessions with\n<a href=\"/2015/07/it-stars.html\">established experts</a> from Silicon Valley on topics such as software architecture and JVM performance. Pretty much\neveryone could attend at least one good conference each year, and we also sponsored a number of developer-centric events in order to gain visibility and attract\ngood hires. About a year into my job, I got to attend JavaOne in San Francisco, whose scale and depth trumped even the biggest conferences I knew from Europe.\nAfter attending a few conferences, I decided to give speaking myself a try, and was able to take advantage of a number of useful trainings to help me with that.\nWe also started the <a href=\"https://allegro.tech/\">allegro.tech</a> initiative in order to organize all the activity used to promote our brand, and this blog is one\nof the projects that we run under the allegro.tech umbrella to this day.</p>\n\n<h3 id=\"the-cycle-of-life\">The cycle of life</h3>\n\n<p>In 2022, a service I had worked on when I first started at Allegro was shut down due to being replaced with a newer solution. This way, I witnessed the\nfull lifecycle of a service: building it from scratch, adding more features to the mature solution, maintenance, and finally seeing it discontinued. It was\nreally a great experience to see that something I had built had run its course and I could be there to see the whole cycle.</p>\n\n<h2 id=\"takeaways\">Takeaways</h2>\n\n<p><img src=\"/img/articles/2024-04-12-ten-years-microservices/pyramids.jpg\" alt=\"Pyramids of Egypt\" class=\"small-image-right\" />\nWhen we started out working with microservices, we were well aware of their benefits but also of their cost. The famous\n<a href=\"https://martinfowler.com/bliki/MicroservicePrerequisites.html\">You must be this tall to use microservices</a> image adorned many of our presentations at that\ntime. By taking a realistic stance, we avoided many pitfalls. Our transition to the microservice world took several years, but was successful, and I am\ncertain we would be in a much worse place had the company not made that bold decision. Apart from being a huge technical challenge, it was also a great\ntransformation in our way of thinking and in the way we work together. <a href=\"https://en.wikipedia.org/wiki/Conway%27s_law\">Conway’s Law</a> applies and the change\nin system architecture was possible only together with a change in company architecture. It was also possible thanks to many smart people with whom I had\nthe pleasure to work over these years.</p>\n\n<p>When I look back, I see how far we have come. Creating a new service used to take a week or two at first, and now it takes minutes. Scaling a service required\na human operator, creating virtual machines, and manually adding them to the monitoring system. Today, an autoscaler handles most services and developers\ndo not even need to know that instances were added or removed. Our tooling is really convenient, even though there are things we could improve, and some\ncomponents are already showing signs of aging. Nonetheless, many things that used to be a challenge, are trivial today. New joiners at the company can\nbenefit from all these conveniences right from the start, and sometimes I think they might not fully appreciate them since they never had to perform all\nthat work manually.</p>\n\n<p>The world does not stand still, though. Technologies change, and some assumptions we made when planning our architecture ten years ago, have already had to\nbe updated. Our system has grown, and so has the company, so many issues we are dealing with now are different from those that troubled us in the beginning\nof Project Rubicon. Initially, everything was a greenfield project, but by now, some places have accumulated bit rot and need cleanup. The system is much\nbigger (which microservices enabled) so introducing changes gets harder (still, much easier than it would be within a monolith). And since ten\nyears is a lot of time, many people have moved through the company, so <a href=\"/2023/10/battle-against-knowledge-loss.html\">knowledge transfer and continued learning</a>\nare still essential. Only change is certain, and this has not changed a bit. I’m happy I could experience the heroic age of microservices myself, and I’m\nlooking forward to whatever comes next.</p>\n","contentSnippet":"In early 2024, I hit ten years at Allegro, which also happens to be how long I’ve been working with microservices.\nThis timespan also roughly corresponds to how long the company as a whole has been using them, so I think it’s a good time to outline the story of project\nRubicon: a very ambitious gamble which completely changed how we work and what our software is like. The idea probably seemed rather extreme at the time, yet I\nam certain that without this change, Allegro would not be where it is today, or perhaps would not be there at all.\nBackground\nAllegro is one of the largest e-commerce sites in Central Europe, with 20 million users and over 300 million\noffers. It was founded in 1999, originally with just the Polish market in mind. The story I want to tell you starts in 2013, a year before I joined.\n\nIn 2013, the site was already large and relevant, but its commercial success and further growth led to development bottlenecks emerging. The codebase was a\nmonolithic PHP application, with some auxiliary processes written in C. Checked out, the git monorepo weighed about 2 GB, and the number of pull requests\nproduced daily by a few hundred developers was so large that if you started a new branch in the morning, you were almost sure to get some conflicts if you\nwanted to merge in the afternoon. The system was centered around a single, huge database, with all the performance and architectural challenges you can imagine.\nTests were brittle and took ages to finish. Deployment was a mostly manual and thus time-consuming processes that required lots of attention and ran the risk of\ncausing a serious problem in production if something went wrong. It was so demanding and stressful I still remember my team having to run the deployment once\n(in place of the usual deployers) as a big event.\nRubicon Rises\n\nIt was becoming clear that we would hit a wall if we continued working this way. So, around 2012/2013, the idea for a complete overhaul of the architecture\nstarted to emerge. We began experimenting with SOA (Service-Oriented Architecture) by\ncreating a small side project, the so-called New Platform, in PHP, as a proof-of-concept. We also decided we would start doing\nAgile, TDD, and\nCloud. After a short while, on top of this, we decided to switch to Java for backend development.\nIt was becoming clear that it would be a revolution indeed, requiring everyone to change\nthe way they worked, and to switch out the whole development ecosystem, starting with the core programming language. Once we got this going, there would be\nno turning back, so a matching name also appeared: Project Rubicon.\nThe project had such a broad scope that it even came with its own constitution, a set of high-level guidelines to be used in case of doubt. It focused mostly\non ways of working and highlighted the value of learning (on personal, team, and company level), testing, reuse, empirical approach to software development,\nand active participation in the open-source community both as users and as contributors. Specific technical assumptions included:\nfocus on quality\nmicroservices\ndistributed, multi-regional, active-active architecture\nJava\ncloud deployment\nusing open-source technologies\nThere was also a list of success criteria for the project:\nthe monolith is gone\nwe have Java gurus on board\nwe have services\ndevelopment is faster\nwe have continuous delivery\nwe don’t have another monolith\nwe still make money\nFaster development was probably the most important goal, since slow delivery was the direct reason we embarked on this long journey.\nOn top of these lists, more detailed plans were made as well, of course. For example, various parts of the system were prioritized for moving out of the\nmonolith as we were well aware we would not be able to work on everything at once. Being Agile does not mean planning is to be avoided, only that plans have\nto be flexible. So, armed with a plan, we got off to work.\nExecution\n\nToo much has happened during the 10+ years to report here. The initial period was really frantic since we had to set up everything, and, first of all, teams had\nto switch to a new mindset. This was also a period of intense hiring, and the time I joined the recently opened office in Warsaw. Microservices were at that\ntime only starting to gain traction, so while we used the experiences of others as much has possible, we had to learn many things ourselves, sometimes learning\nthem the hard way.\nTo give you an idea of the pace, here are just some of the things that happened in 2013:\noutline of the common architecture (service discovery, logging) created\na set of common libraries created (presentation from 2016)\ntraining in Java and JVM for PHP developers\nrecruitment of Java developers started\nfirst Java code got written\nfierce discussions about technology choices (Guice vs Spring, Maven vs Gradle, Jetty vs Undertow)\nWhat followed in 2014 (this is the part I could already experience in person):\nvarious self-service tools allowing developers to handle common tasks such as creating databases themselves rather than by involving specialized support teams\nautomation tools\ndevelopment of Hermes, our open-source message broker built on top of Kafka, started\nstrategic DDD training with Eric Evans\nmigration to Java 8\nglobal architecture improvements\nallegro.tech, the project to coordinate the visibility of our tech division online and offline, of which this blog is a part,\nstarted\nSRE team created\nCQK (Code Quality Keepers) guild opened\nfirst Java services deployed to production\nintense recruitment and learning\nThe number of both production services and of tools supporting developers’ work that got created thereafter is staggering. It should be clear from just the\nlist above that this was a huge investment, and could only proceed due to full buy-in of both technology and business parts of the company. It was indeed a\ngamble, well-informed, but still a gamble that carried big risk should it fail, but an even greater risk if we were to stay with the old architecture.\nAt this point you probably can see that actually building microservices seems like a minor part of the whole undertaking. There was a lot of work to\nwriting so many parts of this huge system anew, but indeed the amount of work that we had to invest into\ninfrastructure,\ntooling, and\nlearning, was immense. It was also absolutely critical for the project’s success. A lot has been\nsaid about microservices, and it is true that for them to be beneficial, you need the right scale and the right kind of system. We had both, and so the decision\nto move to microservices proved to be worthwhile, but despite knowing the theory, I think no one expected the amount of auxiliary work to be so huge. Indeed,\nwhile microservices themselves may be simple, the glue that holds them together is not.\nFlashbacks\nSummarizing ten years of rapid development is tough, so instead of trying to tell you the full story, I decided to share a few flashbacks: moments which I\nremembered for one reason or another.\nNo-ing SQL\n\nWhen refactoring our huge monolith into smaller microservices, we needed to also choose the\ndatabase to use for each of them. Since horizontal scalability was our focus, we preferred NoSQL databases when possible.\nThis was a big change since the monolithic solution relied on a single, huge SQL database. On top of that, it was not modularized well, and in many places\nthere was little or no separation between domain and persistence layers. If the monolith was structured well, splitting it into separate services would have\nbeen much easier. Unfortunately, this was not the case, so we had to perform the transition to NoSQL together with other refactorings and cleanup. Usually,\nwe had to deeply remodel data and operations handling it, especially transactional, so that they could be executed in the new environment. This was often\na significant effort even if we could divide the code in such way that the transaction or set of related operations ended up within the same service. Things\nbecame even more complicated if an operation spanned multiple services (and databases) in the new architecture. This is one of the reasons why dividing a\nbig application into smaller chunks is much harder than it may seem at first.\nCassandra was initially our preferred NoSQL database for most tasks. Only after a while did we learn that each database is good\nfor some use cases and bad for others, and that we needed polyglot persistence to achieve high performance\nand get the required flexibility in all cases. The team I worked on was among the first Cassandra adopters at the company, and as is often the case when\nyou run something in production for the first time, we uncovered a number of issues in our Cassandra deployment which was “ready” but not tested in production\nyet. The team responsible for the DB was learning completely new stuff just as we were.\nAn argument sometimes put up against the need to separate your application’s persistence layer from the domain logic is “you’re never going to switch out the\nDB for another one anyway”. Most of the time that’s true, but in one service we did have to switch from Cassandra to MongoDB\nafter we found out our access patterns were not very well aligned with Cassandra’s data model. We managed to do it inside a single two-week sprint, and\napart from the service becoming faster, its clients would not notice any difference as the external API stayed the same. While the (usually theoretical)\nprospect of switching databases is not the only reason for decoupling domain and persistence layers, it did help a lot in this case, and it is about this\ntime I started to understand why we were creating so many classes even though you could just cram all that code into one.\nI also managed to kill our Cassandra instance once when I was learning about big data processing and created a job that was supposed to process some data from\nthe DB. The job was so massively parallel that the barrage of requests it generated overwhelmed even Cassandra. Fortunately, this situation also showed the\nadvantage of having separate databases for each service, as only that single service experienced an outage.\nInto the cloud\n\nBefore joining Allegro, I had only deployed to physical servers, so moving to the cloud was a big change. At first, we deployed our services to virtual\nmachines configured in OpenStack. What a convenience it was to be able to just set up a complete virtual server with a few\nclicks rather than wait days for a physical machine. We used Puppet to fully configure the virtual machines for each service, so\nwhile you had to write some configuration once, you could spin up a new server configured for your service almost instantly afterwards.\nThis IaaS (Infrastructure as a Service) approach was very convenient, and quite a change, but in\nmany ways it still resembled what I had known before: you had a machine, even if virtual, and you could ssh and run any commands there if you wanted, even\nif it was rarely needed since Puppet set up everything for you.\nThe real revolution came when we switched to PaaS (Platform as a Service) model, at that time based on\nMesos and Marathon. Suddenly, there were no more virtual machines, and you could not ssh\nto the server where your software was running. For me, this was a real culture shock, and even though up to this point I was very enthusiastic about all the\ncool technology we were introducing, the thought of no more ssh freaked me out. How would I know what was going on in the system if I couldn’t even access\nit? Despite my reservations, I gradually found out you could indeed deploy and monitor software despite not being able to access the machine via ssh. It\nsounds weird in retrospect, but this was one of the most difficult technological transitions in my career.\nAfter a while, we built some abstraction layers on top of Mesos, including a custom app console that allows you to deploy a service and perform all\nmaintenance tasks. It isolates you from most details of the underlying system, and is so effective that when we migrated from Mesos to Kubernetes\nlater on, the impact on most teams was much smaller that you could imagine for such a big change. Our App Console is an internal project, but if you are\nfamiliar with Backstage, it should give you an idea of what kind\nof tool we’re talking about here.\nMonitoring\n\nBelieve it or not, initially all monitoring was centralized and handled by a single team. If you wanted to have any non-standard charts in\nZabbix or any custom alerts (and obviously, you wanted to), you had to create a ticket in JIRA, describe exactly what you wanted,\nand after a while, the monitoring team would set it up for you. The whole process took about a week, and quite often, right after seeing the new chart you\nknew you wanted to improve it, so you would file another ticket and wait another week. Needless to say, this was incredibly frustrating, and I consider it\none of my early big successes when I kept pushing the monitoring team until they finally gave in and allowed development teams to configure all of their\nobservability settings themselves.\nGoing polyglot\n\nWhile Rubicon started out with the premise of rewriting our software in Java, we quickly started experimenting with other JVM languages. The team I worked\non considered Scala for a while, but after some experimentation decided against using it as our main language. Some other teams, however, did choose it, and\neven though they are a minority at Allegro, we have some microservices written in Scala to this day. On the other hand, Scala is the dominant language at\nAllegro when it comes to writing Spark jobs.\nSome time around 2015, a teammate found out there was a relatively new, but promising, language called Kotlin. It so happened that we\nwere just starting work on a new microservice which was still very simple and not quite critical. He decided to use it as a testbed, and within I think two days\nrewrote the whole thing in Kotlin. Thanks to the services being independent and this one not being very important yet, we could safely experiment in production\nand assess the stability of the rewritten service. Learning the language by writing actual production-ready code rather than just playing with throw-away code\nallowed us to check what advantages and disadvantages the language offered under realistic usage scenarios. Kotlin caught on, and gradually we started to use\nit for more and more new services and to use it for new features in existing Java services as mixing the two was easy. Many services already used\nGroovy and Spock for tests anyway. At this point, Kotlin is more popular than Java at Allegro, and\non our blog we published some articles about Kotlin,\nincluding one which unfortunately stirred a lot of controversy, and caused a (deserved IMO)\nshitstorm both inside and outside the company.\nBesides JVM languages, we by now have also microservices written in C#,\nGo, Python,\nElixir, and probably a few more languages I forgot to mention. This is just the backend, but our\nfrontend architecture also allows for components written in various\nlanguages. And besides customer-facing business code, there are also internal tools and utilities, sometimes written using yet other general-purpose languages\nand DSLs. Finally, there’s the whole world of AI, including prompting for generative AI that you\ncan also consider a programming language of sorts.\nThe main point I want to make here is that using microservices has allowed us to safely experiment with various programming languages, to consciously limit\nthe blast radius of those experiments should anything go wrong, and to perform all transitions gradually. Of course, this all has a purpose: finding the\nbest tool for the job, and using all the different languages’ strengths where they can help us most. It is not about introducing new tools just for the sake\nof it, which would cause but chaos and introduce risks related to future maintenance. I think the autonomy teams get in making technical decisions, yet\ncombined with responsibility for the outcomes, is what allows us to learn and find new ways of doing things while at the same time it limits the risks\nassociated with experimenting. As in many other cases, things work well when the organization’s ways of working (team autonomy) are aligned with technical\nsolutions (microservices).\nUsing antipatterns wisely\n\nGood practices are heuristics: most of the time, following them is a good idea. For example,\ntwo microservices should not share database tables since this introduces tight coupling: you can’t introduce a change to the schema and deploy just one service\nbut not the other. Your two services are not independent, but form a distributed monolith instead. Avoiding such situations is just common sense.\nStill, you should always keep in mind the reasons why a good practice exists, what it protects you from and what costs it introduces. At one point we had a\ndiscussion within our team about how to best handle a peculiar performance issue. Our service connected to an Elasticsearch instance and performed two kinds\nof operations: reads and writes. Reads were much more numerous, but writes introduced heavy load (on the service itself — Elastic could handle it). Writes\ncame in bursts, so most of the time things worked well, but when a burst of writes arrived, performance of the whole service suffered and read times were\naffected. We tried various mechanisms for isolating the two kinds of operation, but couldn’t do it effectively.\nA colleague suggested we split the service in two, one responsible for handling reads and the other for writes. We had a long discussion, in which I\npresented arguments for having a single service as the owner of the data, responsible for both reads and writes, and highlighted what issues could arise due to\nthe split. While keeping the service intact seemed to be the elegant thing to do, I didn’t have a good solution for the performance issue. My colleague’s\nidea to split the service, on the other hand, while somewhat messy, did offer a chance to solve it.\nSo, we decided to just try it and see whether this approach would solve the performance issue and how bad the side effects would be. We did just that, and the\nantipattern-based solution worked great: performance hiccups went away, and despite sharing the common Elasticsearch cluster, the two services remained\nmaintainable. We were not able to fully assess this aspect right away, but time proved my colleague right as well: during the 3+ years we worked with that\ncodebase later on, we only ran into issues related to sharing Elasticsearch once, and we managed to fix that case quickly. It certainly did help, though, that\nboth services kept being developed by the same team, and that by the time we introduced the split, the schema was already quite stable and did not change often.\nNonetheless, had I insisted on keeping things clean, we would have probably spent much more time fighting performance issues than we lost during the single\nissue that resulted from sharing Elasticsearch between services. Know when to use patterns, know when to use antipatterns, and use both wisely.\nOne size does not fit all\n\nI think we’ve always been quite pragmatic about sizing our microservices. It’s hard to define a set of specific rules for finding the right size, but going\ntoo far in one direction or the other causes considerable pain. Make a service huge, and it becomes too hard for a single team to maintain and develop, or\nscaling issues arise similar to those you could experience with a monolith. Make it very small, and you might get overwhelmed by the overhead of having your\nlogic split between too many places, issues with debugging, and the performance penalty of the system being distributed to the extreme.\nMost services I got to work on at Allegro were not too tiny, and contained some non-trivial amount of logic. There were sometimes agitated discussions about\nwhere to implement a certain feature, in particular whether it should be in an existing service or in a new one. In hindsight, I think most decisions made\nsense, but there were certainly cases where a feature that we believed would grow ended up in a new service which then never took off and remained too small,\nand cases where something was bolted onto an existing service because it was easier to implement this way, but which caused some pain later on.\nI think I only once saw a team fall into the nanoservice trap where services were designed so small the split caused more trouble than it was worth. On the\nother hand, there were certainly services which you could no longer call micro by any stretch. This was not necessarily a bad thing. As long as a service\nfulfilled a well-defined role, a single team was enough to take care of it, and it was OK that you had to deploy and scale the whole thing together, things\nwere fine. In some cases of services which grew really much too big (indicators being that they contained pieces of logic only very loosely related to each\nother, and that at some point multiple teams were regularly interested in contributing), we did get back to them and split them up. It was not very easy,\nbut doable, and the second-hardest part was usually finding the right lines along which to divide. The only thing harder was finding the time to perform\nsuch operations, but with a bit of negotiation and persistence, after a while we usually succeeded.\nThere is an ongoing discussion of whether we have too many microservices. It’s not an urgent thing, but there are reasons to not go too high, such as\ncertain technical limitations in the infrastructure and the cost of overprovisioning (each service allocates resources such as memory or CPUs with a margin,\nand those margins add up). Still, the fact that we are well above a thousand services and yet their number is only a minor nuisance, speaks well of our\ntooling and organization. Indeed, thanks to some custom tools, creating a new service is very easy (maybe too easy?), and managing those already there is\nalso quite pleasant. This is possible due to huge investments we made early on (and continue): we knew right from the start that while each microservice may\nbe relatively simple, a lot of complexity goes into the glue that holds the whole system together. Without it, things would not quite work so well. Another\nfactor is, obviously, that our system has an actual use case for microservices: we have hundreds of teams, a system that keeps growing in capacity and\ncomplexity, and scale that makes a truly distributed system necessary. I think much of the anti-microservice sentiment you see around the internet today\nstems from treating microservices as a silver bullet that you can apply to any problem regardless of whether they actually make sense in given situation, or\nfrom not being aware that they can bring huge payoffs but also require great investments. There is a good summary of the advantages and disadvantages of\nmicroservices in this Gitlab blog post.\nService Mesh and common libraries\n\nProbably the most recent really significant change related to our microservice ecosystem was the migration to service mesh.\nFrom developers’ perspective it did not seem all that radical, but it required a lot of work from infrastructure teams. The most important gain is the\npossibility to control some aspects of services’ behavior in a single place. For example, originally if you wanted to have secure connections between\nservices, you had to support TLS in code, using common libraries. With service mesh, you can just\nenable it globally without the developers even having to know. This makes maintaining the huge ecosystem that consists of more than a thousand services much\nmore bearable.\nEach microservice needs certain behaviors in order to work well within our environment. For example, it needs a healthcheck endpoint which allows Kubernetes\nto tell if the service instance is working or not. We have a written Microservice Contract which defines those requirements. There are also features that are\nnot strictly necessary, but which many services will find useful, for example various metrics. Our initial approach was to have a set of common libraries\nthat provided both the required and many of the nice-to-have features. Of course, if you can’t or don’t want to use those libraries, you are free to do so, as\nlong as your service implements the Microservice Contract some other way.\nOver time, the role of those libraries has changed, with the general direction being that of reducing their scope. There are several reasons.\nReason number one is more and more features can be moved to infrastructure layer, of which Service Mesh is an important part. For example, originally\ncommunicating with another service required a service discovery client, implemented in a shared library.  Now, all this logic has been delegated to the\nService Mesh and requires no special support in shared libraries or service code.\nAnother reason is that open source libraries have caught on and some features we used to need to implement ourselves, such as certain metrics, are now\navailable out of the box in Spring Boot or other frameworks. There is no point in reinventing the wheel and having more code to maintain.\nFinally, the problem with libraries is that updating a library in 1000+ services is a slow and costly process. Meanwhile, a feature that the Service Mesh\nprovides can be switched on or reconfigured for all services almost instantly.\nDespite common libraries falling out of favor with us, there are some features that are hard to implement in infrastructure alone. Even with a simple\nfeature such as logging, sometimes we need data that only code running within the services has access to. When we want to fill in certain standard fields in\norder to make searching logs easier, some fields, such as host or dc, can easily be filled in by the infrastructure, but some, such as thread_name are\nonly known inside the service and can’t be handled externally. Thus, the role of libraries is diminished but not completely eliminated. In order to make\nworking with shared libraries less cumbersome, we are working on ways to automate upgrades as much as possible so that we can keep all versions up to date\nwithout it costing too much developers’ time.\nLearning\n\nDuring the transition, Allegro invested in learning and development heavily. Daily work was full of learning opportunities since everything we were doing\nwas quite new, and many approaches and technologies were not mature yet. We were really on the cutting edge of technology, so for many problems there were\nsimply no run-of-the-mill solutions yet. We were already several years into the microservice transition when microservices became a global hype.\nSince everybody was well aware of what an ambitious plan we were pursuing, it was also well understood that some things took experimenting, and while of\ncourse we were expected to ship value, there was a company-wide understanding that time for learning, team tourism,\ntrying out new things, and sometimes failing, were necessary for success. One of the things I really enjoyed was the focus on quality and doing things right.\nBusiness understood this as well, and actually at one point when Rubicon was quite advanced, developers were granted a 6-month grace period during which we\ncould focus on just technical changes without having to deliver any business value. As a matter of fact, many business logic changes were delivered anyway. For\nexample, the team I was on created a microservice-based approach to handling payments which was much more flexible than the old solution, so it was not just a\nrefactoring, but rather a rewrite that took new business requirements into account.\nApart from learning by doing, we also invested in organized training and conferences. We bought a number of dedicated training sessions with\nestablished experts from Silicon Valley on topics such as software architecture and JVM performance. Pretty much\neveryone could attend at least one good conference each year, and we also sponsored a number of developer-centric events in order to gain visibility and attract\ngood hires. About a year into my job, I got to attend JavaOne in San Francisco, whose scale and depth trumped even the biggest conferences I knew from Europe.\nAfter attending a few conferences, I decided to give speaking myself a try, and was able to take advantage of a number of useful trainings to help me with that.\nWe also started the allegro.tech initiative in order to organize all the activity used to promote our brand, and this blog is one\nof the projects that we run under the allegro.tech umbrella to this day.\nThe cycle of life\nIn 2022, a service I had worked on when I first started at Allegro was shut down due to being replaced with a newer solution. This way, I witnessed the\nfull lifecycle of a service: building it from scratch, adding more features to the mature solution, maintenance, and finally seeing it discontinued. It was\nreally a great experience to see that something I had built had run its course and I could be there to see the whole cycle.\nTakeaways\n\nWhen we started out working with microservices, we were well aware of their benefits but also of their cost. The famous\nYou must be this tall to use microservices image adorned many of our presentations at that\ntime. By taking a realistic stance, we avoided many pitfalls. Our transition to the microservice world took several years, but was successful, and I am\ncertain we would be in a much worse place had the company not made that bold decision. Apart from being a huge technical challenge, it was also a great\ntransformation in our way of thinking and in the way we work together. Conway’s Law applies and the change\nin system architecture was possible only together with a change in company architecture. It was also possible thanks to many smart people with whom I had\nthe pleasure to work over these years.\nWhen I look back, I see how far we have come. Creating a new service used to take a week or two at first, and now it takes minutes. Scaling a service required\na human operator, creating virtual machines, and manually adding them to the monitoring system. Today, an autoscaler handles most services and developers\ndo not even need to know that instances were added or removed. Our tooling is really convenient, even though there are things we could improve, and some\ncomponents are already showing signs of aging. Nonetheless, many things that used to be a challenge, are trivial today. New joiners at the company can\nbenefit from all these conveniences right from the start, and sometimes I think they might not fully appreciate them since they never had to perform all\nthat work manually.\nThe world does not stand still, though. Technologies change, and some assumptions we made when planning our architecture ten years ago, have already had to\nbe updated. Our system has grown, and so has the company, so many issues we are dealing with now are different from those that troubled us in the beginning\nof Project Rubicon. Initially, everything was a greenfield project, but by now, some places have accumulated bit rot and need cleanup. The system is much\nbigger (which microservices enabled) so introducing changes gets harder (still, much easier than it would be within a monolith). And since ten\nyears is a lot of time, many people have moved through the company, so knowledge transfer and continued learning\nare still essential. Only change is certain, and this has not changed a bit. I’m happy I could experience the heroic age of microservices myself, and I’m\nlooking forward to whatever comes next.","guid":"https://blog.allegro.tech/2024/04/ten-years-microservices.html","categories":["tech","microservices","architecture"],"isoDate":"2024-04-11T22:00:00.000Z"},{"title":"Unlocking Kafka's Potential: Tackling Tail Latency with eBPF","link":"https://blog.allegro.tech/2024/03/kafka-performance-analysis.html","pubDate":"Wed, 06 Mar 2024 00:00:00 +0100","authors":{"author":[{"name":["Maciej Mościcki"],"photo":["https://blog.allegro.tech/img/authors/maciej.moscicki.jpg"],"url":["https://blog.allegro.tech/authors/maciej.moscicki"]},{"name":["Piotr Rżysko"],"photo":["https://blog.allegro.tech/img/authors/piotr.rzysko.jpg"],"url":["https://blog.allegro.tech/authors/piotr.rzysko"]}]},"content":"<p>At <a href=\"https://allegro.tech\">Allegro</a>, we use <a href=\"https://kafka.apache.org/\">Kafka</a> as a backbone for asynchronous communication between microservices. With up to\n300k messages published and 1M messages consumed every second, it is a key part of our infrastructure. A few months ago, in our main Kafka cluster, we noticed\nthe following discrepancy: while median response times for <a href=\"https://developer.confluent.io/courses/architecture/broker/#inside-the-apache-kafka-broker:~:text=Client%20requests%20fall%20into%20two%20categories%3A%20produce%20requests%20and%20fetch%20requests.%20A%20produce%20request%20is%20requesting%20that%20a%20batch%20of%20data%20be%20written%20to%20a%20specified%20topic.%20A%20fetch%20request%20is%20requesting%20data%20from%20Kafka%20topics.\">produce requests</a>\nwere in single-digit milliseconds, the tail latency was much worse. Namely, the\np99 latency was up to 1 second, and the p999 latency was up to 3 seconds. This was unacceptable for a new project that we were about to start, so we\ndecided to look into this issue. In this blog post, we would like to describe our journey — how we used Kafka protocol sniffing and eBPF to identify and remove\nthe performance bottleneck.</p>\n\n<p><img src=\"/img/articles/2024-03-06-kafka-performance-analysis/kafka-performance-analysis.png\" alt=\"Kafka Produce Latency\" /></p>\n\n<h2 id=\"the-need-for-tracing\">The Need for Tracing</h2>\n<p>Kafka brokers <a href=\"https://docs.confluent.io/platform/current/kafka/monitoring.html#localtimems\">expose various metrics</a>. From them, we were able to tell that\nproduce requests were slow for high percentiles, but we couldn’t identify the cause. System metrics were also not showing anything alarming.</p>\n\n<p>To pinpoint the underlying problem, we decided to trace individual requests. By analyzing components of Kafka involved in handling produce requests,\nwe aimed to uncover the source of the latency spikes. One way of doing that would be to fork Kafka, implement instrumentation, and deploy our custom version\nto the cluster. However, this would be very time-consuming and invasive. We decided to try an alternative approach.</p>\n\n<p>The first thing we did was finding <em>arrival</em> and <em>end</em> times for every Kafka produce request.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th style=\"text-align: center\"> </th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"text-align: center\"><img src=\"/img/articles/2024-03-06-kafka-performance-analysis/request_timeline1.png\" alt=\"Timeline of Kafka produce request\" /></td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\"><em>Timeline of a produce request. Arrival and end times define the boundaries of the request. The components of Kafka involved in handling the request and their latencies are unknown.</em></td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Kafka uses a binary protocol over TCP to send requests from producers (and consumers) to brokers. We started by capturing the network traffic on a selected\nbroker using <a href=\"https://www.tcpdump.org/\">tcpdump</a>. Then we wrote a tool for analyzing the captured packets, which enabled us to list all the request and response\ntimes. In the output, we saw a confirmation of what we already knew — there were many slow produce requests taking over a second to complete. What’s more we\nwere able to see request metadata — <em>topic name</em>, <em>partition ID</em> and <em>message ID</em> (our internal identifier included in Kafka headers):</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ARRIVAL TIME  END TIME      LATENCY(ms)  MESSAGE_ID  TOPIC   PARTITION\n12:11:36.521  12:11:37.060  538          371409548   topicA  2\n12:11:36.519  12:11:37.060  540          375783615   topicB  18\n12:11:36.519  12:11:37.060  540          375783615   topicB  18\n12:11:36.555  12:11:37.061  505          371409578   topicC  7\n12:11:36.587  12:11:37.061  473          375783728   topicD  16\n12:11:36.690  12:11:37.061  370          375783907   topicB  18\n</code></pre></div></div>\n\n<p>With that extra knowledge in hand, we were ready to dig deeper.</p>\n\n<h2 id=\"dynamic-tracing\">Dynamic Tracing</h2>\n\n<p>Thanks to network traffic analysis we had arrival time, end time and metadata for each request. We then wanted to gain insights into\nwhich Kafka components were the source of latency. Since produce requests are mostly concerned with saving data,\nwe decided to instrument writes to the underlying storage.</p>\n\n<p>On Linux, Kafka uses regular files for storing data. Writes are done using ordinary <a href=\"https://man7.org/linux/man-pages/man2/write.2.html\">write system calls</a> — data is first stored in the page cache\nand then asynchronously flushed to disk. How can we trace individual file writes without modifying the source code? We can make use of <em>dynamic tracing</em>.</p>\n\n<p>What is <em>dynamic tracing</em>? In Brendan Gregg’s <em>System Performance</em>, he uses the following analogy that we really like:</p>\n\n<blockquote>\n  <p>Consider an operating system kernel: analyzing kernel internals can be like venturing into a dark room, with candles […] placed where the kernel engineers\nthought they were needed. Dynamic instrumentation is like having a flashlight that you can point anywhere.</p>\n</blockquote>\n\n<p>This basically means that it is possible to instrument arbitrary kernel code without the need to modify a user space application or the kernel itself. For\nexample, we can use dynamic tracing to instrument file system calls to check whether they are the source of latency. To do that we can make use of a technology\ncalled BPF.</p>\n\n<p>BPF (or eBPF) which stands for <em>(extended) Berkeley Packet Filter</em> is a technology with a rich history, but today it is a generic in-kernel execution\nenvironment [<em>Gregg Brendan (2020). Systems Performance: Enterprise and the Cloud, 2nd Edition</em>]. It has a wide range of applications, including networking,\nsecurity and tracing tools. eBPF programs are compiled to bytecode which is then interpreted by the Linux Kernel.</p>\n\n<p>There are a couple of well-established front-ends for eBPF, including <a href=\"https://github.com/iovisor/bcc/tree/master\">BCC</a>,\n<a href=\"https://github.com/bpftrace/bpftrace\">bpftrace</a> and <a href=\"https://github.com/libbpf/libbpf\">libbpf</a>. They can be used to write custom tracing programs, but they\nalso ship with many useful tools already implemented. One such tool is <a href=\"https://github.com/iovisor/bcc/blob/master/tools/ext4slower.py\">ext4slower</a>.\nIt allows tracing file system operations in the ext4 file system, which is the default file system for Linux.</p>\n\n<h2 id=\"tracing-kafka\">Tracing Kafka</h2>\n<p>In Kafka, every partition has its own directory, named according to the pattern: <em>topicName</em>-<em>partitionID</em>. Within each of these directories, there are segment\nfiles where messages are stored. In the figure below, we can see an example of this structure. In this scenario, the broker hosts two partitions (0 and 7)\nfor <em>topicA</em> and one partition (1) for <em>topicB</em>.</p>\n\n<p><img src=\"/img/articles/2024-03-06-kafka-performance-analysis/kafka_directories.png\" alt=\"Kafka Partition Directories\" /></p>\n\n<p>By slightly altering the ext4slower program to include parent directories, we were able to trace Kafka file system writes. For every write with a duration\nexceeding a specified threshold, we observed the following:</p>\n<ul>\n  <li>Start time and end time</li>\n  <li>Duration</li>\n  <li>Thread ID (TID)</li>\n  <li>Number of bytes written</li>\n  <li>File offset</li>\n  <li>Topic name</li>\n  <li>Partition ID</li>\n</ul>\n\n<p>Below is an example output from the program:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>START TIME    END TIME      LATENCY  TID   BYTES  OFF_KB     FILE\n15:37:00.627  15:37:00.785  158 ms   4478  2009   88847331   topicA-0/00000000002938697123.log\n15:37:00.629  15:37:00.785  156 ms   4492  531    289315894  topicB-7/00000000001119733846.log\n15:37:00.629  15:37:00.785  156 ms   4495  815    167398027  topicC-7/00000000015588371822.log\n15:37:00.631  15:37:00.785  154 ms   4488  778    502626221  topicD-7/00000000004472160265.log\n15:37:00.644  15:37:00.785  141 ms   4486  341    340818418  topicE-7/00000000002661443174.log\n15:37:00.650  15:37:00.785  135 ms   4470  374    230883174  topicF-7/00000000006102922534.log\n15:37:00.653  15:37:00.785  132 ms   4461  374    375758631  topicF-19/00000000001555977358.log\n</code></pre></div></div>\n\n<p>This was already very helpful since we could, based on timestamp, topic and partition, correlate produce requests from the tcpdump output with writes to\nthe file system:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ARRIVAL TIME  END TIME      LATENCY  MESSAGE_ID  TOPIC   PARTITION\n15:37:00.627  15:37:00.785  158 ms   839584818   topicA  0\n15:37:00.629  15:37:00.785  156 ms   982282008   topicB  7\n15:37:00.629  15:37:00.785  156 ms   398037998   topicC  7\n15:37:00.631  15:37:00.785  154 ms   793357083   topicD  7\n15:37:00.644  15:37:00.786  141 ms   605597592   topicE  7\n15:37:00.649  15:37:00.785  136 ms   471986034   topicF  7\n15:37:00.653  15:37:00.786  132 ms   190735697   topicF  19\n</code></pre></div></div>\n\n<p>To gain extra confidence, we wrote a tool that parses a Kafka log file, reads the records written to it (using file offset and number of bytes written),\nparses them, and returns their <em>message IDs</em>. With that, we were able to perfectly correlate incoming requests with their respective writes:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>START TIME    END TIME      LATENCY  MESSAGE_ID  FILE                                TOPIC   PARTITION  BYTES  OFF_KB\n15:37:00.627  15:37:00.785  158 ms   839584818   topicA-0/00000000002938697123.log   topicA  0          2009   88847331\n15:37:00.629  15:37:00.785  156 ms   982282008   topicB-7/00000000001119733846.log   topicB  7          531    289315894\n15:37:00.629  15:37:00.785  156 ms   398037998   topicC-7/00000000015588371822.log   topicC  7          815    167398027\n15:37:00.631  15:37:00.785  154 ms   793357083   topicD-7/00000000004472160265.log   topicD  7          778    502626221\n15:37:00.644  15:37:00.786  141 ms   605597592   topicE-7/00000000002661443174.log   topicE  7          341    340818418\n15:37:00.649  15:37:00.785  136 ms   471986034   topicF-7/00000000006102922534.log   topicF  7          374    230883174\n15:37:00.653  15:37:00.786  132 ms   190735697   topicF-19/00000000001555977358.log  topicF  19         374    375758631\n</code></pre></div></div>\n\n<p>From the analysis, we were able to tell that <strong>there were many slow produce requests that spent all of their time waiting for the file system write to\ncomplete.</strong></p>\n\n<p><img src=\"/img/articles/2024-03-06-kafka-performance-analysis/timeline_slow_write.png\" alt=\"Request Timeline with Slow Write\" /></p>\n\n<p>There were however requests that didn’t have corresponding slow writes.</p>\n\n<p><img src=\"/img/articles/2024-03-06-kafka-performance-analysis/timeline_fast_write.png\" alt=\"Request Timeline with Fast Write\" /></p>\n\n<h2 id=\"kafka-lock-contention\">Kafka Lock Contention</h2>\n<p>Slow produce requests without corresponding slow writes were always occurring around the time of some other slow write. We started wondering whether those\nrequests were perhaps queuing and waiting for something to finish. By analyzing Kafka source code, we identified a couple of places that use <em>synchronized</em>\nblocks, including those guarding log file writes.</p>\n\n<p>We set out to measure how much time Kafka’s threads, processing produce requests, spend on the aforementioned locks. Our goal was to correlate periods when\nthey were waiting on locks with writes to the file system. We considered two approaches to do that.</p>\n\n<p>The first one was to use tracing again, and perhaps combine its results with the tool we already had for tracing the ext4 file system.\nLooking at the JDK source code we were not able to identify a connection between <em>synchronized</em> blocks and traceable kernel routines. Instead, we learned that\nJVM ships with predefined DTrace tracepoints (DTrace can be thought of as a predecessor of eBPF). These tracepoints include <em>hotspot:monitor__contended__enter</em>\nand <em>hotspot:monitor__contended__entered</em>, which monitor when a thread begins waiting on a contended lock and when it finally enters it. By running Kafka\nwith the <em>-XX:+DTraceMonitorProbes</em> VM option and attaching to these tracepoints we were able to see monitor wait times for a given thread.</p>\n\n<p>Another approach we came up with was to capture states of Kafka’s threads by running <a href=\"https://github.com/async-profiler/async-profiler\">async-profiler</a>\nalongside the ext4 tracing script. We would then analyze results from both tools and correlate their outputs.</p>\n\n<p>After experimenting with both ideas, we ultimately chose to stick with async-profiler. It provided a clean visualization of thread states and offered more\ninsights into JVM-specific properties of threads.</p>\n\n<p>Now, let’s delve into how we analyzed a situation when a latency spike occurred, based on an example async-profiler recording, eBPF traces, and parsed\ntcpdump output. For brevity, we’ll focus on one Kafka topic.</p>\n\n<p>By capturing network traffic on a broker, we were able to see that there were four slow produce requests to the selected topic:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ARRIVAL TIME  END TIME      LATENCY  MESSAGE_ID  TOPIC   PARTITION\n17:58:00.644  17:58:00.770  126 ms   75567596    topicF  6\n17:58:00.651  17:58:00.770  119 ms   33561917    topicF  6\n17:58:00.655  17:58:00.775  119 ms   20422312    topicF  6\n17:58:00.661  17:58:00.776  114 ms   18658935    topicF  6\n</code></pre></div></div>\n\n<p>However, there was only one slow file system write for that topic:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>START TIME    END TIME      LATENCY  TID   BYTES  OFF_KB     FILE\n17:58:00.643  17:58:00.769  126 ms   4462  498    167428091  topicF-6/00000000000966764382.log\n</code></pre></div></div>\n\n<p>All other writes to that topic were fast at that time:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>START TIME    END TIME      LATENCY  TID   BYTES  OFF_KB     FILE\n17:58:00.770  17:58:00.770  0 ms     4484  798    167451825  topicF-6/00000000000966764382.log\n17:58:00.775  17:58:00.775  0 ms     4499  14410  167437415  topicF-6/00000000000966764382.log\n17:58:00.776  17:58:00.776  0 ms     4467  1138   167436277  topicF-6/00000000000966764382.log\n</code></pre></div></div>\n\n<p>We knew that one of the fast writes was performed from a thread with ID 4484. From a thread dump, we extracted thread names and Native IDs (NIDs).\nKnowing that NIDs translate directly to Linux TIDs (thread IDs), we found a thread with NID 0x1184 (decimal: 4484). We determined that the name of\nthis thread was <em>data-plane-kafka-request-handler-24</em>.</p>\n\n<p>We searched for this thread’s activity in the async-profiler output:</p>\n\n<table>\n  <thead>\n    <tr>\n      <th style=\"text-align: center\"> </th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"text-align: center\"><img src=\"/img/articles/2024-03-06-kafka-performance-analysis/locks.png\" alt=\"Async profiler output visualized in Java Mission Control\" /></td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\"><em>Async profiler output visualized in Java Mission Control. Thread with TID 4484 is blocked on a monitor.</em></td>\n    </tr>\n  </tbody>\n</table>\n\n<p>In the output, we saw what we suspected — a thread was waiting on a lock for approximately the same duration as the slow write occurring on another thread.\nThis confirmed our initial hypothesis.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th style=\"text-align: center\"> </th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"text-align: center\"><img src=\"/img/articles/2024-03-06-kafka-performance-analysis/timeline_lock.png\" alt=\"For a slow request with fast file system writes, waiting to obtain a lock turned out to be the source of latency\" /></td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\"><em>For a slow request with fast file system writes, waiting to acquire a lock turned out to be the source of latency.</em></td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Applying this technique, we analyzed numerous cases, and the results were consistent: <strong>for a slow produce request there was either a matching slow write or a\nthread was waiting to acquire a lock guarding access to a log file</strong>. We confirmed that file system writes were the root cause of slow produce requests.</p>\n\n<h2 id=\"tracing-the-file-system\">Tracing the File System</h2>\n<p>Our original eBPF script traced only calls to the <a href=\"https://elixir.bootlin.com/linux/v5.15.91/source/fs/ext4/file.c#L673\">ext4_file_write_iter</a> function.\nWhile this was sufficient to roughly determine that slow writes to the file system were causing the latency spikes, it was not enough to pinpoint which\nparameters of the file system needed tuning. To address this, we captured both <a href=\"https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html\">on-CPU</a>\nand <a href=\"https://www.brendangregg.com/offcpuanalysis.html\">off-CPU</a> profiles of <em>ext4_file_write_iter</em>, using\n<a href=\"https://github.com/iovisor/bcc/blob/master/tools/profile.py\">profile</a> and <a href=\"https://github.com/iovisor/bcc/blob/master/tools/offcputime.py\">offcputime</a>,\nrespectively. Our goal was to identify the activated paths in the kernel and then measure the latency of functions associated with them.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th style=\"text-align: center\"> </th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"text-align: center\"><img src=\"/img/articles/2024-03-06-kafka-performance-analysis/on_cpu.png\" alt=\"on-CPU profile of ext4_file_write_iter\" /></td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\"><em>on-CPU profile of ext4_file_write_iter</em></td>\n    </tr>\n  </tbody>\n</table>\n\n<table>\n  <thead>\n    <tr>\n      <th style=\"text-align: center\"> </th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"text-align: center\"><img src=\"/img/articles/2024-03-06-kafka-performance-analysis/off_cpu.png\" alt=\"off-CPU profile of ext4_file_write_iter\" /></td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\"><em>off-CPU profile of ext4_file_write_iter</em></td>\n    </tr>\n  </tbody>\n</table>\n\n<p>We noticed that the function <a href=\"https://elixir.bootlin.com/linux/v5.15.91/source/fs/ext4/inode.c#L5971\">ext4_dirty_inode</a> [1] was present in both flamegraphs.\nIn the Linux kernel, the <em>ext4_dirty_inode</em> function is responsible for marking an inode (file or directory data structure) as being in a dirty state. A <em>dirty</em>\ninode indicates that the corresponding file’s data or metadata has been modified and needs to be synchronized with the underlying storage device, typically a\ndisk, to ensure data consistency.</p>\n\n<p>What caught our attention in the off-CPU profile was the <a href=\"https://elixir.bootlin.com/linux/v5.15.91/source/fs/jbd2/transaction.c#L490\">jbd2__journal_start</a>\n[2] function which is part of a journaling mechanism employed in ext4 that ensures data integrity and reliability. Journaling in ext4 involves maintaining a\ndetailed log that records the changes before they are committed to the file system. This log, often referred to as the <em>journal</em>, serves as a safety net in the\nevent of an unexpected system crash or power failure. When a file system operation occurs, such as creating, modifying, or deleting a file, ext4 first records\nthis change in the journal. Subsequently, the actual file system structures are updated. The process of updating the file system is known as <em>committing</em> the\njournal. During a commit, the changes recorded in the journal are applied to the file system structures in a controlled and atomic manner. In the event of an\ninterruption, the file system can recover quickly by replaying the journal, ensuring that it reflects the consistent state of the file system.</p>\n\n<p>As seen in the figure with the off-CPU profile, <a href=\"https://elixir.bootlin.com/linux/v5.15/source/fs/jbd2/transaction.c#L169\">wait_transaction_locked</a> [3] is the\nfunction executed before voluntarily yielding the processor, allowing the scheduler to select and switch to a different process or thread ready to run\n(<a href=\"https://elixir.bootlin.com/linux/v5.15/source/kernel/sched/core.c#L6359\">schedule()</a>). Guided by the comment above the <em>wait_transaction_locked</em> function:</p>\n\n<blockquote>\n  <p>Wait until running transaction passes to T_FLUSH state and new transaction can thus be started. Also starts the commit if needed. The function expects running\ntransaction to exist and releases j_state_lock.</p>\n</blockquote>\n\n<p>We searched the kernel code to identify what sets the <em>T_FLUSH</em> flag. The only place that we discovered was within the\n<a href=\"https://elixir.bootlin.com/linux/v5.15/source/fs/jbd2/commit.c#L381\">jbd2_journal_commit_transaction</a> function executed periodically by a kernel journal\nthread. Consequently, we decided to trace this function to explore any correlation between its latency and the latency of <em>ext4_dirty_inode</em>. The obtained\nresults aligned precisely with our expectations – namely, <strong>a high latency in  <em>jbd2_journal_commit_transaction</em> translates to a high latency in\n<em>ext4_dirty_inode</em>.</strong> The details of our findings are presented below:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>START TIME    END TIME      LATENCY  FUNCTION\n19:35:24.503  19:35:24.680  176 ms   jbd2_journal_commit_transaction\n19:35:24.507  19:35:24.648  141 ms   ext4_dirty_inode\n19:35:24.508  19:35:24.648  139 ms   ext4_dirty_inode\n19:35:24.514  19:35:24.648  134 ms   ext4_dirty_inode\n...\n19:38:14.508  19:38:14.929  420 ms   jbd2_journal_commit_transaction\n19:38:14.511  19:38:14.868  357 ms   ext4_dirty_inode\n19:38:14.511  19:38:14.868  357 ms   ext4_dirty_inode\n19:38:14.512  19:38:14.868  356 ms   ext4_dirty_inode\n...\n19:48:39.475  19:48:40.808  1332 ms  jbd2_journal_commit_transaction\n19:48:39.477  19:48:40.757  1280 ms  ext4_dirty_inode\n19:48:39.487  19:48:40.757  1270 ms  ext4_dirty_inode\n19:48:39.543  19:48:40.757  1213 ms  ext4_dirty_inode\n...\n</code></pre></div></div>\n\n<h2 id=\"ext4-improvements-monitoring\">ext4 Improvements Monitoring</h2>\n<p>Having identified journal commits as the cause of slow writes, we started thinking how to alleviate the problem. We had a few ideas, but we were wondering how\nwe would be able to observe improvements.  Up until that point, we relied on command-line tools and analyzing their output for short time ranges. We wanted\nto be able to observe the impact of our optimizations over longer periods.</p>\n\n<p>To report traced functions latency over long periods, we used <a href=\"https://github.com/cloudflare/ebpf_exporter\">ebpf_exporter</a>, a tool that exposes eBPF-based\nmetrics in Prometheus format. We were then able to visualize traces in Grafana. For example, maximum ext4 write latency for a given broker:</p>\n\n<p><img src=\"/img/articles/2024-03-06-kafka-performance-analysis/base_max_write_iter.png\" alt=\"Base ext4 Latency\" /></p>\n\n<p>With that, we were able to run brokers with different configurations and observe their write latency over time.</p>\n\n<h2 id=\"ext4-improvements\">ext4 Improvements</h2>\n<p>Let’s go back to ext4. We knew that journal commits were the source of latency. By studying ext4 documentation, we identified a few possible solutions for\nimproving the performance:</p>\n<ol>\n  <li>Disabling journaling</li>\n  <li>Decreasing the commit interval</li>\n  <li>Changing the journaling mode from <code class=\"language-plaintext highlighter-rouge\">data=ordered</code> to <code class=\"language-plaintext highlighter-rouge\">data=writeback</code></li>\n  <li>Enabling fast commits</li>\n</ol>\n\n<p>Let’s discuss each of them.</p>\n\n<h3 id=\"disabling-journaling\">Disabling Journaling</h3>\n<p>If journaling is the source of high latency, why not disable it completely? Well, it turns out that journaling is there for a reason. Without journaling, we\nwould risk long recovery in case of a crash. Thus, we quickly ruled out this solution.</p>\n\n<h3 id=\"decreasing-the-commit-interval\">Decreasing the Commit Interval</h3>\n<p>ext4 has the <em>commit</em> mount parameter which tells how often to perform commits. It has the default value of 5 seconds. According to the ext4 documentation:</p>\n\n<blockquote>\n  <p>This default value (or any low value) will hurt performance, but it’s good for data-safety. […] Setting it to very large values will improve performance.</p>\n</blockquote>\n\n<p>However, instead of increasing the value we decided to decrease it. Why? Our intuition was that by performing commits more frequently we would make them\n“lighter” which would make them faster. We would trade throughput for lower latency. We experimented with <code class=\"language-plaintext highlighter-rouge\">commit=1</code>, and <code class=\"language-plaintext highlighter-rouge\">commit=3</code> but observed no\nsignificant differences.</p>\n\n<h3 id=\"changing-the-journaling-mode-from-dataordered-to-datawriteback\">Changing the Journaling Mode from data=ordered to data=writeback</h3>\n<p>ext4 offers three journaling modes: <em>journal</em>, <em>ordered</em> and <em>writeback</em>. The default mode is <em>ordered</em> and compared to the most performant mode, <em>writeback</em>,\nit guarantees that the data is written to the main file system prior to the metadata being committed to the journal. As mentioned in\n<a href=\"https://kafka.apache.org/documentation/#ext4\">docs</a>, Kafka does not rely on this property, so switching the mode to <em>writeback</em> should reduce latency.</p>\n\n<p><strong>We switched the journaling mode on one of the brokers, and indeed, we observed latency improvements:</strong></p>\n\n<table>\n  <thead>\n    <tr>\n      <th style=\"text-align: center\"> </th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"text-align: center\"><img src=\"/img/articles/2024-03-06-kafka-performance-analysis/base_p999_2.png\" alt=\"Base Produce Latency\" /></td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\"><img src=\"/img/articles/2024-03-06-kafka-performance-analysis/writeback_p999_2.png\" alt=\"Writeback Produce Latency\" /></td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\"><em>With data=writeback, p999 decreased from 3 seconds to 800 milliseconds.</em></td>\n    </tr>\n  </tbody>\n</table>\n\n<h3 id=\"enabling-fast-commit\">Enabling Fast Commit</h3>\n<p>When reading about ext4 journaling, we stumbled upon an <a href=\"https://lwn.net/Articles/842385/\">article</a> describing a new feature introduced in Linux 5.10 called\n<em>fast commits</em>. As explained in the article, <em>fast commit</em> is a lighter-weight journaling method that could result in performance boost for certain workloads.</p>\n\n<p>We enabled <em>fast commit</em> on one of the brokers. <strong>We noticed that max write latency decreased significantly.</strong> Diving deeper we found out that on a broker with\n<em>fast commit</em> enabled:</p>\n<ul>\n  <li>The latency of <em>jdb2_journal_commit_transaction</em> decreased by an order of magnitude. This meant that periodic journal commits were indeed much faster\nthanks to enabling <em>fast commits</em>.</li>\n  <li>Slow ext4 writes occurred at the same time when there was a spike in latency of <em>jbd2_fc_begin_commit</em>. This method is part of the <em>fast commit</em> flow. It\nbecame the new source of latency but its maximum latency was lower than that of <em>jdb2_journal_commit_transaction</em> without fast commits.</li>\n</ul>\n\n<table>\n  <thead>\n    <tr>\n      <th style=\"text-align: center\"> </th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"text-align: center\"><img src=\"/img/articles/2024-03-06-kafka-performance-analysis/write_iter_heatmap.png\" alt=\"Comparison of maximum latency [s] of ext4 writes for brokers without and with fast commit.\" /></td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\"><em>Comparison of maximum latency [s] of ext4 writes for brokers without and with fast commit.</em></td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Lower file system write latency, in turn, resulted in reduced produce latency:</p>\n\n<table>\n  <thead>\n    <tr>\n      <th style=\"text-align: center\"> </th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"text-align: center\"><img src=\"/img/articles/2024-03-06-kafka-performance-analysis/base_p999_2.png\" alt=\"Base Produce Latency\" /></td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\"><img src=\"/img/articles/2024-03-06-kafka-performance-analysis/fc_p999_2.png\" alt=\"Fast Commit Produce Latency\" /></td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\"><em>With fast commit enabled, produce P999 latency went down from 3 seconds to 500 milliseconds</em></td>\n    </tr>\n  </tbody>\n</table>\n\n<h3 id=\"summary\">Summary</h3>\n<p>To summarize, we’ve tested the following ext4 optimizations:</p>\n<ul>\n  <li>Decreasing the commit interval</li>\n  <li>Changing the journaling mode to <code class=\"language-plaintext highlighter-rouge\">data=writeback</code></li>\n  <li>Enabling <code class=\"language-plaintext highlighter-rouge\">fast commit</code></li>\n</ul>\n\n<p>We observed that both <code class=\"language-plaintext highlighter-rouge\">data=writeback</code> and <code class=\"language-plaintext highlighter-rouge\">fast commit</code> significantly reduced latency, with <code class=\"language-plaintext highlighter-rouge\">fast commit</code> having slightly lower latency. The results were\npromising, but we had higher hopes. Thankfully, we had one more idea left.</p>\n\n<h2 id=\"xfs\">XFS</h2>\n<p>While researching the topic of journaling in ext4, we stumbled upon a few sources suggesting that the XFS file system, with its more advanced journaling,\nis well-suited for handling large files and high-throughput workloads, often outperforming ext4 in such scenarios. Kafka documentation also mentions that XFS\nhas a lot of tuning already in place and should be a better fit than the default ext4.</p>\n\n<p>We migrated one of the brokers to the XFS file system. The results were impressive. The thing that was very distinctive compared to the aforementioned ext4\noptimizations was the consistency of XFS performance. While other broker configurations experienced p999 latency spikes throughout the day, XFS – with its default configuration – had only a\nfew hiccups.</p>\n\n<p><img src=\"/img/articles/2024-03-06-kafka-performance-analysis/base_p999_2.png\" alt=\"Base Produce Latency\" />\n<img src=\"/img/articles/2024-03-06-kafka-performance-analysis/xfs_p999_2.png\" alt=\"Produce Latency XFS\" /></p>\n\n<p>After a couple of weeks of testing, we were confident that XFS was the best choice. Consequently, we migrated all our brokers from ext4 to XFS.</p>\n\n<h2 id=\"summary-1\">Summary</h2>\n<p>Using a combination of packet sniffing, eBPF, and async-profiler we managed to identify the root cause of slow produce requests in our Kafka cluster. We\nthen tested a couple of solutions to the problem: <code class=\"language-plaintext highlighter-rouge\">data=writeback</code> journaling mode, <code class=\"language-plaintext highlighter-rouge\">fast commits</code>, and changing the file system to XFS. The results of these\noptimizations are visualized in the heatmap below:</p>\n\n<p><img src=\"/img/articles/2024-03-06-kafka-performance-analysis/heatmap_p999.png\" alt=\"Produce Latency Heatmap\" /></p>\n\n<p>Ultimately, we found XFS to be the most performant and rolled it out to all of our brokers. <strong>With XFS, the number of produce requests exceeding 65ms (our SLO)\nwas lowered by 82%.</strong></p>\n\n<p>Here are some of the lessons we learned along the way:</p>\n<ul>\n  <li>eBPF was extremely useful during the analysis. It was straightforward to utilize one of the pre-existing tools from bcc or bpftrace. We were also able to\neasily modify them for our custom use cases.</li>\n  <li>ebpf_exporter is a great tool for observing trace results over longer periods of time. It allows to expose Prometheus metrics based on libbpf programs.</li>\n  <li>p99 and p999 analysis is sometimes not enough. In our case, the p999 latency of file system writes was less than 1ms. It turned out that a single slow write\ncould cause lock contention and a cascade of slow requests. Without tracing individual requests, the root cause would have been very hard to catch.</li>\n</ul>\n\n<p>We hope that you found this blog post useful, and we wish you good luck in your future performance analysis endeavors!</p>\n\n<hr />\n<h3 id=\"acknowledgments\">Acknowledgments</h3>\n\n<p><em>We would like to thank our colleague Dominik Kowalski for performing the XFS migration and applying the ext4 configuration changes to the Kafka cluster.</em></p>\n\n<style>\n  .post-content table, .post-content td, .post-content th {\n    border: none;\n    background-color: transparent;\n}\n\n.post-content th {\n    display: none;\n}\n\n.post-content td {\n    padding: 0;\n}\n\n</style>\n\n","contentSnippet":"At Allegro, we use Kafka as a backbone for asynchronous communication between microservices. With up to\n300k messages published and 1M messages consumed every second, it is a key part of our infrastructure. A few months ago, in our main Kafka cluster, we noticed\nthe following discrepancy: while median response times for produce requests\nwere in single-digit milliseconds, the tail latency was much worse. Namely, the\np99 latency was up to 1 second, and the p999 latency was up to 3 seconds. This was unacceptable for a new project that we were about to start, so we\ndecided to look into this issue. In this blog post, we would like to describe our journey — how we used Kafka protocol sniffing and eBPF to identify and remove\nthe performance bottleneck.\n\nThe Need for Tracing\nKafka brokers expose various metrics. From them, we were able to tell that\nproduce requests were slow for high percentiles, but we couldn’t identify the cause. System metrics were also not showing anything alarming.\nTo pinpoint the underlying problem, we decided to trace individual requests. By analyzing components of Kafka involved in handling produce requests,\nwe aimed to uncover the source of the latency spikes. One way of doing that would be to fork Kafka, implement instrumentation, and deploy our custom version\nto the cluster. However, this would be very time-consuming and invasive. We decided to try an alternative approach.\nThe first thing we did was finding arrival and end times for every Kafka produce request.\n \n    \n\n    \nTimeline of a produce request. Arrival and end times define the boundaries of the request. The components of Kafka involved in handling the request and their latencies are unknown.\n    \nKafka uses a binary protocol over TCP to send requests from producers (and consumers) to brokers. We started by capturing the network traffic on a selected\nbroker using tcpdump. Then we wrote a tool for analyzing the captured packets, which enabled us to list all the request and response\ntimes. In the output, we saw a confirmation of what we already knew — there were many slow produce requests taking over a second to complete. What’s more we\nwere able to see request metadata — topic name, partition ID and message ID (our internal identifier included in Kafka headers):\n\nARRIVAL TIME  END TIME      LATENCY(ms)  MESSAGE_ID  TOPIC   PARTITION\n12:11:36.521  12:11:37.060  538          371409548   topicA  2\n12:11:36.519  12:11:37.060  540          375783615   topicB  18\n12:11:36.519  12:11:37.060  540          375783615   topicB  18\n12:11:36.555  12:11:37.061  505          371409578   topicC  7\n12:11:36.587  12:11:37.061  473          375783728   topicD  16\n12:11:36.690  12:11:37.061  370          375783907   topicB  18\n\n\nWith that extra knowledge in hand, we were ready to dig deeper.\nDynamic Tracing\nThanks to network traffic analysis we had arrival time, end time and metadata for each request. We then wanted to gain insights into\nwhich Kafka components were the source of latency. Since produce requests are mostly concerned with saving data,\nwe decided to instrument writes to the underlying storage.\nOn Linux, Kafka uses regular files for storing data. Writes are done using ordinary write system calls — data is first stored in the page cache\nand then asynchronously flushed to disk. How can we trace individual file writes without modifying the source code? We can make use of dynamic tracing.\nWhat is dynamic tracing? In Brendan Gregg’s System Performance, he uses the following analogy that we really like:\nConsider an operating system kernel: analyzing kernel internals can be like venturing into a dark room, with candles […] placed where the kernel engineers\nthought they were needed. Dynamic instrumentation is like having a flashlight that you can point anywhere.\nThis basically means that it is possible to instrument arbitrary kernel code without the need to modify a user space application or the kernel itself. For\nexample, we can use dynamic tracing to instrument file system calls to check whether they are the source of latency. To do that we can make use of a technology\ncalled BPF.\nBPF (or eBPF) which stands for (extended) Berkeley Packet Filter is a technology with a rich history, but today it is a generic in-kernel execution\nenvironment [Gregg Brendan (2020). Systems Performance: Enterprise and the Cloud, 2nd Edition]. It has a wide range of applications, including networking,\nsecurity and tracing tools. eBPF programs are compiled to bytecode which is then interpreted by the Linux Kernel.\nThere are a couple of well-established front-ends for eBPF, including BCC,\nbpftrace and libbpf. They can be used to write custom tracing programs, but they\nalso ship with many useful tools already implemented. One such tool is ext4slower.\nIt allows tracing file system operations in the ext4 file system, which is the default file system for Linux.\nTracing Kafka\nIn Kafka, every partition has its own directory, named according to the pattern: topicName-partitionID. Within each of these directories, there are segment\nfiles where messages are stored. In the figure below, we can see an example of this structure. In this scenario, the broker hosts two partitions (0 and 7)\nfor topicA and one partition (1) for topicB.\n\nBy slightly altering the ext4slower program to include parent directories, we were able to trace Kafka file system writes. For every write with a duration\nexceeding a specified threshold, we observed the following:\nStart time and end time\nDuration\nThread ID (TID)\nNumber of bytes written\nFile offset\nTopic name\nPartition ID\nBelow is an example output from the program:\n\nSTART TIME    END TIME      LATENCY  TID   BYTES  OFF_KB     FILE\n15:37:00.627  15:37:00.785  158 ms   4478  2009   88847331   topicA-0/00000000002938697123.log\n15:37:00.629  15:37:00.785  156 ms   4492  531    289315894  topicB-7/00000000001119733846.log\n15:37:00.629  15:37:00.785  156 ms   4495  815    167398027  topicC-7/00000000015588371822.log\n15:37:00.631  15:37:00.785  154 ms   4488  778    502626221  topicD-7/00000000004472160265.log\n15:37:00.644  15:37:00.785  141 ms   4486  341    340818418  topicE-7/00000000002661443174.log\n15:37:00.650  15:37:00.785  135 ms   4470  374    230883174  topicF-7/00000000006102922534.log\n15:37:00.653  15:37:00.785  132 ms   4461  374    375758631  topicF-19/00000000001555977358.log\n\n\nThis was already very helpful since we could, based on timestamp, topic and partition, correlate produce requests from the tcpdump output with writes to\nthe file system:\n\nARRIVAL TIME  END TIME      LATENCY  MESSAGE_ID  TOPIC   PARTITION\n15:37:00.627  15:37:00.785  158 ms   839584818   topicA  0\n15:37:00.629  15:37:00.785  156 ms   982282008   topicB  7\n15:37:00.629  15:37:00.785  156 ms   398037998   topicC  7\n15:37:00.631  15:37:00.785  154 ms   793357083   topicD  7\n15:37:00.644  15:37:00.786  141 ms   605597592   topicE  7\n15:37:00.649  15:37:00.785  136 ms   471986034   topicF  7\n15:37:00.653  15:37:00.786  132 ms   190735697   topicF  19\n\n\nTo gain extra confidence, we wrote a tool that parses a Kafka log file, reads the records written to it (using file offset and number of bytes written),\nparses them, and returns their message IDs. With that, we were able to perfectly correlate incoming requests with their respective writes:\n\nSTART TIME    END TIME      LATENCY  MESSAGE_ID  FILE                                TOPIC   PARTITION  BYTES  OFF_KB\n15:37:00.627  15:37:00.785  158 ms   839584818   topicA-0/00000000002938697123.log   topicA  0          2009   88847331\n15:37:00.629  15:37:00.785  156 ms   982282008   topicB-7/00000000001119733846.log   topicB  7          531    289315894\n15:37:00.629  15:37:00.785  156 ms   398037998   topicC-7/00000000015588371822.log   topicC  7          815    167398027\n15:37:00.631  15:37:00.785  154 ms   793357083   topicD-7/00000000004472160265.log   topicD  7          778    502626221\n15:37:00.644  15:37:00.786  141 ms   605597592   topicE-7/00000000002661443174.log   topicE  7          341    340818418\n15:37:00.649  15:37:00.785  136 ms   471986034   topicF-7/00000000006102922534.log   topicF  7          374    230883174\n15:37:00.653  15:37:00.786  132 ms   190735697   topicF-19/00000000001555977358.log  topicF  19         374    375758631\n\n\nFrom the analysis, we were able to tell that there were many slow produce requests that spent all of their time waiting for the file system write to\ncomplete.\n\nThere were however requests that didn’t have corresponding slow writes.\n\nKafka Lock Contention\nSlow produce requests without corresponding slow writes were always occurring around the time of some other slow write. We started wondering whether those\nrequests were perhaps queuing and waiting for something to finish. By analyzing Kafka source code, we identified a couple of places that use synchronized\nblocks, including those guarding log file writes.\nWe set out to measure how much time Kafka’s threads, processing produce requests, spend on the aforementioned locks. Our goal was to correlate periods when\nthey were waiting on locks with writes to the file system. We considered two approaches to do that.\nThe first one was to use tracing again, and perhaps combine its results with the tool we already had for tracing the ext4 file system.\nLooking at the JDK source code we were not able to identify a connection between synchronized blocks and traceable kernel routines. Instead, we learned that\nJVM ships with predefined DTrace tracepoints (DTrace can be thought of as a predecessor of eBPF). These tracepoints include hotspot:monitor__contended__enter\nand hotspot:monitor__contended__entered, which monitor when a thread begins waiting on a contended lock and when it finally enters it. By running Kafka\nwith the -XX:+DTraceMonitorProbes VM option and attaching to these tracepoints we were able to see monitor wait times for a given thread.\nAnother approach we came up with was to capture states of Kafka’s threads by running async-profiler\nalongside the ext4 tracing script. We would then analyze results from both tools and correlate their outputs.\nAfter experimenting with both ideas, we ultimately chose to stick with async-profiler. It provided a clean visualization of thread states and offered more\ninsights into JVM-specific properties of threads.\nNow, let’s delve into how we analyzed a situation when a latency spike occurred, based on an example async-profiler recording, eBPF traces, and parsed\ntcpdump output. For brevity, we’ll focus on one Kafka topic.\nBy capturing network traffic on a broker, we were able to see that there were four slow produce requests to the selected topic:\n\nARRIVAL TIME  END TIME      LATENCY  MESSAGE_ID  TOPIC   PARTITION\n17:58:00.644  17:58:00.770  126 ms   75567596    topicF  6\n17:58:00.651  17:58:00.770  119 ms   33561917    topicF  6\n17:58:00.655  17:58:00.775  119 ms   20422312    topicF  6\n17:58:00.661  17:58:00.776  114 ms   18658935    topicF  6\n\n\nHowever, there was only one slow file system write for that topic:\n\nSTART TIME    END TIME      LATENCY  TID   BYTES  OFF_KB     FILE\n17:58:00.643  17:58:00.769  126 ms   4462  498    167428091  topicF-6/00000000000966764382.log\n\n\nAll other writes to that topic were fast at that time:\n\nSTART TIME    END TIME      LATENCY  TID   BYTES  OFF_KB     FILE\n17:58:00.770  17:58:00.770  0 ms     4484  798    167451825  topicF-6/00000000000966764382.log\n17:58:00.775  17:58:00.775  0 ms     4499  14410  167437415  topicF-6/00000000000966764382.log\n17:58:00.776  17:58:00.776  0 ms     4467  1138   167436277  topicF-6/00000000000966764382.log\n\n\nWe knew that one of the fast writes was performed from a thread with ID 4484. From a thread dump, we extracted thread names and Native IDs (NIDs).\nKnowing that NIDs translate directly to Linux TIDs (thread IDs), we found a thread with NID 0x1184 (decimal: 4484). We determined that the name of\nthis thread was data-plane-kafka-request-handler-24.\nWe searched for this thread’s activity in the async-profiler output:\n \n    \n\n    \nAsync profiler output visualized in Java Mission Control. Thread with TID 4484 is blocked on a monitor.\n    \nIn the output, we saw what we suspected — a thread was waiting on a lock for approximately the same duration as the slow write occurring on another thread.\nThis confirmed our initial hypothesis.\n \n    \n\n    \nFor a slow request with fast file system writes, waiting to acquire a lock turned out to be the source of latency.\n    \nApplying this technique, we analyzed numerous cases, and the results were consistent: for a slow produce request there was either a matching slow write or a\nthread was waiting to acquire a lock guarding access to a log file. We confirmed that file system writes were the root cause of slow produce requests.\nTracing the File System\nOur original eBPF script traced only calls to the ext4_file_write_iter function.\nWhile this was sufficient to roughly determine that slow writes to the file system were causing the latency spikes, it was not enough to pinpoint which\nparameters of the file system needed tuning. To address this, we captured both on-CPU\nand off-CPU profiles of ext4_file_write_iter, using\nprofile and offcputime,\nrespectively. Our goal was to identify the activated paths in the kernel and then measure the latency of functions associated with them.\n \n    \n\n    \non-CPU profile of ext4_file_write_iter\n    \n \n    \n\n    \noff-CPU profile of ext4_file_write_iter\n    \nWe noticed that the function ext4_dirty_inode [1] was present in both flamegraphs.\nIn the Linux kernel, the ext4_dirty_inode function is responsible for marking an inode (file or directory data structure) as being in a dirty state. A dirty\ninode indicates that the corresponding file’s data or metadata has been modified and needs to be synchronized with the underlying storage device, typically a\ndisk, to ensure data consistency.\nWhat caught our attention in the off-CPU profile was the jbd2__journal_start\n[2] function which is part of a journaling mechanism employed in ext4 that ensures data integrity and reliability. Journaling in ext4 involves maintaining a\ndetailed log that records the changes before they are committed to the file system. This log, often referred to as the journal, serves as a safety net in the\nevent of an unexpected system crash or power failure. When a file system operation occurs, such as creating, modifying, or deleting a file, ext4 first records\nthis change in the journal. Subsequently, the actual file system structures are updated. The process of updating the file system is known as committing the\njournal. During a commit, the changes recorded in the journal are applied to the file system structures in a controlled and atomic manner. In the event of an\ninterruption, the file system can recover quickly by replaying the journal, ensuring that it reflects the consistent state of the file system.\nAs seen in the figure with the off-CPU profile, wait_transaction_locked [3] is the\nfunction executed before voluntarily yielding the processor, allowing the scheduler to select and switch to a different process or thread ready to run\n(schedule()). Guided by the comment above the wait_transaction_locked function:\nWait until running transaction passes to T_FLUSH state and new transaction can thus be started. Also starts the commit if needed. The function expects running\ntransaction to exist and releases j_state_lock.\nWe searched the kernel code to identify what sets the T_FLUSH flag. The only place that we discovered was within the\njbd2_journal_commit_transaction function executed periodically by a kernel journal\nthread. Consequently, we decided to trace this function to explore any correlation between its latency and the latency of ext4_dirty_inode. The obtained\nresults aligned precisely with our expectations – namely, a high latency in  jbd2_journal_commit_transaction translates to a high latency in\next4_dirty_inode. The details of our findings are presented below:\n\nSTART TIME    END TIME      LATENCY  FUNCTION\n19:35:24.503  19:35:24.680  176 ms   jbd2_journal_commit_transaction\n19:35:24.507  19:35:24.648  141 ms   ext4_dirty_inode\n19:35:24.508  19:35:24.648  139 ms   ext4_dirty_inode\n19:35:24.514  19:35:24.648  134 ms   ext4_dirty_inode\n...\n19:38:14.508  19:38:14.929  420 ms   jbd2_journal_commit_transaction\n19:38:14.511  19:38:14.868  357 ms   ext4_dirty_inode\n19:38:14.511  19:38:14.868  357 ms   ext4_dirty_inode\n19:38:14.512  19:38:14.868  356 ms   ext4_dirty_inode\n...\n19:48:39.475  19:48:40.808  1332 ms  jbd2_journal_commit_transaction\n19:48:39.477  19:48:40.757  1280 ms  ext4_dirty_inode\n19:48:39.487  19:48:40.757  1270 ms  ext4_dirty_inode\n19:48:39.543  19:48:40.757  1213 ms  ext4_dirty_inode\n...\n\n\next4 Improvements Monitoring\nHaving identified journal commits as the cause of slow writes, we started thinking how to alleviate the problem. We had a few ideas, but we were wondering how\nwe would be able to observe improvements.  Up until that point, we relied on command-line tools and analyzing their output for short time ranges. We wanted\nto be able to observe the impact of our optimizations over longer periods.\nTo report traced functions latency over long periods, we used ebpf_exporter, a tool that exposes eBPF-based\nmetrics in Prometheus format. We were then able to visualize traces in Grafana. For example, maximum ext4 write latency for a given broker:\n\nWith that, we were able to run brokers with different configurations and observe their write latency over time.\next4 Improvements\nLet’s go back to ext4. We knew that journal commits were the source of latency. By studying ext4 documentation, we identified a few possible solutions for\nimproving the performance:\nDisabling journaling\nDecreasing the commit interval\nChanging the journaling mode from data=ordered to data=writeback\nEnabling fast commits\nLet’s discuss each of them.\nDisabling Journaling\nIf journaling is the source of high latency, why not disable it completely? Well, it turns out that journaling is there for a reason. Without journaling, we\nwould risk long recovery in case of a crash. Thus, we quickly ruled out this solution.\nDecreasing the Commit Interval\next4 has the commit mount parameter which tells how often to perform commits. It has the default value of 5 seconds. According to the ext4 documentation:\nThis default value (or any low value) will hurt performance, but it’s good for data-safety. […] Setting it to very large values will improve performance.\nHowever, instead of increasing the value we decided to decrease it. Why? Our intuition was that by performing commits more frequently we would make them\n“lighter” which would make them faster. We would trade throughput for lower latency. We experimented with commit=1, and commit=3 but observed no\nsignificant differences.\nChanging the Journaling Mode from data=ordered to data=writeback\next4 offers three journaling modes: journal, ordered and writeback. The default mode is ordered and compared to the most performant mode, writeback,\nit guarantees that the data is written to the main file system prior to the metadata being committed to the journal. As mentioned in\ndocs, Kafka does not rely on this property, so switching the mode to writeback should reduce latency.\nWe switched the journaling mode on one of the brokers, and indeed, we observed latency improvements:\n \n    \n\n    \n\n    \nWith data=writeback, p999 decreased from 3 seconds to 800 milliseconds.\n    \nEnabling Fast Commit\nWhen reading about ext4 journaling, we stumbled upon an article describing a new feature introduced in Linux 5.10 called\nfast commits. As explained in the article, fast commit is a lighter-weight journaling method that could result in performance boost for certain workloads.\nWe enabled fast commit on one of the brokers. We noticed that max write latency decreased significantly. Diving deeper we found out that on a broker with\nfast commit enabled:\nThe latency of jdb2_journal_commit_transaction decreased by an order of magnitude. This meant that periodic journal commits were indeed much faster\nthanks to enabling fast commits.\nSlow ext4 writes occurred at the same time when there was a spike in latency of jbd2_fc_begin_commit. This method is part of the fast commit flow. It\nbecame the new source of latency but its maximum latency was lower than that of jdb2_journal_commit_transaction without fast commits.\n \n    \n\n    \nComparison of maximum latency [s] of ext4 writes for brokers without and with fast commit.\n    \nLower file system write latency, in turn, resulted in reduced produce latency:\n \n    \n\n    \n\n    \nWith fast commit enabled, produce P999 latency went down from 3 seconds to 500 milliseconds\n    \nSummary\nTo summarize, we’ve tested the following ext4 optimizations:\nDecreasing the commit interval\nChanging the journaling mode to data=writeback\nEnabling fast commit\nWe observed that both data=writeback and fast commit significantly reduced latency, with fast commit having slightly lower latency. The results were\npromising, but we had higher hopes. Thankfully, we had one more idea left.\nXFS\nWhile researching the topic of journaling in ext4, we stumbled upon a few sources suggesting that the XFS file system, with its more advanced journaling,\nis well-suited for handling large files and high-throughput workloads, often outperforming ext4 in such scenarios. Kafka documentation also mentions that XFS\nhas a lot of tuning already in place and should be a better fit than the default ext4.\nWe migrated one of the brokers to the XFS file system. The results were impressive. The thing that was very distinctive compared to the aforementioned ext4\noptimizations was the consistency of XFS performance. While other broker configurations experienced p999 latency spikes throughout the day, XFS – with its default configuration – had only a\nfew hiccups.\n\n\nAfter a couple of weeks of testing, we were confident that XFS was the best choice. Consequently, we migrated all our brokers from ext4 to XFS.\nSummary\nUsing a combination of packet sniffing, eBPF, and async-profiler we managed to identify the root cause of slow produce requests in our Kafka cluster. We\nthen tested a couple of solutions to the problem: data=writeback journaling mode, fast commits, and changing the file system to XFS. The results of these\noptimizations are visualized in the heatmap below:\n\nUltimately, we found XFS to be the most performant and rolled it out to all of our brokers. With XFS, the number of produce requests exceeding 65ms (our SLO)\nwas lowered by 82%.\nHere are some of the lessons we learned along the way:\neBPF was extremely useful during the analysis. It was straightforward to utilize one of the pre-existing tools from bcc or bpftrace. We were also able to\neasily modify them for our custom use cases.\nebpf_exporter is a great tool for observing trace results over longer periods of time. It allows to expose Prometheus metrics based on libbpf programs.\np99 and p999 analysis is sometimes not enough. In our case, the p999 latency of file system writes was less than 1ms. It turned out that a single slow write\ncould cause lock contention and a cascade of slow requests. Without tracing individual requests, the root cause would have been very hard to catch.\nWe hope that you found this blog post useful, and we wish you good luck in your future performance analysis endeavors!\nAcknowledgments\nWe would like to thank our colleague Dominik Kowalski for performing the XFS migration and applying the ext4 configuration changes to the Kafka cluster.\n\n\n  .post-content table, .post-content td, .post-content th {\n    border: none;\n    background-color: transparent;\n}\n\n.post-content th {\n    display: none;\n}\n\n.post-content td {\n    padding: 0;\n}","guid":"https://blog.allegro.tech/2024/03/kafka-performance-analysis.html","categories":["tech","kafka","ebpf","bcc","linux","kernel","ext4","xfs","performance","tuning","file system"],"isoDate":"2024-03-05T23:00:00.000Z"},{"title":"Tired of repetitive tasks?! Go for RPA!","link":"https://blog.allegro.tech/2024/02/rpa.html","pubDate":"Tue, 20 Feb 2024 00:00:00 +0100","authors":{"author":[{"name":["Dominika Pleśniak"],"photo":["https://blog.allegro.tech/img/authors/dominika.plesniak.jpg"],"url":["https://blog.allegro.tech/authors/dominika.plesniak"]}]},"content":"<p>Have you ever thought about ways of reducing repetitive, monotonous tasks? Maybe you would like to try to automate your own tasks? I will show you what\ntechnology we use at Allegro, what processes we have automated, and how to do it on your own.</p>\n\n<h2 id=\"what-is-rpa-and-how-do-we-use-it-at-allegro\">What is RPA and how do we use it at Allegro?</h2>\n\n<blockquote>\n  <p><em>“Robotic process automation (RPA) is a software technology that makes it easy to build, deploy, and manage software robots that emulate humans actions\ninteracting with digital systems and software. Just like people, software robots can do things like understand what’s on a screen, complete the right \nkeystrokes, navigate systems, identify and extract data, and perform a wide range of defined actions.”</em> \n<br /> \nSource: <a href=\"https://www.uipath.com/rpa/robotic-process-automation\">UiPath Robotic Process Automation</a></p>\n</blockquote>\n\n<p>At Allegro, our Process Automation Team primarily relies on UiPath as our key RPA tool. Processes suitable for automation through RPA are standardized, repetitive, manual, with high volume, stable and has data in digital form. If possible, we try to combine UiPath with different integrations such as scripts, databases, chatbots.</p>\n\n<p>UiPath provides the ability to automate all kinds of applications (web, desktop, java, etc.). Automations can be created through the user interface of an \napplication, meaning that the created robot imitates an employee’s clicks. Furthermore, when an application’s API is available, it is easy to integrate \nUiPath with API, and in that case, the robot’s steps are performed in the backend-side. UiPath also allows the use of\nOCR (optical character recognition) and machine learning modules.</p>\n\n<p>Thanks to the various roles within Process Automation Team, such as analysts and developers, we are able to approach processes holistically. When we receive an idea for \nautomatization, we first perform an assessment to establish if the process is suitable for robotization, and we calculate the Return On Investment (ROI) and the potential of\ntime savings from automation in terms of <a href=\"https://en.wikipedia.org/wiki/Full-time_equivalent\">Full-Time Equivalent (FTE)</a>. Once the assessment is done and costs of investment return are approved, we analyze and optimize the process. \nAs a result, the analyst prepares a Process Definition Document (PDD) which serves as an instruction/description of the process.\nIn the next phase, based on PDD, a developer takes over the process and designs a solution. After that, the development part begins while the robot is created.\nLast but not least, there is the testing phase, where we check the results of the robotization together with the analyst and the business process owner.\nIf the solution is successful and performs as intended, we run the robot in production. Then we enter the hypercare period, during which we monitor and make necessary adjustments\nin tandem with the business process owner. After about two weeks of this phase, if both sides are satisfied with the results, we “go live”.</p>\n\n<p><img src=\"/img/articles/2024-02-20-rpa/robotic_process_automation_workflow.png\" alt=\"Robotic Process Automation Workflow\" /></p>\n\n<h2 id=\"what-kind-of-processes-do-we-automate\">What kind of processes do we automate?</h2>\n\n<h3 id=\"jira-automations\">Jira automations</h3>\n\n<p>In our organization we have a lot of processes based on Jira “tickets”. Many employees had to manage and operate Jira’s queues. Our team implemented several \nrobots to relieve administrators from repetitive tasks. Jira has an API available which we used in combination with the UiPath platform. \nFor example, when an employee is leaving Allegro, several Jira tasks are automatically created to retract authorization in various systems. Previously, these tasks were \nperformed manually by administrators. Now, the process is fully automated. The robot manages tickets via API and checks accounts in systems by GUI.</p>\n\n<h3 id=\"sap-enterprise-resource-planning-system-processes\">SAP (Enterprise Resource Planning system) processes</h3>\n\n<p>All repetitive, rule-based processes in SAP can be automated. For instance, let’s consider the processes in the Finance team. They handle massive amounts of \ninvoices. For some suppliers, with the largest quantity of invoices and unchangeable invoice layout, we were able to automate the accounting process in SAP. \nThe robot accesses an appropriate transaction in SAP and lists invoices. Based on business rules, the bot selects a specific invoice, opens it, and \nreads selected values. Then, it compares these values with business conditions which were established in the Process Definition Document. Depending on the \nsituation, the robot fills or corrects adequate fields and either accepts or rejects the invoice.</p>\n\n<h3 id=\"automation-by-api\">Automation by API</h3>\n\n<p>One of the excellent examples of API automations is the process of changing product categories on the Allegro platform. Allegro hosts a vast number of products. Initially, \nnot all of them are assigned to the proper category. We were able to create a robot that uses Allegro’s REST API to move these products to the target category.\nBefore automation, this task was time-consuming and monotonous. Recently, the robot completed a huge task, moving almost 3 million products in two days!</p>\n\n<h3 id=\"processes-across-multiple-applications-and-integrations\">Processes across multiple applications and integrations</h3>\n\n<p>It is possible to combine tasks from different applications into one robot. This approach allows us to automate more complex processes. \nThe most interesting ones include:</p>\n<ul>\n  <li>The process of user’s data change in Allegro platform is carried out at the request of users. To perform all actions, the bot uses Salesforce and \nInternal Admin tools. The robot downloads a report with requests, then checks the pre-set business rules. Based on the results, the bot changes user’s data or\n rejects the request.\nThe robot works 24 hours a day, handling 80% of applications. The number of tasks it performs can be compared to the work of four full-time employees.</li>\n  <li>The anti-fraud process. The robot verifies hundreds of thousands of messages and blocks suspected accounts. Using suspicious messages from the Spoof \napplication (Message Center), the robot determines if a message is spam or not. To make a proper decision, it checks various business conditions to decide \nif an account should be blocked. After making the decision, the bot blocks the account’s message sending capabilities.</li>\n  <li>The process for the HR team where the robot works on two applications. The robot interacts with the interface of an application and also uses its API. \nIn the recruitment process, specialists from different fields participate and help recruiters to find the best candidates. These specialists are known as \nthe Hiring Squad. A significant number of people are involved in this process, and the robot is responsible for keeping the Hiring Squad updated. Based \non a report with job offers the robot checks if a candidate has active status for specific skills required for the interview process. If the status is active, \nthe bot selects a particular job offer from the platform and assigns the interviewer from Hiring Squad.</li>\n</ul>\n\n<h3 id=\"human-in-the-loop\">“Human in the Loop”</h3>\n\n<p>Those processes which are rule-based, repetitive, but require human decision-making or the robot does not know what to do on the basis of the collected data, \nare referred to as “human in the loop”. A great example could be the process of damage complaints regarding packages that we have automated. The robot gathers a report \nfrom Salesforce and filters all jobs referring to damaged packages. Then, in the Internal Admin tool, the bot checks and collects various pieces of information based \non specific business rules. If necessary, it also checks the status of packages on carrier websites. Finally, the robot creates a form with all the gathered \ndetails, information, and attachments. This form is sent to a human for verification. With all this collected information, an employee can quickly decide \nwhether the complaint should be accepted. Then, the decision is sent back to the robot, which is able to close the case. It sends appropriate emails and \nrecords the results in the system.</p>\n\n<h2 id=\"robotics-workshops-for-employees\">Robotics workshops for employees</h2>\n\n<p>Additionally, twice a year, we organize an educational program for employees called “Allegro Robot School”. Employees get a chance to learn how to build \nbasic robots in UiPath and build one to support their daily tasks. To sign up for the program there is no need to have coding experience. It is enough if \nan employee can think analytically and has motivation to learn new things.\nThe program is intensive, consisting of five days of workshops. After the workshops, there is a three-weeks period where, with our support, employees choose \ntheir own processes and build robots.\nFor each edition we have around ten participants. The robots created during one edition account for about 3 FTEs! We have many examples of graduate \nemployees who created more robots to support their daily work in a team. Moreover, we created a Slack community for graduates to stay in touch, share \nknowledge, and support the development of new robots.</p>\n\n<h2 id=\"summary\">Summary</h2>\n\n<p>Today, the number of processes and different applications used in companies is enormous. Moreover, it can sometimes be challenging to integrate one application\nwith another, and employees are burdened with many manual, repetitive tasks. It is important to know that there is a solution to automate these processes. \nThe RPA technology can quickly help with that, freeing up employees for more creative tasks. The above examples visualize the possibilities of using UiPath.\nThe most important thing to remember is that the process to automate has to be manual, rule-based, repetitive, with data in digital form. What is more, \nit is possible to learn for those who don’t have coding experience. Thanks to that, the automation of processes can be expanded across the company beyond the Process Automation Team.</p>\n","contentSnippet":"Have you ever thought about ways of reducing repetitive, monotonous tasks? Maybe you would like to try to automate your own tasks? I will show you what\ntechnology we use at Allegro, what processes we have automated, and how to do it on your own.\nWhat is RPA and how do we use it at Allegro?\n“Robotic process automation (RPA) is a software technology that makes it easy to build, deploy, and manage software robots that emulate humans actions\ninteracting with digital systems and software. Just like people, software robots can do things like understand what’s on a screen, complete the right \nkeystrokes, navigate systems, identify and extract data, and perform a wide range of defined actions.” \n \nSource: UiPath Robotic Process Automation\nAt Allegro, our Process Automation Team primarily relies on UiPath as our key RPA tool. Processes suitable for automation through RPA are standardized, repetitive, manual, with high volume, stable and has data in digital form. If possible, we try to combine UiPath with different integrations such as scripts, databases, chatbots.\nUiPath provides the ability to automate all kinds of applications (web, desktop, java, etc.). Automations can be created through the user interface of an \napplication, meaning that the created robot imitates an employee’s clicks. Furthermore, when an application’s API is available, it is easy to integrate \nUiPath with API, and in that case, the robot’s steps are performed in the backend-side. UiPath also allows the use of\nOCR (optical character recognition) and machine learning modules.\nThanks to the various roles within Process Automation Team, such as analysts and developers, we are able to approach processes holistically. When we receive an idea for \nautomatization, we first perform an assessment to establish if the process is suitable for robotization, and we calculate the Return On Investment (ROI) and the potential of\ntime savings from automation in terms of Full-Time Equivalent (FTE). Once the assessment is done and costs of investment return are approved, we analyze and optimize the process. \nAs a result, the analyst prepares a Process Definition Document (PDD) which serves as an instruction/description of the process.\nIn the next phase, based on PDD, a developer takes over the process and designs a solution. After that, the development part begins while the robot is created.\nLast but not least, there is the testing phase, where we check the results of the robotization together with the analyst and the business process owner.\nIf the solution is successful and performs as intended, we run the robot in production. Then we enter the hypercare period, during which we monitor and make necessary adjustments\nin tandem with the business process owner. After about two weeks of this phase, if both sides are satisfied with the results, we “go live”.\n\nWhat kind of processes do we automate?\nJira automations\nIn our organization we have a lot of processes based on Jira “tickets”. Many employees had to manage and operate Jira’s queues. Our team implemented several \nrobots to relieve administrators from repetitive tasks. Jira has an API available which we used in combination with the UiPath platform. \nFor example, when an employee is leaving Allegro, several Jira tasks are automatically created to retract authorization in various systems. Previously, these tasks were \nperformed manually by administrators. Now, the process is fully automated. The robot manages tickets via API and checks accounts in systems by GUI.\nSAP (Enterprise Resource Planning system) processes\nAll repetitive, rule-based processes in SAP can be automated. For instance, let’s consider the processes in the Finance team. They handle massive amounts of \ninvoices. For some suppliers, with the largest quantity of invoices and unchangeable invoice layout, we were able to automate the accounting process in SAP. \nThe robot accesses an appropriate transaction in SAP and lists invoices. Based on business rules, the bot selects a specific invoice, opens it, and \nreads selected values. Then, it compares these values with business conditions which were established in the Process Definition Document. Depending on the \nsituation, the robot fills or corrects adequate fields and either accepts or rejects the invoice.\nAutomation by API\nOne of the excellent examples of API automations is the process of changing product categories on the Allegro platform. Allegro hosts a vast number of products. Initially, \nnot all of them are assigned to the proper category. We were able to create a robot that uses Allegro’s REST API to move these products to the target category.\nBefore automation, this task was time-consuming and monotonous. Recently, the robot completed a huge task, moving almost 3 million products in two days!\nProcesses across multiple applications and integrations\nIt is possible to combine tasks from different applications into one robot. This approach allows us to automate more complex processes. \nThe most interesting ones include:\nThe process of user’s data change in Allegro platform is carried out at the request of users. To perform all actions, the bot uses Salesforce and \nInternal Admin tools. The robot downloads a report with requests, then checks the pre-set business rules. Based on the results, the bot changes user’s data or\n rejects the request.\nThe robot works 24 hours a day, handling 80% of applications. The number of tasks it performs can be compared to the work of four full-time employees.\nThe anti-fraud process. The robot verifies hundreds of thousands of messages and blocks suspected accounts. Using suspicious messages from the Spoof \napplication (Message Center), the robot determines if a message is spam or not. To make a proper decision, it checks various business conditions to decide \nif an account should be blocked. After making the decision, the bot blocks the account’s message sending capabilities.\nThe process for the HR team where the robot works on two applications. The robot interacts with the interface of an application and also uses its API. \nIn the recruitment process, specialists from different fields participate and help recruiters to find the best candidates. These specialists are known as \nthe Hiring Squad. A significant number of people are involved in this process, and the robot is responsible for keeping the Hiring Squad updated. Based \non a report with job offers the robot checks if a candidate has active status for specific skills required for the interview process. If the status is active, \nthe bot selects a particular job offer from the platform and assigns the interviewer from Hiring Squad.\n“Human in the Loop”\nThose processes which are rule-based, repetitive, but require human decision-making or the robot does not know what to do on the basis of the collected data, \nare referred to as “human in the loop”. A great example could be the process of damage complaints regarding packages that we have automated. The robot gathers a report \nfrom Salesforce and filters all jobs referring to damaged packages. Then, in the Internal Admin tool, the bot checks and collects various pieces of information based \non specific business rules. If necessary, it also checks the status of packages on carrier websites. Finally, the robot creates a form with all the gathered \ndetails, information, and attachments. This form is sent to a human for verification. With all this collected information, an employee can quickly decide \nwhether the complaint should be accepted. Then, the decision is sent back to the robot, which is able to close the case. It sends appropriate emails and \nrecords the results in the system.\nRobotics workshops for employees\nAdditionally, twice a year, we organize an educational program for employees called “Allegro Robot School”. Employees get a chance to learn how to build \nbasic robots in UiPath and build one to support their daily tasks. To sign up for the program there is no need to have coding experience. It is enough if \nan employee can think analytically and has motivation to learn new things.\nThe program is intensive, consisting of five days of workshops. After the workshops, there is a three-weeks period where, with our support, employees choose \ntheir own processes and build robots.\nFor each edition we have around ten participants. The robots created during one edition account for about 3 FTEs! We have many examples of graduate \nemployees who created more robots to support their daily work in a team. Moreover, we created a Slack community for graduates to stay in touch, share \nknowledge, and support the development of new robots.\nSummary\nToday, the number of processes and different applications used in companies is enormous. Moreover, it can sometimes be challenging to integrate one application\nwith another, and employees are burdened with many manual, repetitive tasks. It is important to know that there is a solution to automate these processes. \nThe RPA technology can quickly help with that, freeing up employees for more creative tasks. The above examples visualize the possibilities of using UiPath.\nThe most important thing to remember is that the process to automate has to be manual, rule-based, repetitive, with data in digital form. What is more, \nit is possible to learn for those who don’t have coding experience. Thanks to that, the automation of processes can be expanded across the company beyond the Process Automation Team.","guid":"https://blog.allegro.tech/2024/02/rpa.html","categories":["tech","rpa"],"isoDate":"2024-02-19T23:00:00.000Z"}],"jobs":[{"id":"743999990616328","name":"Senior Salesforce Software Engineer","uuid":"d984c251-7464-4af8-be1b-0e462f02be12","jobAdId":"d0b08f39-f02c-4e32-ad36-475f900ddfc1","defaultJobAd":true,"refNumber":"REF4747J","company":{"identifier":"Allegro","name":"Allegro"},"releasedDate":"2024-05-29T08:03:29.629Z","location":{"city":"Poznań, Warsaw","country":"pl","remote":false},"industry":{"id":"internet","label":"Internet"},"department":{"id":"2572770","label":"IT - Software Development"},"function":{"id":"information_technology","label":"Information Technology"},"typeOfEmployment":{"id":"permanent","label":"Full-time"},"experienceLevel":{"id":"mid_senior_level","label":"Mid-Senior Level"},"customField":[{"fieldId":"61583054f15cea434e0be36f","fieldLabel":"Career Level","valueId":"26b58095-3c5f-4596-937f-27547fb80b07","valueLabel":"5"},{"fieldId":"61582f70e72a6b6d239c9857","fieldLabel":"Area","valueId":"76599a72-f283-4550-9303-52e2e0eb6e32","valueLabel":"Technology"},{"fieldId":"58c15608e4b01d4b19ddf790","fieldLabel":"Recruitment Process","valueId":"ed4682c7-33c9-41c2-8d13-428ed39046f5","valueLabel":"Tech. Engineer - IC"},{"fieldId":"6406f92e638cbb2f415a94a9","fieldLabel":"Job Area","valueId":"e8731ea4-48a9-476d-ab1d-9a40eb3426f1","valueLabel":"Technology"},{"fieldId":"COUNTRY","fieldLabel":"Country","valueId":"pl","valueLabel":"Poland"},{"fieldId":"58c13159e4b01d4b19ddf729","fieldLabel":"Department","valueId":"2572770","valueLabel":"IT - Software Development"},{"fieldId":"58c13159e4b01d4b19ddf728","fieldLabel":"Brands","valueId":"4ccb4fab-6c3f-4ed0-9140-8533fe17447f","valueLabel":"Allegro sp. z o.o."}],"visibility":"PUBLIC","ref":"https://api.smartrecruiters.com/v1/companies/allegro/postings/743999990616328","creator":{"name":"Agnieszka Adamus"},"language":{"code":"en","label":"English","labelNative":"English (US)"}},{"id":"743999990181193","name":"Senior Software Engineer (Python)  - TP&O","uuid":"115ee12e-eaa2-455c-81fc-b42df6f8b529","jobAdId":"d2e1f185-6762-4f5c-9de7-2d29fcedec03","defaultJobAd":true,"refNumber":"REF4913R","company":{"identifier":"Allegro","name":"Allegro"},"releasedDate":"2024-05-27T10:07:28.306Z","location":{"city":"Warsaw, Poznań","country":"pl","remote":false},"industry":{"id":"internet","label":"Internet"},"department":{"id":"2572770","label":"IT - Software Development"},"function":{"id":"engineering","label":"Engineering"},"typeOfEmployment":{"id":"permanent","label":"Full-time"},"experienceLevel":{"id":"mid_senior_level","label":"Mid-Senior Level"},"customField":[{"fieldId":"61583054f15cea434e0be36f","fieldLabel":"Career Level","valueId":"26b58095-3c5f-4596-937f-27547fb80b07","valueLabel":"5"},{"fieldId":"61582f70e72a6b6d239c9857","fieldLabel":"Area","valueId":"76599a72-f283-4550-9303-52e2e0eb6e32","valueLabel":"Technology"},{"fieldId":"58c15608e4b01d4b19ddf790","fieldLabel":"Recruitment Process","valueId":"ed4682c7-33c9-41c2-8d13-428ed39046f5","valueLabel":"Tech. Engineer - IC"},{"fieldId":"6406f92e638cbb2f415a94a9","fieldLabel":"Job Area","valueId":"e8731ea4-48a9-476d-ab1d-9a40eb3426f1","valueLabel":"Technology"},{"fieldId":"COUNTRY","fieldLabel":"Country","valueId":"pl","valueLabel":"Poland"},{"fieldId":"58c13159e4b01d4b19ddf729","fieldLabel":"Department","valueId":"2572770","valueLabel":"IT - Software Development"},{"fieldId":"58c13159e4b01d4b19ddf728","fieldLabel":"Brands","valueId":"4ccb4fab-6c3f-4ed0-9140-8533fe17447f","valueLabel":"Allegro sp. z o.o."}],"visibility":"PUBLIC","ref":"https://api.smartrecruiters.com/v1/companies/allegro/postings/743999990181193","creator":{"name":"Jagoda Rusiniak"},"language":{"code":"en","label":"English","labelNative":"English (US)"}},{"id":"743999989074323","name":"Front-End Software Engineer - Ads","uuid":"c1adfbe6-4468-4775-a3d9-44a26a1b86a5","jobAdId":"fb5b74ad-85c4-4ae6-b670-a68bf6e5b18a","defaultJobAd":true,"refNumber":"REF4981A","company":{"identifier":"Allegro","name":"Allegro"},"releasedDate":"2024-05-21T11:23:50.882Z","location":{"city":"Warsaw","country":"pl","remote":false},"industry":{"id":"internet","label":"Internet"},"department":{"id":"2572770","label":"IT - Software Development"},"function":{"id":"information_technology","label":"Information Technology"},"typeOfEmployment":{"id":"permanent","label":"Full-time"},"experienceLevel":{"id":"associate","label":"Associate"},"customField":[{"fieldId":"61583054f15cea434e0be36f","fieldLabel":"Career Level","valueId":"3976147c-fe25-42a8-8c97-78273250960b","valueLabel":"4"},{"fieldId":"61582f70e72a6b6d239c9857","fieldLabel":"Area","valueId":"76599a72-f283-4550-9303-52e2e0eb6e32","valueLabel":"Technology"},{"fieldId":"58c15608e4b01d4b19ddf790","fieldLabel":"Recruitment Process","valueId":"b3da614a-1ddb-441b-a557-5acfdb6fcb90","valueLabel":"NEW Technology CL 1-6"},{"fieldId":"6406f92e638cbb2f415a94a9","fieldLabel":"Job Area","valueId":"e8731ea4-48a9-476d-ab1d-9a40eb3426f1","valueLabel":"Technology"},{"fieldId":"COUNTRY","fieldLabel":"Country","valueId":"pl","valueLabel":"Poland"},{"fieldId":"58c13159e4b01d4b19ddf729","fieldLabel":"Department","valueId":"2572770","valueLabel":"IT - Software Development"},{"fieldId":"58c13159e4b01d4b19ddf728","fieldLabel":"Brands","valueId":"4ccb4fab-6c3f-4ed0-9140-8533fe17447f","valueLabel":"Allegro sp. z o.o."}],"visibility":"PUBLIC","ref":"https://api.smartrecruiters.com/v1/companies/allegro/postings/743999989074323","language":{"code":"en","label":"English","labelNative":"English (US)"}},{"id":"743999988837033","name":"Contractor Software Engineer (Java/Kotlin)","uuid":"bc22f235-405b-42c5-a377-08b9431c739f","jobAdId":"eba60e1f-3a45-4af9-a9e7-2b36917ce3eb","defaultJobAd":true,"refNumber":"REF4956T","company":{"identifier":"Allegro","name":"Allegro"},"releasedDate":"2024-05-20T16:44:43.844Z","location":{"city":"Warsaw, Poznań","country":"pl","remote":false},"industry":{"id":"internet","label":"Internet"},"department":{"id":"2572770","label":"IT - Software Development"},"function":{"id":"information_technology","label":"Information Technology"},"typeOfEmployment":{"id":"contract","label":"Contract"},"experienceLevel":{"id":"mid_senior_level","label":"Mid-Senior Level"},"customField":[{"fieldId":"58c15608e4b01d4b19ddf790","fieldLabel":"Recruitment Process","valueId":"e543c79f-6df9-499f-8ba8-237c3c331cc1","valueLabel":"NEW B2B Technology CL 1-6"},{"fieldId":"6406f92e638cbb2f415a94a9","fieldLabel":"Job Area","valueId":"e8731ea4-48a9-476d-ab1d-9a40eb3426f1","valueLabel":"Technology"},{"fieldId":"COUNTRY","fieldLabel":"Country","valueId":"pl","valueLabel":"Poland"},{"fieldId":"61583054f15cea434e0be36f","fieldLabel":"Career Level","valueId":"3c97f53f-19c2-4a25-9eb1-513f9fb38b80","valueLabel":"3-5"},{"fieldId":"58c13159e4b01d4b19ddf729","fieldLabel":"Department","valueId":"2572770","valueLabel":"IT - Software Development"},{"fieldId":"58c13159e4b01d4b19ddf728","fieldLabel":"Brands","valueId":"f7af19b5-5d6a-43a0-9a2b-1e99277515c7","valueLabel":"Opennet.pl Sp. z o.o."},{"fieldId":"61582f70e72a6b6d239c9857","fieldLabel":"Area","valueId":"76599a72-f283-4550-9303-52e2e0eb6e32","valueLabel":"Technology"}],"visibility":"PUBLIC","ref":"https://api.smartrecruiters.com/v1/companies/allegro/postings/743999988837033","language":{"code":"en","label":"English","labelNative":"English (US)"}},{"id":"743999987145193","name":"Software Engineer (.NET) - Product Team - Allegro Pay","uuid":"295c893e-3c03-431b-9da7-eb18a45f98ed","jobAdId":"57040109-b330-495b-aa0d-247de3ea2066","defaultJobAd":false,"refNumber":"REF4748E","company":{"identifier":"Allegro","name":"Allegro"},"releasedDate":"2024-05-13T13:02:53.832Z","location":{"city":"Warsaw","region":"Masovian Voivodeship","country":"pl","remote":false,"latitude":"52.2296756","longitude":"21.0122287"},"industry":{"id":"internet","label":"Internet"},"department":{"id":"2572770","label":"IT - Software Development"},"function":{"id":"information_technology","label":"Information Technology"},"typeOfEmployment":{"id":"permanent","label":"Full-time"},"experienceLevel":{"id":"mid_senior_level","label":"Mid-Senior Level"},"customField":[{"fieldId":"61583054f15cea434e0be36f","fieldLabel":"Career Level","valueId":"3c97f53f-19c2-4a25-9eb1-513f9fb38b80","valueLabel":"3-5"},{"fieldId":"61582f70e72a6b6d239c9857","fieldLabel":"Area","valueId":"76599a72-f283-4550-9303-52e2e0eb6e32","valueLabel":"Technology"},{"fieldId":"58c15608e4b01d4b19ddf790","fieldLabel":"Recruitment Process","valueId":"b3da614a-1ddb-441b-a557-5acfdb6fcb90","valueLabel":"NEW Technology CL 1-6"},{"fieldId":"6406f92e638cbb2f415a94a9","fieldLabel":"Job Area","valueId":"e8731ea4-48a9-476d-ab1d-9a40eb3426f1","valueLabel":"Technology"},{"fieldId":"COUNTRY","fieldLabel":"Country","valueId":"pl","valueLabel":"Poland"},{"fieldId":"58c13159e4b01d4b19ddf729","fieldLabel":"Department","valueId":"2572770","valueLabel":"IT - Software Development"},{"fieldId":"58c13159e4b01d4b19ddf728","fieldLabel":"Brands","valueId":"9c8396d4-11a6-443c-897c-15f29221a3fd","valueLabel":"Allegro Pay sp. z o.o."}],"visibility":"PUBLIC","ref":"https://api.smartrecruiters.com/v1/companies/allegro/postings/743999987145193","creator":{"name":"Martyna Stafa"},"language":{"code":"en","label":"English","labelNative":"English (US)"}}],"events":[{"created":1715716710000,"duration":7200000,"id":"301022703","name":"Allegro Tech Talks #43 - Wszystko o programie e-Xperience","date_in_series_pattern":false,"status":"past","time":1716393600000,"local_date":"2024-05-22","local_time":"18:00","updated":1716406648000,"utc_offset":7200000,"waitlist_count":0,"yes_rsvp_count":14,"venue":{"id":27570147,"name":"Allegro Office - Poznań (Nowy Rynek)","lat":52.40021514892578,"lon":16.92083168029785,"repinned":false,"address_1":"Wierzbięcice 1B - budynek D","city":"Poznań","country":"pl","localized_country_name":"Poland"},"is_online_event":false,"eventType":"PHYSICAL","group":{"created":1425052059000,"name":"allegro Tech","id":18465254,"join_mode":"open","lat":52.2599983215332,"lon":21.020000457763672,"urlname":"allegrotech","who":"Techs","localized_location":"Warsaw, Poland","state":"","country":"pl","region":"en_US","timezone":"Europe/Warsaw"},"link":"https://www.meetup.com/allegrotech/events/301022703/","description":"**➡ Rejestracja:** [https://app.evenea.pl/event/allegro-tech-talk-43/](https://app.evenea.pl/event/allegro-tech-talk-43/) Zapraszamy Was na #43 wydarzenie z serii Allegro Tech Talk, podczas których dzielimy się wiedzą, wzajemnie inspirujemy oraz integrujemy przy dobrej kawie☕, napojach🥤…","how_to_find_us":"Biuro Allegro znajduje się w kompleksie Nowy Rynek. Szukaj budynku D i kieruj się do wejścia od ul. Wierzbięcice. Komunikacja miejska: najbliższy przystanek to Wierzbięcice i kursują tu linie tramwajowe numer 2, 5, 6, 10, 12, 18 Spacerem - z dworca Poznań Główny przejście zajmie Ci około 5 minut.","visibility":"public","member_pay_fee":false},{"created":1702979844000,"duration":187200000,"id":"298027809","name":"UX Research Confetti - IV edycja","date_in_series_pattern":false,"status":"past","time":1716202800000,"local_date":"2024-05-20","local_time":"13:00","updated":1716392955000,"utc_offset":7200000,"waitlist_count":0,"yes_rsvp_count":82,"venue":{"id":27549223,"name":"Allegro Warsaw Office","lat":52.23224639892578,"lon":20.992111206054688,"repinned":true,"address_1":"ul. Żelazna 51/53","city":"Warszawa","country":"pl","localized_country_name":"Poland"},"is_online_event":false,"eventType":"PHYSICAL","group":{"created":1425052059000,"name":"allegro Tech","id":18465254,"join_mode":"open","lat":52.2599983215332,"lon":21.020000457763672,"urlname":"allegrotech","who":"Techs","localized_location":"Warsaw, Poland","state":"","country":"pl","region":"en_US","timezone":"Europe/Warsaw"},"link":"https://www.meetup.com/allegrotech/events/298027809/","description":"**🎉 Przedstawiamy 4. edycję UX Research Confetti - bezpłatną, polską konferencję poświęconą badaniom UX, organizowaną przez zespół badaczy z Allegro.** ✨ Konferencja odbędzie się w…","visibility":"public","member_pay_fee":false},{"created":1712583756000,"duration":14400000,"id":"300288303","name":"DDD & EventStorming na luzie - unconference na 2 lata gildii w Allegro","date_in_series_pattern":false,"status":"past","time":1714129200000,"local_date":"2024-04-26","local_time":"13:00","updated":1714146607000,"utc_offset":7200000,"waitlist_count":0,"yes_rsvp_count":103,"venue":{"id":27549223,"name":"Allegro Warsaw Office","lat":52.23224639892578,"lon":20.992111206054688,"repinned":true,"address_1":"ul. Żelazna 51/53","city":"Warszawa","country":"pl","localized_country_name":"Poland"},"is_online_event":false,"eventType":"PHYSICAL","group":{"created":1425052059000,"name":"allegro Tech","id":18465254,"join_mode":"open","lat":52.2599983215332,"lon":21.020000457763672,"urlname":"allegrotech","who":"Techs","localized_location":"Warsaw, Poland","state":"","country":"pl","region":"en_US","timezone":"Europe/Warsaw"},"link":"https://www.meetup.com/allegrotech/events/300288303/","description":"**➡ Rejestracja:** **[https://app.evenea.pl/event/allegro-tech-talk-ddd/](https://app.evenea.pl/event/allegro-tech-talk-ddd/)** Dobrze Was widzieć! Allegro Tech to miejsce, w którym dzielimy się wiedzą, dobrymi praktykami i case study z różnych projektów prowadzonych w…","how_to_find_us":"Biuro Allegro znajduje się w kompleksie Fabryki Norblina. Szukaj wejścia Plater 3, od ul. Żelaznej. \n\nKomunikacja miejska: najbliższe przystanki to Norblin 05 i 06 z liniami: 109, 178, 157. Dojedziecie do nas również tramwajami numer 10 i 11 oraz metrem (Rondo ONZ lub Rondo Daszyńskiego).","visibility":"public","member_pay_fee":false},{"created":1712756447000,"duration":7200000,"id":"300327359","name":"Allegro Tech Talks #42 - Kariera Product Managera","date_in_series_pattern":false,"status":"past","time":1713888000000,"local_date":"2024-04-23","local_time":"18:00","updated":1713900030000,"utc_offset":7200000,"waitlist_count":0,"yes_rsvp_count":37,"venue":{"id":27549223,"name":"Allegro Warsaw Office","lat":52.23224639892578,"lon":20.992111206054688,"repinned":true,"address_1":"ul. Żelazna 51/53","city":"Warszawa","country":"pl","localized_country_name":"Poland"},"is_online_event":false,"eventType":"PHYSICAL","group":{"created":1425052059000,"name":"allegro Tech","id":18465254,"join_mode":"open","lat":52.2599983215332,"lon":21.020000457763672,"urlname":"allegrotech","who":"Techs","localized_location":"Warsaw, Poland","state":"","country":"pl","region":"en_US","timezone":"Europe/Warsaw"},"link":"https://www.meetup.com/allegrotech/events/300327359/","description":"**➡ Rejestracja:** [https://app.evenea.pl/event/allegro-tech-talk-42/ ](https://app.evenea.pl/event/allegro-tech-talk-42/) Zapraszamy Was na #42 wydarzenie z serii Allegro Tech Talk, podczas których dzielimy się wiedzą, wzajemnie inspirujemy oraz integrujemy przy dobrej…","how_to_find_us":"Biuro Allegro znajduje się w kompleksie Fabryki Norblina. Szukaj wejścia Plater 3, od ul. Żelaznej. \n\nKomunikacja miejska: najbliższe przystanki to Norblin 05 i 06 z liniami: 109, 178, 157. Dojedziesz do nas również tramwajami numer 10 i 11 oraz metrem (Rondo ONZ lub Rondo Daszyńskiego).","visibility":"public","member_pay_fee":false}],"podcasts":[{"title":"O pracy analityków w obszarze technologii i przetwarzaniu danych w dużej skali","link":"https://podcast.allegro.tech/o-pracy-analitykow-w-obszarze-technologii-i-przetwarzaniu-danych-w-duzej-skali/","pubDate":"Thu, 29 Feb 2024 00:00:00 GMT","content":"Na czym polega praca analityków w obszarze technologii w Allegro? Jakich narzędzi i technologii na co dzień używają osoby pracujące na tych stanowiskach? Jak efekty pracy analityków wpływają na naszą platformę, produkty i funkcjonalności? Czym zajmuje się Data Product Manager w Allegro Pay? Dlaczego monety są ważnym elementem ekosystemu Allegro? Posłuchajcie kolejnego odcinka Allegro Tech Podcast tym razem z udziałem Adrianny Napiórkowskiej - Data Product Managerki w Allegro Pay oraz Kaya Akcelikli - Senior Managera w obszarze Data w Allegro.","contentSnippet":"Na czym polega praca analityków w obszarze technologii w Allegro? Jakich narzędzi i technologii na co dzień używają osoby pracujące na tych stanowiskach? Jak efekty pracy analityków wpływają na naszą platformę, produkty i funkcjonalności? Czym zajmuje się Data Product Manager w Allegro Pay? Dlaczego monety są ważnym elementem ekosystemu Allegro? Posłuchajcie kolejnego odcinka Allegro Tech Podcast tym razem z udziałem Adrianny Napiórkowskiej - Data Product Managerki w Allegro Pay oraz Kaya Akcelikli - Senior Managera w obszarze Data w Allegro.","guid":"https://podcast.allegro.tech/o-pracy-analitykow-w-obszarze-technologii-i-przetwarzaniu-danych-w-duzej-skali/","isoDate":"2024-02-29T00:00:00.000Z"},{"title":"Programowanie - co liczy się w nim najbardziej?","link":"https://podcast.allegro.tech/programowanie-co-liczy-sie-w-nim-najbardziej/","pubDate":"Thu, 01 Feb 2024 00:00:00 GMT","content":"Jaką ścieżkę trzeba przejść, aby dobrze programować? Gdzie zdobywać wiedzę, doświadczenie i szlifować swoje umiejętności? Ile czasu potrzeba aby nabrać doświadczenia i jak zadbać o swój dalszy rozwój? Na czym w praktyce polegają role (Senior) Software Engineer oraz Engineering Manager w Allegro i kto najlepiej sprawdza się w naszych zespołach? Posłuchajcie nowego odcinka Allegro Tech Podcast z udziałem Rafała Schmidta (Senior Software Engineer) i Waldemara Panasa (Manager, Engineering) z Allegro.","contentSnippet":"Jaką ścieżkę trzeba przejść, aby dobrze programować? Gdzie zdobywać wiedzę, doświadczenie i szlifować swoje umiejętności? Ile czasu potrzeba aby nabrać doświadczenia i jak zadbać o swój dalszy rozwój? Na czym w praktyce polegają role (Senior) Software Engineer oraz Engineering Manager w Allegro i kto najlepiej sprawdza się w naszych zespołach? Posłuchajcie nowego odcinka Allegro Tech Podcast z udziałem Rafała Schmidta (Senior Software Engineer) i Waldemara Panasa (Manager, Engineering) z Allegro.","guid":"https://podcast.allegro.tech/programowanie-co-liczy-sie-w-nim-najbardziej/","isoDate":"2024-02-01T00:00:00.000Z"},{"title":"MBox: server-driven UI dla aplikacji mobilnych","link":"https://podcast.allegro.tech/mbox-server-driven-ui-dla-aplikacji-mobilnych/","pubDate":"Thu, 16 Nov 2023 00:00:00 GMT","content":"Czym jest i jak powstał MBox: wewnętrzna platforma server-driven UI dla aplikacji mobilnych w Allegro? Skąd wziął się pomysł na to rozwiązanie i na jakie bolączki odpowiada? Dlaczego zdecydowaliśmy się na budowanie tego typu rozwiązania in-house i z jakimi wyzwaniami mierzyliśmy się w procesie tworzenia? Co wyróżnia zespoły pracujące nad tym narzędziem i jak pracuje im się bez Product Ownera? Posłuchajcie siódmego odcinka Allegro Tech Podcast z udziałem Pauliny Sadowskiej i Tomasza Gębarowskiego - Managerów w obszarze Technical Platform Services w Allegro.","contentSnippet":"Czym jest i jak powstał MBox: wewnętrzna platforma server-driven UI dla aplikacji mobilnych w Allegro? Skąd wziął się pomysł na to rozwiązanie i na jakie bolączki odpowiada? Dlaczego zdecydowaliśmy się na budowanie tego typu rozwiązania in-house i z jakimi wyzwaniami mierzyliśmy się w procesie tworzenia? Co wyróżnia zespoły pracujące nad tym narzędziem i jak pracuje im się bez Product Ownera? Posłuchajcie siódmego odcinka Allegro Tech Podcast z udziałem Pauliny Sadowskiej i Tomasza Gębarowskiego - Managerów w obszarze Technical Platform Services w Allegro.","guid":"https://podcast.allegro.tech/mbox-server-driven-ui-dla-aplikacji-mobilnych/","isoDate":"2023-11-16T00:00:00.000Z"},{"title":"O chatbotach i ich wpływie na Allegro","link":"https://podcast.allegro.tech/o-chatbotach-i-ich-wplywie-na-allegro/","pubDate":"Wed, 11 Oct 2023 00:00:00 GMT","content":"Jakie procesy automatyzujemy w Allegro i co warto o nich wiedzieć w kontekście obszaru Customer Experience? W czym pomagają nam chatboty, jak je rozwijamy i dbamy o ich jakość? Kim są Allina oraz Albert i co mają wspólnego z automatyzacją? Za jakie rozwiązania otrzymaliśmy nagrodę hiperautomatyzacji? O tym wszystkim posłuchacie w odcinku z udziałem Rafała Gajewskiego - Managera w obszarze IT Services w Allegro.","contentSnippet":"Jakie procesy automatyzujemy w Allegro i co warto o nich wiedzieć w kontekście obszaru Customer Experience? W czym pomagają nam chatboty, jak je rozwijamy i dbamy o ich jakość? Kim są Allina oraz Albert i co mają wspólnego z automatyzacją? Za jakie rozwiązania otrzymaliśmy nagrodę hiperautomatyzacji? O tym wszystkim posłuchacie w odcinku z udziałem Rafała Gajewskiego - Managera w obszarze IT Services w Allegro.","guid":"https://podcast.allegro.tech/o-chatbotach-i-ich-wplywie-na-allegro/","isoDate":"2023-10-11T00:00:00.000Z"}]},"__N_SSG":true}