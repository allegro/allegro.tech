{"pageProps":{"posts":[{"title":"A Mission to Cost-Effectiveness: Reducing the cost of a single Google Cloud Dataflow Pipeline by Over 60%","link":"https://blog.allegro.tech/2024/06/cost-optimization-data-pipeline-gcp.html","pubDate":"Thu, 20 Jun 2024 00:00:00 +0200","authors":{"author":[{"name":["Jakub Demianowski"],"photo":["https://blog.allegro.tech/img/authors/jakub.demianowski.jpg"],"url":["https://blog.allegro.tech/authors/jakub.demianowski"]}]},"content":"<p>In this article we’ll present methods for efficiently optimizing physical resources and fine-tuning the configuration of a Google Cloud Platform (GCP)\nDataflow pipeline in order to achieve cost reductions.\nOptimization will be presented as a real-life scenario, which will be performed in stages.</p>\n\n<p>Before we start, it’s time to introduce several avenues through which the cost of Big Data pipelines can be significantly reduced.\nThese include:</p>\n\n<ol>\n  <li>Careful optimization of consumed physical resources, like choosing VM types with optimal CPU to memory ratio and a cost-effective CPU type.</li>\n  <li>Enhancing the configuration of the data processing engine to maximize its efficiency.</li>\n  <li>Optimizing input and output datasets. Not all data may need processing or perhaps, altering their structure could reduce the processing time.</li>\n  <li>Refining storage strategies for input and output datasets. This is particularly beneficial if reading or writing speeds are suboptimal and demand improvements.</li>\n  <li>Streamlining of our pipeline code and utilizing built-in optimization functionalities (for example broadcast joins and repartitioning in Apache Spark).</li>\n</ol>\n\n<p>Throughout this article we will focus solely on optimizing consumed physical resources (1st point) and enhancing configuration of the data processing engine (2nd point).</p>\n\n<h2 id=\"about-the-data-pipeline-being-optimized\">About the data pipeline being optimized</h2>\n\n<p>The data pipeline which will serve us as an example throughout this article is written in Apache Beam using Python SDK.\nThe pipeline runs on Google Cloud Dataflow processing engine.\nThe goal of the pipeline is to join a couple of tables (most of them are a terabyte+ in size), apply some transformations and produce a unified output table.</p>\n\n<p>Overall processing cost of the full dataset is around $350 per day.\nIt results in roughly $10,500 per month, and $127,000 per year.</p>\n\n<h2 id=\"approach-to-cost-optimization\">Approach to cost optimization</h2>\n\n<p>At the beginning of the cost optimization let’s draft a couple of hypotheses:</p>\n\n<ul>\n  <li>Physical resources are underutilized.</li>\n  <li>Physical resources have not the best price-to-performance ratio.</li>\n  <li>Configuration of the Dataflow job is suboptimal and could be optimized.</li>\n</ul>\n\n<p>My goal will be to check those hypotheses.</p>\n\n<p>During the testing phase I’ll use a 3% subsample of input datasets. As a result I will be running tests with input size at ~100 GB level.\nThus, I’ll limit the cost of tests and significantly reduce their time. Final tests will be made on the full dataset, not on a limited subsample.</p>\n\n<p>In order to save time and resources I’ve made some speculative choices regarding what I should test during optimization.\nIn addition, I’ve decided not to test all the possible combinations of machine families, disk types and configuration options to save time.\nI will try to stick with the most promising choices and omit testing unpromising configurations.</p>\n\n<h2 id=\"hypothesis-testing-physical-resources-are-underutilized\">Hypothesis testing: physical resources are underutilized</h2>\n\n<p>In our initial configuration we used the following type of worker machines:</p>\n\n<ul>\n  <li>Machine type: <a href=\"https://cloud.google.com/compute/docs/general-purpose-machines#n2_series\">n2-standard-4</a> (4 vCPU, 16 GB of memory)</li>\n  <li>Disk size: 100 GB</li>\n  <li>Disk type: HDD</li>\n  <li>Max. worker nodes: 500</li>\n  <li>Autoscaling algorithm: throughput based</li>\n</ul>\n\n<p>I made a decision to focus on CPU and memory utilization first.</p>\n\n<h3 id=\"cpu-utilization\">CPU utilization</h3>\n<p>I checked if CPU utilization was on an acceptable level, and it was.</p>\n\n<p>The following diagram from Dataflow UI presents CPU utilization on All Workers in terms of the CPU utilization\nfor all cores on a single App Engine flexible instance.\nSo it gives us an idea of how the CPU is utilized on each virtual machine.</p>\n\n<p><img src=\"/img/articles/2024-06-20-cost-optimization-data-pipeline-gcp/01_cpu_utilization_all_workers.png\" alt=\"CPU utilization on all worker nodes\" class=\"image-with-frame\" /></p>\n\n<p>We could also take a look at the same data presented in terms of statistical metrics.</p>\n\n<p><img src=\"/img/articles/2024-06-20-cost-optimization-data-pipeline-gcp/02_cpu_utilization_stats.png\" alt=\"CPU utilization statistics\" class=\"image-with-frame\" /></p>\n\n<p>From the given graph I could see that mean utilization of the CPU was around 85%, which is a good score.\nThe result is affected by two shuffle stages, when we need to send data around the cluster (usually network is a small bottleneck here).\nCPU tends to be idle while shuffling data using Dataflow <a href=\"https://cloud.google.com/dataflow/docs/shuffle-for-batch\">Shuffle Service</a>.</p>\n\n<p>So CPU resources are not underutilized. We use almost all of what we pay for.</p>\n\n<h3 id=\"memory-utilization\">Memory utilization</h3>\n\n<p>In the end I checked memory usage. I saw that we did not use all the memory which we were paying for.\nLet’s take a look at the following two graphs.\nThe first one shows maximal memory utilization among all the workers.\n<img src=\"/img/articles/2024-06-20-cost-optimization-data-pipeline-gcp/03_memory_utilization_max_usage.png\" alt=\"Memory utilization max usage\" class=\"image-with-frame\" /></p>\n\n<p>The second one shows memory utilization statistics among all the worker nodes.\n<img src=\"/img/articles/2024-06-20-cost-optimization-data-pipeline-gcp/04_memory_utilization_summary.png\" alt=\"Memory utilization summary\" class=\"image-with-frame\" /></p>\n\n<p>The first one presents average memory usage on a worker node, the second one presents overall memory usage among the whole cluster.\nWe clearly see that we only use around 50% of the memory. Bingo, we pay for memory that we do not use.</p>\n\n<h3 id=\"improving-memory-utilization\">Improving memory utilization</h3>\n\n<p>Usually there are two ways of improving memory utilization:</p>\n\n<ul>\n  <li>Change CPU to memory ratio on worker nodes.</li>\n  <li>Decrease the amount of worker nodes.</li>\n</ul>\n\n<p>I’ve decided to change the CPU to memory ratio rather than decrease the number of worker nodes.\nI did not want to compromise on scalability and time needed to perform a job.</p>\n\n<p>Test on a 3% subsample of input data has given the following cost of data processing:</p>\n\n<ul>\n  <li>n2-standard-4: $9.48</li>\n  <li>n2-highcpu-8: $8.52 (~ 10% less than original price)</li>\n  <li>n2d-highcpu-8: $8.57 (~ 10% less than original price)</li>\n</ul>\n\n<p>We saved 10% on adjusting CPU and memory ratio.\nIt results in around $12,700 of estimated savings per year (10% of $127,000 annual cost).</p>\n\n<table>\n  <tr>\n    <th>Hypothesis</th>\n    <th>Savings<span><sup id=\"fnref:1\" role=\"doc-noteref\"><a href=\"#fn:1\" class=\"footnote\" rel=\"footnote\">1</a></sup></span></th>\n  </tr>\n  <tr>\n    <td>[1] Physical resources are underutilized</td>\n    <td>$12,700</td>\n  </tr>\n</table>\n\n<h2 id=\"hypothesis-testing-physical-resources-has-not-the-best-price-to-performance-ratio\">Hypothesis testing: physical resources has not the best price-to-performance ratio</h2>\n\n<p>I assumed that the current virtual machine type (n2-standard-4) has not the best price-to-performance ratio.\nTo check performance of different virtual machine types I used <a href=\"https://cloud.google.com/compute/docs/benchmarks-linux\">CoreMark scores provided by Google Cloud itself</a>.</p>\n\n<p>Based on CoreMark scores and official Google Cloud VM pricing, I prepared a table which would help me choose the VM type with the best price-to-performance ratio.\nThe most important column is “price per 1 mln points” — how much I need to pay on average to score 1 mln points.\nI used <a href=\"https://cloud.google.com/compute/vm-instance-pricing\">official VM instance prices from Google Cloud site</a> from region europe-west1.</p>\n\n<table>\n  <tr>\n    <th>Virtual Machine Type</th>\n    <th>Points in ScoreMark<span><sup id=\"fnref:2\" role=\"doc-noteref\"><a href=\"#fn:2\" class=\"footnote\" rel=\"footnote\">2</a></sup></span></th>\n    <th>Price per hour<span><sup id=\"fnref:3\" role=\"doc-noteref\"><a href=\"#fn:3\" class=\"footnote\" rel=\"footnote\">3</a></sup></span></th>\n    <th>Price per 1 mln points</th>\n  </tr>\n  <tr>\n    <td>n2-standard-4</td>\n    <td>66 833 pts</td>\n    <td>$0.21</td>\n    <td>$3.20</td>\n  </tr>\n  <tr>\n    <td>n2-standard-8</td>\n    <td>138 657 pts</td>\n    <td>$0.43</td>\n    <td>$3.08</td>\n  </tr>\n  <tr>\n    <td>n2d-standard-8</td>\n    <td>164 539 pts</td>\n    <td>$0.37</td>\n    <td>$2.26</td>\n  </tr>\n  <tr>\n    <td>e2-standard-8</td>\n    <td>103 808 pts</td>\n    <td>$0.29</td>\n    <td>$2.84</td>\n  </tr>\n  <tr>\n    <td>t2d-standard-8</td>\n    <td>237 411 pts</td>\n    <td>$0.37</td>\n    <td>$1.57</td>\n  </tr>\n</table>\n\n<p>As we see, another hypothesis proved to be true. We’re not using the virtual machine type with the best price-to-performance ratio - T2D.\nWe’re using N2 machine type.</p>\n\n<p>Unfortunately, at the time of writing, T2D machines do not provide CPU to memory ratios other than 3 GB per 1 vCPU.\nIt’s still better than 4 GB per 1 vCPU, but far from 1 or 2 GB per 1 vCPU.\nWe will check if T2D virtual machine type with 4 GB of memory per 1 CPU is cheaper than its counterparts.</p>\n\n<h3 id=\"moving-to-a-virtual-machine-type-with-better-price-to-performance-ratio\">Moving to a virtual machine type with better price-to-performance ratio</h3>\n\n<p>I performed several tests on a small scale (3% subsample of input data) with T2D machine types. Let’s take a look at them.</p>\n\n<ul>\n  <li>n2-standard-4 + HDD: $9.48</li>\n  <li>n2-highcpu-8 + HDD: $8.52 (~ 10% less than original price)</li>\n  <li>n2d-highcpu-8 + HDD: $8.57 (~ 10% less than original price)</li>\n  <li>t2d-standard-8 + HDD: $6.65 (~ 32% less than original price)</li>\n</ul>\n\n<p>This way we decreased the estimated processing cost from $127,000 by $40,640 per year to $86,360 (by 32%)<sup id=\"fnref:1:1\" role=\"doc-noteref\"><a href=\"#fn:1\" class=\"footnote\" rel=\"footnote\">1</a></sup>.\nUnfortunately, we also introduced some possible underutilized resources (memory) by changing CPU to memory ratio.</p>\n\n<table>\n  <tr>\n    <th>Hypothesis</th>\n    <th>Savings<span><sup id=\"fnref:1:2\" role=\"doc-noteref\"><a href=\"#fn:1\" class=\"footnote\" rel=\"footnote\">1</a></sup></span></th>\n  </tr>\n  <tr>\n    <td>[1] Physical resources are underutilized</td>\n    <td>$12,700</td>\n  </tr>\n  <tr>\n    <td>[2] Moving to a more cost-effective VM type</td>\n    <td>$27,940</td>\n  </tr>\n</table>\n\n<p>Total: $40,640 of estimated savings<sup id=\"fnref:1:3\" role=\"doc-noteref\"><a href=\"#fn:1\" class=\"footnote\" rel=\"footnote\">1</a></sup></p>\n\n<h3 id=\"coming-back-to-optimization-of-virtual-machine-storage-type\">Coming back to optimization of virtual machine storage type</h3>\n\n<p>As I found the most suitable virtual machine type, I was able to focus on choosing between SSD and HDD disk types.\nAs we all know, HDDs are much slower than SSDs, especially in terms of random read/write.\nFor processes where we do not heavily use storage I/O operations there’s no need to move to more expensive SSDs.</p>\n\n<p>I decided to check if we should use cheaper and slower HDDs or more expensive and faster SSDs.\nI run the pipeline (3% of input data size) with HDD and SSD disks.\nHere are the results for different VM families:</p>\n\n<ul>\n  <li>n2-standard-4 + HDD: $9.48</li>\n  <li>n2-highcpu-8 + HDD: $8.52 (~ 10% less than original price)</li>\n  <li>n2d-highcpu-8 + HDD: $8.57 (~ 10% less than original price)</li>\n  <li>t2d-standard-8 + HDD: $6.65 (~ 32% less than original price)</li>\n  <li>t2d-standard-8 + SSD: $5.64 (~ 41% less than original price)</li>\n</ul>\n\n<p>This way we decreased the estimated processing cost from $127,000 by $52,070 per year to $74,930 (by 41%)<sup id=\"fnref:1:4\" role=\"doc-noteref\"><a href=\"#fn:1\" class=\"footnote\" rel=\"footnote\">1</a></sup>.</p>\n\n<table>\n  <tr>\n    <th>Hypothesis</th>\n    <th>Savings<span><sup id=\"fnref:1:5\" role=\"doc-noteref\"><a href=\"#fn:1\" class=\"footnote\" rel=\"footnote\">1</a></sup></span></th>\n  </tr>\n  <tr>\n    <td>[1] Physical resources are underutilized</td>\n    <td>$12,700</td>\n  </tr>\n  <tr>\n    <td>[2] Moving to a more cost-effective VM type</td>\n    <td>$27,940</td>\n  </tr>\n  <tr>\n    <td>[3] Changing VM disk type to SSD</td>\n    <td>$11,430</td>\n  </tr>\n</table>\n\n<p>Total: $52,070 of estimated savings<sup id=\"fnref:1:6\" role=\"doc-noteref\"><a href=\"#fn:1\" class=\"footnote\" rel=\"footnote\">1</a></sup></p>\n\n<h2 id=\"hypothesis-testing-configuration-of-the-dataflow-job-is-not-optimal\">Hypothesis testing: configuration of the Dataflow job is not optimal</h2>\n\n<p>Dataflow, in comparison to Apache Spark, leaves us with almost no configuration options to be changed.\nIt’s good because in Dataflow you get very decent out-of-the-box settings.\nThe single option which I wanted to tune was if we should use Shuffle Service.\nShuffle Service is a serverless tool that facilitates data shuffling around the cluster, thus relieving worker nodes from this task.\nAlso, node preemption is not so painful because Shuffle Service stores data in external storage independent of worker nodes.\nBut it comes at a price.</p>\n\n<p>Cost breakdown of processing 3% input dataset using virtual machine t2d-standard-8 with SSD disk is presented below<sup id=\"fnref:3:1\" role=\"doc-noteref\"><a href=\"#fn:3\" class=\"footnote\" rel=\"footnote\">3</a></sup>:</p>\n\n<ul>\n  <li>Cost of CPU: $2.47</li>\n  <li>Cost of memory: $0.70</li>\n  <li>Cost of SSD disk: $0.16</li>\n  <li>Cost of shuffle service: $2.32</li>\n  <li>Overall cost: $5.64</li>\n</ul>\n\n<p>Thus, we see that the cost of the shuffle service plays an important role - it’s more than 40% of the overall cost. Let’s do an experiment and turn Shuffle Service off.</p>\n\n<ul>\n  <li>n2-standard-4 + HDD: $9.48 (original configuration)</li>\n  <li>t2d-standard-8 + SSD: $5.64 (~ 41% less than original configuration)</li>\n  <li>t2d-standard-8 + SSD + no Shuffle Service: $3.95 (~ 58% less than original configuration)</li>\n</ul>\n\n<p>By turning off Shuffle Service we achieved a much lower cost.\nAs a bonus, our memory utilization increased to almost 100%, because we use worker nodes to perform a shuffle.\nSo we eliminated an underutilized T2D issue connected with a CPU to memory ratio.\nNode preemption is not a problem since we’re not utilizing preemptible VMs.</p>\n\n<p>I must also add that turning off external shuffle service may not always result in lower cost.\nIt depends on many factors, and you should test it on your own data pipeline.\nAlso, you need to take into consideration that the job will usually require more resources (CPU, memory) once you turn off external shuffle service.</p>\n\n<p>This way we decreased the estimated processing cost from $127,000 by $73,660 per year to $53,340 (by 58%)<sup id=\"fnref:1:7\" role=\"doc-noteref\"><a href=\"#fn:1\" class=\"footnote\" rel=\"footnote\">1</a></sup>.\nSo it’s now less than half of the initial cost<sup id=\"fnref:1:8\" role=\"doc-noteref\"><a href=\"#fn:1\" class=\"footnote\" rel=\"footnote\">1</a></sup>.</p>\n\n<table>\n  <tr>\n    <th>Hypothesis</th>\n    <th>Savings<span><sup id=\"fnref:1:9\" role=\"doc-noteref\"><a href=\"#fn:1\" class=\"footnote\" rel=\"footnote\">1</a></sup></span></th>\n  </tr>\n  <tr>\n    <td>[1] Physical resources are underutilized</td>\n    <td>$12,700</td>\n  </tr>\n  <tr>\n    <td>[2] Moving to a more cost-effective VM type</td>\n    <td>$27,940</td>\n  </tr>\n  <tr>\n    <td>[3] Changing VM disk type to SSD</td>\n    <td>$11,430</td>\n  </tr>\n  <tr>\n    <td>[4] Turning off Shuffle Service</td>\n    <td>$21,590</td>\n  </tr>\n</table>\n\n<p>Total: $73,660 of estimated savings<sup id=\"fnref:1:10\" role=\"doc-noteref\"><a href=\"#fn:1\" class=\"footnote\" rel=\"footnote\">1</a></sup></p>\n\n<p>Note: Why did we not use Dataflow <a href=\"https://cloud.google.com/dataflow/docs/guides/flexrs\">FlexRS</a> which could lower the processing price by combining preemptible and regular VMs?</p>\n\n<p>We did not test it due to how scheduling in FlexRS works.\nWhen you schedule a Dataflow FlexRS job you do not know the exact start time,\nthe only one promise from FlexRS is that the job will start within 6 hours (<a href=\"https://cloud.google.com/dataflow/docs/guides/flexrs\">documentation notes from Google Cloud website on that</a>).\nOur data pipeline must start at specified time and having a 6 hour delay is not acceptable.</p>\n\n<h2 id=\"final-test-on-a-full-dataset\">Final test on a full dataset</h2>\n\n<p>My last task was to test findings from subsampled input dataset (3%) tests on the full dataset (without subsampling).\nHere are the costs of processing a full dataset for a single day:</p>\n\n<table>\n  <tr>\n    <th>Configuration</th>\n    <th>Processing cost for one day on a full dataset</th>\n  </tr>\n  <tr>\n    <td>n2-standard-4 + HDD</td>\n    <td>$350.02</td>\n  </tr>\n  <tr>\n    <td>t2d-standard-8 + SSD + shuffle service turned off</td>\n    <td>$134.14 (~ 62% less than original price)</td>\n  </tr>\n</table>\n\n<p>As we see, the predicted gain from subsampling was achieved, and savings are even 3 pp higher than estimated.\nFor reference: we estimated, based on runs with 3% of input size, that we will achieve a roughly 58% cost reduction.</p>\n\n<ul>\n  <li>Initial annual cost: $127,000</li>\n  <li>Estimated annual cost after optimization: $48,260</li>\n  <li>Total estimated annual savings: $78,740</li>\n</ul>\n\n<p>Presented figures are only estimates based on a single run and extrapolated to the whole year.\nTo know the exact savings we will need to run the processing pipeline over a year, which hasn’t been done yet.</p>\n\n<h2 id=\"summary\">Summary</h2>\n\n<p>We achieved excellent outcome without even touching the processing code.\nSpeculative approach provided good results.\nThere may still be some space for optimization, but within the timeframe I was given, I treat these results as first-rate and do not find any more reasons to further\noptimize the environment and configuration of the Dataflow job.</p>\n\n<p>Also, specified strategies do not have to lead to cost optimizations in other pipelines.\nAs every data pipeline is different, some changes which brought cost reduction in this example may result in increased processing cost in different data pipelines.\nWhat is most important in this article: how to approach cost optimization of a data pipeline, not which type of resources to choose.</p>\n\n<div class=\"footnotes\" role=\"doc-endnotes\">\n  <ol>\n    <li id=\"fn:1\" role=\"doc-endnote\">\n      <p>Presented figures are only estimates based on a single run (with only 3% of input data) and extrapolated to the whole year with the assumption that processing the whole dataset will result in the same relative savings as processing 3% of source data. <a href=\"#fnref:1\" class=\"reversefootnote\" role=\"doc-backlink\">&#8617;</a> <a href=\"#fnref:1:1\" class=\"reversefootnote\" role=\"doc-backlink\">&#8617;<sup>2</sup></a> <a href=\"#fnref:1:2\" class=\"reversefootnote\" role=\"doc-backlink\">&#8617;<sup>3</sup></a> <a href=\"#fnref:1:3\" class=\"reversefootnote\" role=\"doc-backlink\">&#8617;<sup>4</sup></a> <a href=\"#fnref:1:4\" class=\"reversefootnote\" role=\"doc-backlink\">&#8617;<sup>5</sup></a> <a href=\"#fnref:1:5\" class=\"reversefootnote\" role=\"doc-backlink\">&#8617;<sup>6</sup></a> <a href=\"#fnref:1:6\" class=\"reversefootnote\" role=\"doc-backlink\">&#8617;<sup>7</sup></a> <a href=\"#fnref:1:7\" class=\"reversefootnote\" role=\"doc-backlink\">&#8617;<sup>8</sup></a> <a href=\"#fnref:1:8\" class=\"reversefootnote\" role=\"doc-backlink\">&#8617;<sup>9</sup></a> <a href=\"#fnref:1:9\" class=\"reversefootnote\" role=\"doc-backlink\">&#8617;<sup>10</sup></a> <a href=\"#fnref:1:10\" class=\"reversefootnote\" role=\"doc-backlink\">&#8617;<sup>11</sup></a></p>\n    </li>\n    <li id=\"fn:2\" role=\"doc-endnote\">\n      <p>CoreMark results from <a href=\"https://cloud.google.com/compute/docs/benchmarks-linux\">CoreMark scores provided by Google Cloud itself</a>, retrieved on 04/05/2024. <a href=\"#fnref:2\" class=\"reversefootnote\" role=\"doc-backlink\">&#8617;</a></p>\n    </li>\n    <li id=\"fn:3\" role=\"doc-endnote\">\n      <p>Official prices taken from Google Cloud site, VM instance pricing in region europe-west1, retrieved on 04/05/2024. <a href=\"#fnref:3\" class=\"reversefootnote\" role=\"doc-backlink\">&#8617;</a> <a href=\"#fnref:3:1\" class=\"reversefootnote\" role=\"doc-backlink\">&#8617;<sup>2</sup></a></p>\n    </li>\n  </ol>\n</div>\n","contentSnippet":"In this article we’ll present methods for efficiently optimizing physical resources and fine-tuning the configuration of a Google Cloud Platform (GCP)\nDataflow pipeline in order to achieve cost reductions.\nOptimization will be presented as a real-life scenario, which will be performed in stages.\nBefore we start, it’s time to introduce several avenues through which the cost of Big Data pipelines can be significantly reduced.\nThese include:\nCareful optimization of consumed physical resources, like choosing VM types with optimal CPU to memory ratio and a cost-effective CPU type.\nEnhancing the configuration of the data processing engine to maximize its efficiency.\nOptimizing input and output datasets. Not all data may need processing or perhaps, altering their structure could reduce the processing time.\nRefining storage strategies for input and output datasets. This is particularly beneficial if reading or writing speeds are suboptimal and demand improvements.\nStreamlining of our pipeline code and utilizing built-in optimization functionalities (for example broadcast joins and repartitioning in Apache Spark).\nThroughout this article we will focus solely on optimizing consumed physical resources (1st point) and enhancing configuration of the data processing engine (2nd point).\nAbout the data pipeline being optimized\nThe data pipeline which will serve us as an example throughout this article is written in Apache Beam using Python SDK.\nThe pipeline runs on Google Cloud Dataflow processing engine.\nThe goal of the pipeline is to join a couple of tables (most of them are a terabyte+ in size), apply some transformations and produce a unified output table.\nOverall processing cost of the full dataset is around $350 per day.\nIt results in roughly $10,500 per month, and $127,000 per year.\nApproach to cost optimization\nAt the beginning of the cost optimization let’s draft a couple of hypotheses:\nPhysical resources are underutilized.\nPhysical resources have not the best price-to-performance ratio.\nConfiguration of the Dataflow job is suboptimal and could be optimized.\nMy goal will be to check those hypotheses.\nDuring the testing phase I’ll use a 3% subsample of input datasets. As a result I will be running tests with input size at ~100 GB level.\nThus, I’ll limit the cost of tests and significantly reduce their time. Final tests will be made on the full dataset, not on a limited subsample.\nIn order to save time and resources I’ve made some speculative choices regarding what I should test during optimization.\nIn addition, I’ve decided not to test all the possible combinations of machine families, disk types and configuration options to save time.\nI will try to stick with the most promising choices and omit testing unpromising configurations.\nHypothesis testing: physical resources are underutilized\nIn our initial configuration we used the following type of worker machines:\nMachine type: n2-standard-4 (4 vCPU, 16 GB of memory)\nDisk size: 100 GB\nDisk type: HDD\nMax. worker nodes: 500\nAutoscaling algorithm: throughput based\nI made a decision to focus on CPU and memory utilization first.\nCPU utilization\nI checked if CPU utilization was on an acceptable level, and it was.\nThe following diagram from Dataflow UI presents CPU utilization on All Workers in terms of the CPU utilization\nfor all cores on a single App Engine flexible instance.\nSo it gives us an idea of how the CPU is utilized on each virtual machine.\n\nWe could also take a look at the same data presented in terms of statistical metrics.\n\nFrom the given graph I could see that mean utilization of the CPU was around 85%, which is a good score.\nThe result is affected by two shuffle stages, when we need to send data around the cluster (usually network is a small bottleneck here).\nCPU tends to be idle while shuffling data using Dataflow Shuffle Service.\nSo CPU resources are not underutilized. We use almost all of what we pay for.\nMemory utilization\nIn the end I checked memory usage. I saw that we did not use all the memory which we were paying for.\nLet’s take a look at the following two graphs.\nThe first one shows maximal memory utilization among all the workers.\n\nThe second one shows memory utilization statistics among all the worker nodes.\n\nThe first one presents average memory usage on a worker node, the second one presents overall memory usage among the whole cluster.\nWe clearly see that we only use around 50% of the memory. Bingo, we pay for memory that we do not use.\nImproving memory utilization\nUsually there are two ways of improving memory utilization:\nChange CPU to memory ratio on worker nodes.\nDecrease the amount of worker nodes.\nI’ve decided to change the CPU to memory ratio rather than decrease the number of worker nodes.\nI did not want to compromise on scalability and time needed to perform a job.\nTest on a 3% subsample of input data has given the following cost of data processing:\nn2-standard-4: $9.48\nn2-highcpu-8: $8.52 (~ 10% less than original price)\nn2d-highcpu-8: $8.57 (~ 10% less than original price)\nWe saved 10% on adjusting CPU and memory ratio.\nIt results in around $12,700 of estimated savings per year (10% of $127,000 annual cost).\nHypothesis\n    Savings1\n  \n[1] Physical resources are underutilized\n    $12,700\n  \nHypothesis testing: physical resources has not the best price-to-performance ratio\nI assumed that the current virtual machine type (n2-standard-4) has not the best price-to-performance ratio.\nTo check performance of different virtual machine types I used CoreMark scores provided by Google Cloud itself.\nBased on CoreMark scores and official Google Cloud VM pricing, I prepared a table which would help me choose the VM type with the best price-to-performance ratio.\nThe most important column is “price per 1 mln points” — how much I need to pay on average to score 1 mln points.\nI used official VM instance prices from Google Cloud site from region europe-west1.\nVirtual Machine Type\n    Points in ScoreMark2\n    Price per hour3\n    Price per 1 mln points\n  \nn2-standard-4\n    66 833 pts\n    $0.21\n    $3.20\n  \nn2-standard-8\n    138 657 pts\n    $0.43\n    $3.08\n  \nn2d-standard-8\n    164 539 pts\n    $0.37\n    $2.26\n  \ne2-standard-8\n    103 808 pts\n    $0.29\n    $2.84\n  \nt2d-standard-8\n    237 411 pts\n    $0.37\n    $1.57\n  \nAs we see, another hypothesis proved to be true. We’re not using the virtual machine type with the best price-to-performance ratio - T2D.\nWe’re using N2 machine type.\nUnfortunately, at the time of writing, T2D machines do not provide CPU to memory ratios other than 3 GB per 1 vCPU.\nIt’s still better than 4 GB per 1 vCPU, but far from 1 or 2 GB per 1 vCPU.\nWe will check if T2D virtual machine type with 4 GB of memory per 1 CPU is cheaper than its counterparts.\nMoving to a virtual machine type with better price-to-performance ratio\nI performed several tests on a small scale (3% subsample of input data) with T2D machine types. Let’s take a look at them.\nn2-standard-4 + HDD: $9.48\nn2-highcpu-8 + HDD: $8.52 (~ 10% less than original price)\nn2d-highcpu-8 + HDD: $8.57 (~ 10% less than original price)\nt2d-standard-8 + HDD: $6.65 (~ 32% less than original price)\nThis way we decreased the estimated processing cost from $127,000 by $40,640 per year to $86,360 (by 32%)1.\nUnfortunately, we also introduced some possible underutilized resources (memory) by changing CPU to memory ratio.\nHypothesis\n    Savings1\n  \n[1] Physical resources are underutilized\n    $12,700\n  \n[2] Moving to a more cost-effective VM type\n    $27,940\n  \nTotal: $40,640 of estimated savings1\nComing back to optimization of virtual machine storage type\nAs I found the most suitable virtual machine type, I was able to focus on choosing between SSD and HDD disk types.\nAs we all know, HDDs are much slower than SSDs, especially in terms of random read/write.\nFor processes where we do not heavily use storage I/O operations there’s no need to move to more expensive SSDs.\nI decided to check if we should use cheaper and slower HDDs or more expensive and faster SSDs.\nI run the pipeline (3% of input data size) with HDD and SSD disks.\nHere are the results for different VM families:\nn2-standard-4 + HDD: $9.48\nn2-highcpu-8 + HDD: $8.52 (~ 10% less than original price)\nn2d-highcpu-8 + HDD: $8.57 (~ 10% less than original price)\nt2d-standard-8 + HDD: $6.65 (~ 32% less than original price)\nt2d-standard-8 + SSD: $5.64 (~ 41% less than original price)\nThis way we decreased the estimated processing cost from $127,000 by $52,070 per year to $74,930 (by 41%)1.\nHypothesis\n    Savings1\n  \n[1] Physical resources are underutilized\n    $12,700\n  \n[2] Moving to a more cost-effective VM type\n    $27,940\n  \n[3] Changing VM disk type to SSD\n    $11,430\n  \nTotal: $52,070 of estimated savings1\nHypothesis testing: configuration of the Dataflow job is not optimal\nDataflow, in comparison to Apache Spark, leaves us with almost no configuration options to be changed.\nIt’s good because in Dataflow you get very decent out-of-the-box settings.\nThe single option which I wanted to tune was if we should use Shuffle Service.\nShuffle Service is a serverless tool that facilitates data shuffling around the cluster, thus relieving worker nodes from this task.\nAlso, node preemption is not so painful because Shuffle Service stores data in external storage independent of worker nodes.\nBut it comes at a price.\nCost breakdown of processing 3% input dataset using virtual machine t2d-standard-8 with SSD disk is presented below3:\nCost of CPU: $2.47\nCost of memory: $0.70\nCost of SSD disk: $0.16\nCost of shuffle service: $2.32\nOverall cost: $5.64\nThus, we see that the cost of the shuffle service plays an important role - it’s more than 40% of the overall cost. Let’s do an experiment and turn Shuffle Service off.\nn2-standard-4 + HDD: $9.48 (original configuration)\nt2d-standard-8 + SSD: $5.64 (~ 41% less than original configuration)\nt2d-standard-8 + SSD + no Shuffle Service: $3.95 (~ 58% less than original configuration)\nBy turning off Shuffle Service we achieved a much lower cost.\nAs a bonus, our memory utilization increased to almost 100%, because we use worker nodes to perform a shuffle.\nSo we eliminated an underutilized T2D issue connected with a CPU to memory ratio.\nNode preemption is not a problem since we’re not utilizing preemptible VMs.\nI must also add that turning off external shuffle service may not always result in lower cost.\nIt depends on many factors, and you should test it on your own data pipeline.\nAlso, you need to take into consideration that the job will usually require more resources (CPU, memory) once you turn off external shuffle service.\nThis way we decreased the estimated processing cost from $127,000 by $73,660 per year to $53,340 (by 58%)1.\nSo it’s now less than half of the initial cost1.\nHypothesis\n    Savings1\n  \n[1] Physical resources are underutilized\n    $12,700\n  \n[2] Moving to a more cost-effective VM type\n    $27,940\n  \n[3] Changing VM disk type to SSD\n    $11,430\n  \n[4] Turning off Shuffle Service\n    $21,590\n  \nTotal: $73,660 of estimated savings1\nNote: Why did we not use Dataflow FlexRS which could lower the processing price by combining preemptible and regular VMs?\nWe did not test it due to how scheduling in FlexRS works.\nWhen you schedule a Dataflow FlexRS job you do not know the exact start time,\nthe only one promise from FlexRS is that the job will start within 6 hours (documentation notes from Google Cloud website on that).\nOur data pipeline must start at specified time and having a 6 hour delay is not acceptable.\nFinal test on a full dataset\nMy last task was to test findings from subsampled input dataset (3%) tests on the full dataset (without subsampling).\nHere are the costs of processing a full dataset for a single day:\nConfiguration\n    Processing cost for one day on a full dataset\n  \nn2-standard-4 + HDD\n    $350.02\n  \nt2d-standard-8 + SSD + shuffle service turned off\n    $134.14 (~ 62% less than original price)\n  \nAs we see, the predicted gain from subsampling was achieved, and savings are even 3 pp higher than estimated.\nFor reference: we estimated, based on runs with 3% of input size, that we will achieve a roughly 58% cost reduction.\nInitial annual cost: $127,000\nEstimated annual cost after optimization: $48,260\nTotal estimated annual savings: $78,740\nPresented figures are only estimates based on a single run and extrapolated to the whole year.\nTo know the exact savings we will need to run the processing pipeline over a year, which hasn’t been done yet.\nSummary\nWe achieved excellent outcome without even touching the processing code.\nSpeculative approach provided good results.\nThere may still be some space for optimization, but within the timeframe I was given, I treat these results as first-rate and do not find any more reasons to further\noptimize the environment and configuration of the Dataflow job.\nAlso, specified strategies do not have to lead to cost optimizations in other pipelines.\nAs every data pipeline is different, some changes which brought cost reduction in this example may result in increased processing cost in different data pipelines.\nWhat is most important in this article: how to approach cost optimization of a data pipeline, not which type of resources to choose.\nPresented figures are only estimates based on a single run (with only 3% of input data) and extrapolated to the whole year with the assumption that processing the whole dataset will result in the same relative savings as processing 3% of source data. ↩ ↩2 ↩3 ↩4 ↩5 ↩6 ↩7 ↩8 ↩9 ↩10 ↩11\nCoreMark results from CoreMark scores provided by Google Cloud itself, retrieved on 04/05/2024. ↩\nOfficial prices taken from Google Cloud site, VM instance pricing in region europe-west1, retrieved on 04/05/2024. ↩ ↩2","guid":"https://blog.allegro.tech/2024/06/cost-optimization-data-pipeline-gcp.html","categories":["tech","big data"],"isoDate":"2024-06-19T22:00:00.000Z"},{"title":"Engineering culture of Allegro & Allegro Pay: Pragmatic Engineer Score","link":"https://blog.allegro.tech/2024/06/pragmatic-engineer-score.html","pubDate":"Tue, 11 Jun 2024 00:00:00 +0200","authors":{"author":[{"name":["Jakub Dropia"],"photo":["https://blog.allegro.tech/img/authors/jakub.dropia.jpg"],"url":["https://blog.allegro.tech/authors/jakub.dropia"]}]},"content":"<p>One tech blog/newsletter gained traction and popularity for a couple of years now: <a href=\"https://blog.pragmaticengineer.com/\">Pragmatic Engineer</a>.</p>\n\n<p>Quoting author:</p>\n\n<p><em>The #1 technology newsletter on Substack. Highly relevant for software engineers and engineering managers, useful for those working in tech.\nWritten by engineering manager and software engineer Gergely Orosz who was previously at Uber, Skype/Microsoft, and at startups.</em></p>\n\n<p>In practice, you will find a huge amount of information and internal insights on how big tech works in many companies.\nThere are many deep dives into engineering culture, best practices, and what goes on behind the scenes.</p>\n\n<p>There is one particular entry in the blog that I would like to share and talk about:</p>\n\n<p><a href=\"https://blog.pragmaticengineer.com/pragmatic-engineer-test/\">The Pragmatic Engineer Test</a></p>\n\n<p>What is it?</p>\n\n<p>It is a checklist of 12 questions, and answering them can “measure” the company’s engineering maturity.</p>\n\n<p>Working in Allegro Pay for four years, I saw a lot of these practices over the years. Hell, I had the opportunity to build some of them, which\nis a valuable thing here. Everyone is open-minded and you can influence your workplace.</p>\n\n<p>But when I came upon this article - it was natural to try to evaluate my current workplace against it.</p>\n\n<p>I did it, and I would like to share the results with you without further ado.</p>\n\n<h1 id=\"disclaimer\">Disclaimer</h1>\n\n<p>I work at Allegro Pay, a company of Allegro Group responsible for Allegro Pay, Care, and Cash products.\nWhat I write further is heavily grounded in the Allegro Pay context, as we have different tech stacks, environments, and technical platforms.\nHowever, all practices are present both at Allegro and at Allegro Pay. The execution may differ, but engineering maturity is very similar in the end.</p>\n\n<h1 id=\"tldr\">TL;DR</h1>\n\n<p>In short - Allegro &amp; Allegro Pay scored 11 points out of 12.</p>\n\n<p>If you want to stop here - the takeaway is:</p>\n\n<p><em>this is a great place for software engineers</em></p>\n\n<p>We have JAVA, .NET, cloud, our own data centers, a mobile-first approach and modern web, a good microservices ecosystem,\na great internal developer platform (or even two!), data engineering and ML, and a product that makes money.</p>\n\n<p>Would you like to hear nice, sweet, and bitter details?</p>\n\n<p>Continue reading 🙂</p>\n\n<p><a href=\"https://blog.pragmaticengineer.com/pragmatic-engineer-test/\">12 Questions</a> and my answers to them.</p>\n\n<h1 id=\"equity-or-profit-sharing\">Equity or profit sharing</h1>\n\n<p>Half Yes. Not all engineers.</p>\n\n<p>Allegro Group is a <a href=\"https://www.gpw.pl/company-factsheet?isin=LU2237380790\">public trading company</a> in Poland. Our engineers can gain stocks as a part of their total compensation package. How does this work?</p>\n\n<p>Well, each senior level and above engineer gains a stocks package yearly as a part of the end-year review. The package is vested over 3 years with (25%, 25% and 50%) proportions.\nVested parts of each package are transferred to your broker account each year and can overlap. The final amount depends on company and individual results.\nIn Poland, these stocks are 19% taxed (if you decide to sell them).</p>\n\n<p>In addition, all employees receive a yearly bonus, which, of course, also depends on the company and individual results.</p>\n\n<p>Both are a significant addition to our overall compensation package.</p>\n\n<p>Caveats?</p>\n\n<p>Stocks are still not part of the offer for newcomers, which I think could contribute to attracting more great engineers.</p>\n\n<h1 id=\"roadmapbacklog-that-engineers-contribute-to\">Roadmap/backlog that engineers contribute to</h1>\n\n<p>Yes.</p>\n\n<p>Each team usually has its backlog. The product manager assigned to that team, the engineering manager, and the team itself are responsible for building\nand maintaining this backlog around functionalities and domains that they own. The backlog is a mix of business features, some maintenance, and technical stories.\nHow it is built and tracked, if teams work in Scrum, Kanban, or some custom approach - is primarily up to the team. In the end, we have some processes that try\nto gather “bigger” deliverables and compose a roadmap and plans for the whole organization at the same root.</p>\n\n<p>It works great and allows teams huge flexibility and freedom in their work. As a trade-off, extra work is needed to map these backlogs into\nthe organizational level processes - which, usually, are in Google Sheets or a custom tool.</p>\n\n<h1 id=\"engineers-directly-working-with-other-ics-individual-contributors\">Engineers directly working with other ICs (Individual Contributors)</h1>\n\n<p>Yes.</p>\n\n<p>We collaborate with each other, regardless of role and career level. Even if other ICs are in different teams, the expectation is to communicate with them directly.\nYou can just write to anyone, and can expect to get an answer. There are some protections to prevent this from turning into complete chaos, like quarterly\nplanning of dependencies between teams, help channels, and so on, but if everyone works on the same page, we are just working together without unnecessary barriers.</p>\n\n<h1 id=\"code-reviews-and-testing\">Code reviews and testing</h1>\n\n<p>Yes.</p>\n\n<p>We have a test platform for automatic E2E tests. Manual testers are available for complex functionalities spanning multiple services.\nTo protect quality, we have code review policies for each repository. In CI/CD, the advanced build system protects us and validates many things\n(unit/integration tests, outdated / beta packages, code formats, etc.) before they go to the main branch.</p>\n\n<p>All of that is part of everyday workflow. Sometimes, it slows you down, but it is done smartly and, most of the time, helps. As always, everything is under your control, and in the end, it is your responsibility to use these tools properly.</p>\n\n<h1 id=\"ci-and-engineers-pushing-to-prod\">CI and engineers pushing to prod</h1>\n\n<p>Yes.</p>\n\n<p>At Allegro Pay, every commit on the main branch triggers a pipeline that goes through the entire CI/CD process, is automatically deployed to the DEV and TEST environment,\nand stops with manual approval before releasing to PROD. Approval needs the acceptance of another engineer than the one who changes the triggered pipeline.\nEach team is responsible for its changes and deployments. We build it, we run it, and we own it.</p>\n\n<p>Of course, that can also vary. Sometimes, additional security measurements need to be applied depending on the context and product.\nBut in the end - we have continuous delivery with dozens of deployments daily.</p>\n\n<h1 id=\"internal-open-source\">Internal open source</h1>\n\n<p>Yes.</p>\n\n<p>Each developer is welcome to issue a PR in components that do not belong to him or his team. We have common internal libraries which are developed and maintained across teams.\nOn the other hand, each repository has only one owner. It works well; people are open-minded and will always consider your contribution.</p>\n\n<p>In practice, this doesn’t happen that often. Most of the work is focused on components that your team owns, and sometimes differences between “services”\n(different technologies, architecture, etc.), and lack of proper documentation are barriers to quick contribution - because you need to understand the service\nand domain first before you will be able to change something that you don’t own.</p>\n\n<p>Additionally, we have a <a href=\"https://github.com/allegro\">catalog</a> of external open-sourced repositories. You can find many great tools and libraries, some of which you may can even know, like\n<a href=\"https://github.com/allegro/bigcache\">bigcache</a>, <a href=\"https://github.com/allegro/hermes\">hermes</a> or <a href=\"https://github.com/allegro/ralph\">ralph</a>. For Allegro Pay itself we also do have <a href=\"https://github.com/topics/allegropay\">some</a>.</p>\n\n<p>What is truly unique and I think fits into this position, is internal tourism. Anyone can request to join any team, and as a regular member work up to a couple of months (usually a quarter), contributing to other teams’ work.</p>\n\n<h1 id=\"healthy-on-call-as-a-priority\">Healthy on-call as a priority.</h1>\n\n<p>Yes.</p>\n\n<p>We do have on-call duty. This is a part of “we own it”.</p>\n\n<p>How this is implemented may vary depending on the area or teams, but in the end, there are some streams of on-duty calls where people\nperform 24-hour on-duty shifts cyclically. These duties are extra paid (for being “ready”). If something happens during duty - your intervention outside working hours is\npaid according to the Polish overtime hours policy (150% or 200% hour rate depends on when this occurs), or you can exchange them for vacation at another time.</p>\n\n<p>We have generic alerts, but each stream also has specific rules. There is a common practice where teams improve and change them to remove noise, false positives,\nor simplify on-duty shifts. In the end - SLA must be met - and how teams will approach this - is up to them.</p>\n\n<h1 id=\"technical-managers\">Technical managers.</h1>\n\n<p>Yes.</p>\n\n<p>Most of our engineering managers have a background in software engineering. They were seniors once and were promoted to manager, taking a step aside from pure IC.\nEven if hiring from outside, they must complete all the technical workshops. It is expected that they will still be experts in the field.</p>\n\n<p>They are deeply rooted in technology. They perform system designs, code reviews, consultancy, and sometimes coding. Proportion varies depending on the team and\nthe manager themselves. Besides people management, they are expected to have ownership of technical decisions and project management of the part which the team is responsible for.</p>\n\n<h1 id=\"career-ladder-when-above-10-engineers--parallel-ic-and-manager-tracks-when-above-30-engineers\">Career ladder (when above 10 engineers) &amp; Parallel IC and manager tracks (when above 30 engineers).</h1>\n\n<p>Yes &amp; half yes</p>\n\n<p>We have a career level for Software Engineer Job Family, which starts from a junior position, goes through mid to senior level, and then splits into two tracks - Individual Contributor and Manager.\nThis split is fairly fresh, as there was only a Manager track before. Because of that, this one is pretty mature, with career progression starting from\nEngineering Manager, going through Senior Engineering Manager, Director, VP or CTO.</p>\n\n<p>If we are talking about the IC path - here we have right now the Principal Software Engineer, whose scope of the work is at least an area or even the whole organization,\nand the Senior Principal Software Engineer is one person for the whole organization.</p>\n\n<p>As you can see, ladders are missing in the IC track; from what I know, this is still in progress. The organization is trying to figure out what IC ladder fits its needs.</p>\n\n<p>There are few opportunities for Individual Contributors above the Senior level. This can be improved, and it will likely be.</p>\n\n<h1 id=\"feedback-culture\">Feedback culture.</h1>\n\n<p>Yes.</p>\n\n<p>I think it is everywhere.</p>\n\n<p>We have continuous feedback - 360, peer-to-peer, promotion, employee engagement surveys and during each half-year performance review. At each significant meeting, a space for Q&amp;A.\nFeedback is deeply rooted in our daily work. You can see polls, surveys, requests for feedback and opinions, post-mortems, and so on everywhere.\nIt is hard to imagine what else we could do to cover this topic, one of our culture’s strongest traits.</p>\n\n<h1 id=\"investing-in-professional-growth\">Investing in professional growth.</h1>\n\n<p>Yes.</p>\n\n<p>This is realized in multiple ways. Each team/individual has a “training budget” - this is money you can spend on external training, courses, and conferences.\nIt differs from team to team, and used to be much better in past.\nAdditionally, we have an internal learning platform with many great workshops - especially in the soft skills area. They are great! You can upskill yourself well.</p>\n\n<p>Also, in some areas and teams, there is a time dedicated to your self-development. You can spend it on contributions to open-source, reading a book,\nlearning from the course, or, for example, writing a PoC of new technology with your team. In Allegro Pay - it is 10%. How you spend it - is up to you,\nor the team, it just should stick to our profession.</p>\n\n<p>There are many internal and external communities (guilds), each with its own meeting calendar and interesting presentations and workshops taking a different kind of forms.\nThere are also many internal events, hackathons, and initiatives. Opportunities to learn are almost infinite.</p>\n\n<p>Landing here was my biggest personal and professional progression so far.</p>\n\n<h1 id=\"the-bitter-or-not\">The bitter (or not?)</h1>\n\n<p>Sounds sweet, right? Where is the bitter here? Well, I am not sure.</p>\n\n<p>This is a rapid-growth product and company. We are focused on delivering value to clients and maximizing profit from our products.\nEverything we do must contribute to overall success, and there is little space to “breathe”. You must often balance delivering functionalities,\npaying back technical debt, and growing scale. Taking shortcuts. Making trade-offs. Asking difficult questions. Our roadmaps often change\nbecause of the economics, law, or maybe data we gathered and told us that our actions do not convert in the way we assumed.\nIn Allegro Pay itself - the financial domain also does not help — a huge amount of our work is dedicated to legal matters. New laws pop up, and we must follow them.</p>\n\n<p>I can imagine that it can’t be for everyone.</p>\n\n<p>But for me, this introduces an entirely new layer of engineering, where you need to be smart, cautious, value impact, and make the right choices.</p>\n\n<p>We strive to be the best in the market, which is why we succeed.</p>\n\n<p>Another thing can be the corporation itself. But this is very likely something that you will not notice until you become a manager.</p>\n\n<p>Allegro is a big company that has shifted to a more centralized and structured approach over the years. Everything needs to be aligned with the process.\nTo picture this, here are a few examples:</p>\n\n<ul>\n  <li>\n    <p>Instead of ordering any accessories required within the budget - the budget was removed, and you can order only specific, pre-selected accessories</p>\n  </li>\n  <li>\n    <p>Want to hire someone? There is budgeting once per year, and you need to come prepared to justify another full-time equivalent.</p>\n  </li>\n  <li>\n    <p>Do you want to give someone a raise? Well, you don’t have to worry about this. Process, one per year, will do that for you.\nYou need to provide a performance review of your directs. Based on that you will get the budget, recommendations, and ability to slightly change proportions.</p>\n  </li>\n  <li>\n    <p>Want to pursue external training? You have a budget. It would be best if you fit it in. You need to raise a request and process it through several layers of acceptance.</p>\n  </li>\n</ul>\n\n<p>As you can imagine, all of that can take time and be annoying. It is very frequent that your “request” is stuck somewhere, and you need to “push” it.\nBut on the other end of the process, there are helpful people whom you can always talk to.</p>\n\n<p>Sometimes, this leads to funny absurdities - you find an old monitor in the office that is not assigned to anyone (or a person who is not already in the company),\nand you would like to order a docking station for it. “Procedures” will not allow you to do that. The dock must have existed before; if lost,\nonly the owner can “order” a new one with a good justification. But you are not the owner. It is no man’s land - thus - no dock for it ;)</p>\n\n<p>But I think most big corporations work like that. The past few years were also difficult for the industry. I understand why this is happening.\nIf you are an individual contributor, most of these things will not affect you. And those which do - you need to get used to it, and if you focus on the rest - hell - this is a great place to work.</p>\n\n<h1 id=\"is-there-more\">Is there more?</h1>\n\n<p>A score of 11 tells that you will find much good stuff in software engineering here.</p>\n\n<p>But this is not all. There are plenty of other great features of engineering culture at Allegro &amp; Allegro Pay. You have great products, a big scale and\na data-driven approach which leads to many challenges; amazing, intelligent people; modern technology and approach to software engineering;\nrich off-topic communities (board games, sports, FIFA league, etc.), and many more.</p>\n\n<p>Overall, #DobrzeTuByć (#GoodToBeHere)</p>\n","contentSnippet":"One tech blog/newsletter gained traction and popularity for a couple of years now: Pragmatic Engineer.\nQuoting author:\nThe #1 technology newsletter on Substack. Highly relevant for software engineers and engineering managers, useful for those working in tech.\nWritten by engineering manager and software engineer Gergely Orosz who was previously at Uber, Skype/Microsoft, and at startups.\nIn practice, you will find a huge amount of information and internal insights on how big tech works in many companies.\nThere are many deep dives into engineering culture, best practices, and what goes on behind the scenes.\nThere is one particular entry in the blog that I would like to share and talk about:\nThe Pragmatic Engineer Test\nWhat is it?\nIt is a checklist of 12 questions, and answering them can “measure” the company’s engineering maturity.\nWorking in Allegro Pay for four years, I saw a lot of these practices over the years. Hell, I had the opportunity to build some of them, which\nis a valuable thing here. Everyone is open-minded and you can influence your workplace.\nBut when I came upon this article - it was natural to try to evaluate my current workplace against it.\nI did it, and I would like to share the results with you without further ado.\nDisclaimer\nI work at Allegro Pay, a company of Allegro Group responsible for Allegro Pay, Care, and Cash products.\nWhat I write further is heavily grounded in the Allegro Pay context, as we have different tech stacks, environments, and technical platforms.\nHowever, all practices are present both at Allegro and at Allegro Pay. The execution may differ, but engineering maturity is very similar in the end.\nTL;DR\nIn short - Allegro & Allegro Pay scored 11 points out of 12.\nIf you want to stop here - the takeaway is:\nthis is a great place for software engineers\nWe have JAVA, .NET, cloud, our own data centers, a mobile-first approach and modern web, a good microservices ecosystem,\na great internal developer platform (or even two!), data engineering and ML, and a product that makes money.\nWould you like to hear nice, sweet, and bitter details?\nContinue reading 🙂\n12 Questions and my answers to them.\nEquity or profit sharing\nHalf Yes. Not all engineers.\nAllegro Group is a public trading company in Poland. Our engineers can gain stocks as a part of their total compensation package. How does this work?\nWell, each senior level and above engineer gains a stocks package yearly as a part of the end-year review. The package is vested over 3 years with (25%, 25% and 50%) proportions.\nVested parts of each package are transferred to your broker account each year and can overlap. The final amount depends on company and individual results.\nIn Poland, these stocks are 19% taxed (if you decide to sell them).\nIn addition, all employees receive a yearly bonus, which, of course, also depends on the company and individual results.\nBoth are a significant addition to our overall compensation package.\nCaveats?\nStocks are still not part of the offer for newcomers, which I think could contribute to attracting more great engineers.\nRoadmap/backlog that engineers contribute to\nYes.\nEach team usually has its backlog. The product manager assigned to that team, the engineering manager, and the team itself are responsible for building\nand maintaining this backlog around functionalities and domains that they own. The backlog is a mix of business features, some maintenance, and technical stories.\nHow it is built and tracked, if teams work in Scrum, Kanban, or some custom approach - is primarily up to the team. In the end, we have some processes that try\nto gather “bigger” deliverables and compose a roadmap and plans for the whole organization at the same root.\nIt works great and allows teams huge flexibility and freedom in their work. As a trade-off, extra work is needed to map these backlogs into\nthe organizational level processes - which, usually, are in Google Sheets or a custom tool.\nEngineers directly working with other ICs (Individual Contributors)\nYes.\nWe collaborate with each other, regardless of role and career level. Even if other ICs are in different teams, the expectation is to communicate with them directly.\nYou can just write to anyone, and can expect to get an answer. There are some protections to prevent this from turning into complete chaos, like quarterly\nplanning of dependencies between teams, help channels, and so on, but if everyone works on the same page, we are just working together without unnecessary barriers.\nCode reviews and testing\nYes.\nWe have a test platform for automatic E2E tests. Manual testers are available for complex functionalities spanning multiple services.\nTo protect quality, we have code review policies for each repository. In CI/CD, the advanced build system protects us and validates many things\n(unit/integration tests, outdated / beta packages, code formats, etc.) before they go to the main branch.\nAll of that is part of everyday workflow. Sometimes, it slows you down, but it is done smartly and, most of the time, helps. As always, everything is under your control, and in the end, it is your responsibility to use these tools properly.\nCI and engineers pushing to prod\nYes.\nAt Allegro Pay, every commit on the main branch triggers a pipeline that goes through the entire CI/CD process, is automatically deployed to the DEV and TEST environment,\nand stops with manual approval before releasing to PROD. Approval needs the acceptance of another engineer than the one who changes the triggered pipeline.\nEach team is responsible for its changes and deployments. We build it, we run it, and we own it.\nOf course, that can also vary. Sometimes, additional security measurements need to be applied depending on the context and product.\nBut in the end - we have continuous delivery with dozens of deployments daily.\nInternal open source\nYes.\nEach developer is welcome to issue a PR in components that do not belong to him or his team. We have common internal libraries which are developed and maintained across teams.\nOn the other hand, each repository has only one owner. It works well; people are open-minded and will always consider your contribution.\nIn practice, this doesn’t happen that often. Most of the work is focused on components that your team owns, and sometimes differences between “services”\n(different technologies, architecture, etc.), and lack of proper documentation are barriers to quick contribution - because you need to understand the service\nand domain first before you will be able to change something that you don’t own.\nAdditionally, we have a catalog of external open-sourced repositories. You can find many great tools and libraries, some of which you may can even know, like\nbigcache, hermes or ralph. For Allegro Pay itself we also do have some.\nWhat is truly unique and I think fits into this position, is internal tourism. Anyone can request to join any team, and as a regular member work up to a couple of months (usually a quarter), contributing to other teams’ work.\nHealthy on-call as a priority.\nYes.\nWe do have on-call duty. This is a part of “we own it”.\nHow this is implemented may vary depending on the area or teams, but in the end, there are some streams of on-duty calls where people\nperform 24-hour on-duty shifts cyclically. These duties are extra paid (for being “ready”). If something happens during duty - your intervention outside working hours is\npaid according to the Polish overtime hours policy (150% or 200% hour rate depends on when this occurs), or you can exchange them for vacation at another time.\nWe have generic alerts, but each stream also has specific rules. There is a common practice where teams improve and change them to remove noise, false positives,\nor simplify on-duty shifts. In the end - SLA must be met - and how teams will approach this - is up to them.\nTechnical managers.\nYes.\nMost of our engineering managers have a background in software engineering. They were seniors once and were promoted to manager, taking a step aside from pure IC.\nEven if hiring from outside, they must complete all the technical workshops. It is expected that they will still be experts in the field.\nThey are deeply rooted in technology. They perform system designs, code reviews, consultancy, and sometimes coding. Proportion varies depending on the team and\nthe manager themselves. Besides people management, they are expected to have ownership of technical decisions and project management of the part which the team is responsible for.\nCareer ladder (when above 10 engineers) & Parallel IC and manager tracks (when above 30 engineers).\nYes & half yes\nWe have a career level for Software Engineer Job Family, which starts from a junior position, goes through mid to senior level, and then splits into two tracks - Individual Contributor and Manager.\nThis split is fairly fresh, as there was only a Manager track before. Because of that, this one is pretty mature, with career progression starting from\nEngineering Manager, going through Senior Engineering Manager, Director, VP or CTO.\nIf we are talking about the IC path - here we have right now the Principal Software Engineer, whose scope of the work is at least an area or even the whole organization,\nand the Senior Principal Software Engineer is one person for the whole organization.\nAs you can see, ladders are missing in the IC track; from what I know, this is still in progress. The organization is trying to figure out what IC ladder fits its needs.\nThere are few opportunities for Individual Contributors above the Senior level. This can be improved, and it will likely be.\nFeedback culture.\nYes.\nI think it is everywhere.\nWe have continuous feedback - 360, peer-to-peer, promotion, employee engagement surveys and during each half-year performance review. At each significant meeting, a space for Q&A.\nFeedback is deeply rooted in our daily work. You can see polls, surveys, requests for feedback and opinions, post-mortems, and so on everywhere.\nIt is hard to imagine what else we could do to cover this topic, one of our culture’s strongest traits.\nInvesting in professional growth.\nYes.\nThis is realized in multiple ways. Each team/individual has a “training budget” - this is money you can spend on external training, courses, and conferences.\nIt differs from team to team, and used to be much better in past.\nAdditionally, we have an internal learning platform with many great workshops - especially in the soft skills area. They are great! You can upskill yourself well.\nAlso, in some areas and teams, there is a time dedicated to your self-development. You can spend it on contributions to open-source, reading a book,\nlearning from the course, or, for example, writing a PoC of new technology with your team. In Allegro Pay - it is 10%. How you spend it - is up to you,\nor the team, it just should stick to our profession.\nThere are many internal and external communities (guilds), each with its own meeting calendar and interesting presentations and workshops taking a different kind of forms.\nThere are also many internal events, hackathons, and initiatives. Opportunities to learn are almost infinite.\nLanding here was my biggest personal and professional progression so far.\nThe bitter (or not?)\nSounds sweet, right? Where is the bitter here? Well, I am not sure.\nThis is a rapid-growth product and company. We are focused on delivering value to clients and maximizing profit from our products.\nEverything we do must contribute to overall success, and there is little space to “breathe”. You must often balance delivering functionalities,\npaying back technical debt, and growing scale. Taking shortcuts. Making trade-offs. Asking difficult questions. Our roadmaps often change\nbecause of the economics, law, or maybe data we gathered and told us that our actions do not convert in the way we assumed.\nIn Allegro Pay itself - the financial domain also does not help — a huge amount of our work is dedicated to legal matters. New laws pop up, and we must follow them.\nI can imagine that it can’t be for everyone.\nBut for me, this introduces an entirely new layer of engineering, where you need to be smart, cautious, value impact, and make the right choices.\nWe strive to be the best in the market, which is why we succeed.\nAnother thing can be the corporation itself. But this is very likely something that you will not notice until you become a manager.\nAllegro is a big company that has shifted to a more centralized and structured approach over the years. Everything needs to be aligned with the process.\nTo picture this, here are a few examples:\nInstead of ordering any accessories required within the budget - the budget was removed, and you can order only specific, pre-selected accessories\nWant to hire someone? There is budgeting once per year, and you need to come prepared to justify another full-time equivalent.\nDo you want to give someone a raise? Well, you don’t have to worry about this. Process, one per year, will do that for you.\nYou need to provide a performance review of your directs. Based on that you will get the budget, recommendations, and ability to slightly change proportions.\nWant to pursue external training? You have a budget. It would be best if you fit it in. You need to raise a request and process it through several layers of acceptance.\nAs you can imagine, all of that can take time and be annoying. It is very frequent that your “request” is stuck somewhere, and you need to “push” it.\nBut on the other end of the process, there are helpful people whom you can always talk to.\nSometimes, this leads to funny absurdities - you find an old monitor in the office that is not assigned to anyone (or a person who is not already in the company),\nand you would like to order a docking station for it. “Procedures” will not allow you to do that. The dock must have existed before; if lost,\nonly the owner can “order” a new one with a good justification. But you are not the owner. It is no man’s land - thus - no dock for it ;)\nBut I think most big corporations work like that. The past few years were also difficult for the industry. I understand why this is happening.\nIf you are an individual contributor, most of these things will not affect you. And those which do - you need to get used to it, and if you focus on the rest - hell - this is a great place to work.\nIs there more?\nA score of 11 tells that you will find much good stuff in software engineering here.\nBut this is not all. There are plenty of other great features of engineering culture at Allegro & Allegro Pay. You have great products, a big scale and\na data-driven approach which leads to many challenges; amazing, intelligent people; modern technology and approach to software engineering;\nrich off-topic communities (board games, sports, FIFA league, etc.), and many more.\nOverall, #DobrzeTuByć (#GoodToBeHere)","guid":"https://blog.allegro.tech/2024/06/pragmatic-engineer-score.html","categories":["tech","engineering culture","pragmatic engineer"],"isoDate":"2024-06-10T22:00:00.000Z"},{"title":"REST service client: design, testing, monitoring","link":"https://blog.allegro.tech/2024/06/rest-service-client-design-testing-monitoring.html","pubDate":"Tue, 04 Jun 2024 00:00:00 +0200","authors":{"author":[{"name":["Piotr Klimiec"],"photo":["https://blog.allegro.tech/img/authors/piotr.klimiec.jpg"],"url":["https://blog.allegro.tech/authors/piotr.klimiec"]}]},"content":"<p>The purpose of this article is to present how to design, test, and monitor a REST service client.\nThe article includes a <a href=\"https://github.com/Klimiec/webclients\">repository</a> with clients written in Kotlin using various technologies such as <a href=\"https://docs.spring.io/spring-framework/reference/web/webflux-webclient.html\">WebClient</a>,\n<a href=\"https://docs.spring.io/spring-framework/reference/integration/rest-clients.html#rest-restclient\">RestClient</a>,\n<a href=\"https://ktor.io/docs/getting-started-ktor-client.html\">Ktor Client</a>,\n<a href=\"https://square.github.io/retrofit/\">Retrofit</a>.\nIt demonstrates how to send and retrieve data from an external service, add a cache layer, and parse the received response into domain objects.</p>\n\n<h2 id=\"motivation\">Motivation</h2>\n<p>Why do we need objects in the project that encapsulate the HTTP clients we use?\nTo begin with, we want to separate the domain from technical details.\nThe way we retrieve/send data and handle errors, which can be quite complex in the case of HTTP clients, should not clutter business logic.\nNext, testability. Even if we do not use <a href=\"/2020/05/hexagonal-architecture-by-example.html\">hexagonal architecture</a> in our applications,\nit’s beneficial to separate the infrastructure from the service layer, as it improves testability.\nVerifying an HTTP service client is not a simple task and requires consideration of many cases — mainly at the integration level.\nHaving a separate “building block“ that encapsulates communication with the outside world makes testing much easier.\nFinally, reusability. A service client that has been written once can be successfully used in other projects.</p>\n\n<h2 id=\"client-design\">Client Design</h2>\n<p>As a case study, I will use an example implementation that utilizes WebClient for retrieving data from the Order Management Service,\nan example service that might appear in an e-commerce site such as <a href=\"https://allegro.tech/\">Allegro</a>.\nThe heart of our client is the <code class=\"language-plaintext highlighter-rouge\">executeHttpRequest</code> method, which is responsible for executing the provided HTTP request, logging, and error handling.\nIt is not part of the WebClient library.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">OrderManagementServiceClient</span><span class=\"p\">(</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">orderManagementServiceApi</span><span class=\"p\">:</span> <span class=\"nc\">OrderManagementServiceApi</span><span class=\"p\">,</span>\n    <span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">clientName</span><span class=\"p\">:</span> <span class=\"nc\">String</span>\n<span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">suspend</span> <span class=\"k\">fun</span> <span class=\"nf\">getOrdersFor</span><span class=\"p\">(</span><span class=\"n\">clientId</span><span class=\"p\">:</span> <span class=\"nc\">ClientId</span><span class=\"p\">):</span> <span class=\"nc\">OrdersDto</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"nf\">executeHttpRequest</span><span class=\"p\">(</span>\n            <span class=\"n\">initialLog</span> <span class=\"p\">=</span> <span class=\"s\">\"[$clientName] Get orders for a clientId= $clientId\"</span><span class=\"p\">,</span>\n            <span class=\"n\">request</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">orderManagementServiceApi</span><span class=\"p\">.</span><span class=\"nf\">getOrdersFor</span><span class=\"p\">(</span><span class=\"n\">clientId</span><span class=\"p\">)</span> <span class=\"p\">},</span>\n            <span class=\"n\">successLog</span> <span class=\"p\">=</span> <span class=\"s\">\"[$clientName] Returned orders for a clientId= $clientId\"</span><span class=\"p\">,</span>\n            <span class=\"n\">failureMessage</span> <span class=\"p\">=</span> <span class=\"s\">\"[$clientName] Failed to get orders for clientId= $clientId\"</span>\n        <span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n</code></pre></div></div>\n\n<p>Full working example can be found <a href=\"https://github.com/Klimiec/webclients/tree/main/httpclient-webclientinterface\">here</a>.</p>\n\n<h3 id=\"client-name\">Client name</h3>\n<p>I like to name clients using the convention: name of the service we integrate with, plus the suffix <strong>Client</strong>.\nIn the case of integration with the Order Management Service, such a class will be named <code class=\"language-plaintext highlighter-rouge\">OrderManagementServiceClient</code>.</p>\n\n<p>If the technology we use employs an interface to describe the called REST API (RestClient, WebClient, Retrofit),\nwe can name such an interface <code class=\"language-plaintext highlighter-rouge\">OrderManagementServiceApi</code> — following the general pattern of the service name with the suffix <strong>Api</strong>.</p>\n\n<p>These names may seem intuitive and obvious, but without an established naming convention, we might end up with a project where\ndifferent integrations have the following suffixes: <strong>HttpClient</strong>, <strong>Facade</strong>, <strong>WebClient</strong>, <strong>Adapter</strong>, and <strong>Service</strong>.\nIt’s important to have a consistent convention and adhere to it throughout the project.</p>\n\n<h3 id=\"api\">API</h3>\n<p>Methods of our clients should have names that reflect the communicative intention behind them.\nTo capture this intention, it is necessary to use a verb in the method’s name.\nTypically, the correct name will have a structure of verb + resource name, for example, <code class=\"language-plaintext highlighter-rouge\">getOrders</code>  —  for methods that retrieve resources.\nIf we want to narrow down the number of returned resources using filters or return a particular resource, I recommend adding the suffix “For” before the list of parameters.\nTechnically, these parameters will be part of the query or path parameters.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>fun getOrdersFor(clientId: ClientId): OrdersDto\n</code></pre></div></div>\n\n<p>For methods responsible for creating resources, simply using the verb in the method name is enough,\nas the resource being passed as a parameter effectively conveys the intention of the method.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>fun publish(event: InvoiceCreatedEventDto)\n</code></pre></div></div>\n\n<h3 id=\"logging\">Logging</h3>\n<p>When communicating with external service we’d like to log the beginning of the interaction, indicating our intention to fetch or send a resource,\nas well as its outcome. The outcome can be either a success, meaning receiving a response with a 2xx status code, or a failure.</p>\n\n<p>Failure can be signaled by status codes (3xx, 4xx, 5xx), resulting from the inability to deserialize the received response into an object,\nexceeding the response time, etc. Generally, <a href=\"/2015/07/testing-server-faults-with-Wiremock.html\">many things can go wrong</a>.\nDepending on the cause of failure, we may want to log the interaction result at different levels (warn/error).\nThere are critical errors that are worth distinguishing (error), and those that will occasionally occur (warn) and don’t require urgent intervention.</p>\n\n<p>To filter logs related to a specific service while browsing through them, I like to include the client’s name within curly braces at the beginning of the logs.\nFor logging technical aspects of the communication, such as the URL called, HTTP method used, and response code,\nwe use filters (logRequestInfo, logResponseInfo) that are plugged in at the client configuration level in the <code class=\"language-plaintext highlighter-rouge\">createExternalServiceApi</code> method.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">inline</span> <span class=\"k\">fun</span> <span class=\"p\">&lt;</span><span class=\"k\">reified</span> <span class=\"nc\">T</span><span class=\"p\">&gt;</span> <span class=\"nf\">createExternalServiceApi</span><span class=\"p\">(</span>\n    <span class=\"n\">webClientBuilder</span><span class=\"p\">:</span> <span class=\"nc\">WebClient</span><span class=\"p\">.</span><span class=\"nc\">Builder</span><span class=\"p\">,</span>\n    <span class=\"n\">properties</span><span class=\"p\">:</span> <span class=\"nc\">ConnectionProperties</span>\n<span class=\"p\">):</span> <span class=\"nc\">T</span> <span class=\"p\">=</span>\n    <span class=\"n\">webClientBuilder</span>\n        <span class=\"p\">.</span><span class=\"nf\">clientConnector</span><span class=\"p\">(</span><span class=\"nf\">httpClient</span><span class=\"p\">(</span><span class=\"n\">properties</span><span class=\"p\">))</span>\n        <span class=\"p\">.</span><span class=\"nf\">baseUrl</span><span class=\"p\">(</span><span class=\"n\">properties</span><span class=\"p\">.</span><span class=\"n\">baseUrl</span><span class=\"p\">)</span>\n        <span class=\"p\">.</span><span class=\"nf\">defaultRequest</span> <span class=\"p\">{</span> <span class=\"n\">it</span><span class=\"p\">.</span><span class=\"nf\">attribute</span><span class=\"p\">(</span><span class=\"nc\">SERVICE_NAME</span><span class=\"p\">,</span> <span class=\"n\">properties</span><span class=\"p\">.</span><span class=\"n\">clientName</span><span class=\"p\">)</span> <span class=\"p\">}</span>\n        <span class=\"p\">.</span><span class=\"nf\">filter</span><span class=\"p\">(</span><span class=\"nf\">logRequestInfo</span><span class=\"p\">(</span><span class=\"n\">properties</span><span class=\"p\">.</span><span class=\"n\">clientName</span><span class=\"p\">))</span>\n        <span class=\"p\">.</span><span class=\"nf\">filter</span><span class=\"p\">(</span><span class=\"nf\">logResponseInfo</span><span class=\"p\">(</span><span class=\"n\">properties</span><span class=\"p\">.</span><span class=\"n\">clientName</span><span class=\"p\">))</span>\n        <span class=\"p\">.</span><span class=\"nf\">build</span><span class=\"p\">()</span>\n        <span class=\"p\">.</span><span class=\"nf\">let</span> <span class=\"p\">{</span> <span class=\"nc\">WebClientAdapter</span><span class=\"p\">.</span><span class=\"nf\">create</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">)</span> <span class=\"p\">}</span>\n        <span class=\"p\">.</span><span class=\"nf\">let</span> <span class=\"p\">{</span> <span class=\"nc\">HttpServiceProxyFactory</span><span class=\"p\">.</span><span class=\"nf\">builderFor</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">).</span><span class=\"nf\">build</span><span class=\"p\">()</span> <span class=\"p\">}</span>\n        <span class=\"p\">.</span><span class=\"nf\">createClient</span><span class=\"p\">(</span><span class=\"nc\">T</span><span class=\"o\">::</span><span class=\"k\">class</span><span class=\"p\">.</span><span class=\"n\">java</span><span class=\"p\">)</span>\n\n<span class=\"k\">fun</span> <span class=\"nf\">logRequestInfo</span><span class=\"p\">(</span><span class=\"n\">clientName</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">)</span> <span class=\"p\">=</span> <span class=\"nc\">ExchangeFilterFunction</span><span class=\"p\">.</span><span class=\"nf\">ofRequestProcessor</span> <span class=\"p\">{</span> <span class=\"n\">request</span> <span class=\"p\">-&gt;</span>\n    <span class=\"n\">logger</span><span class=\"p\">.</span><span class=\"nf\">info</span> <span class=\"p\">{</span>\n        <span class=\"s\">\"[$clientName] method=[${request.method().name()}] url=${request.url()}}\"</span>\n    <span class=\"p\">}</span>\n    <span class=\"nc\">Mono</span><span class=\"p\">.</span><span class=\"nf\">just</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">fun</span> <span class=\"nf\">logResponseInfo</span><span class=\"p\">(</span><span class=\"n\">clientName</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">)</span> <span class=\"p\">=</span> <span class=\"nc\">ExchangeFilterFunction</span><span class=\"p\">.</span><span class=\"nf\">ofResponseProcessor</span> <span class=\"p\">{</span> <span class=\"n\">response</span> <span class=\"p\">-&gt;</span>\n    <span class=\"n\">logger</span><span class=\"p\">.</span><span class=\"nf\">info</span> <span class=\"p\">{</span> <span class=\"s\">\"[$clientName] service responded with a status code= ${response.statusCode()}\"</span> <span class=\"p\">}</span>\n    <span class=\"nc\">Mono</span><span class=\"p\">.</span><span class=\"nf\">just</span><span class=\"p\">(</span><span class=\"n\">response</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>Here’s an example of logged interaction for successfully fetching a resource.</p>\n\n<p><img alt=\"Properly logged interaction\" src=\"/img/articles/2024-06-04-rest-service-client-design-testing-monitoring/logs.png\" /></p>\n\n<p>To prevent redundancy in logging code across multiple clients, it is centralized inside <code class=\"language-plaintext highlighter-rouge\">executeHttpRequest</code> method.\nThe only thing the developer needs to do is to provide a business-oriented description for the beginning of the interaction and its outcome (parameters: <code class=\"language-plaintext highlighter-rouge\">initialLog</code>, <code class=\"language-plaintext highlighter-rouge\">successLog</code>, <code class=\"language-plaintext highlighter-rouge\">failureMessage</code>).</p>\n\n<p>Why do I emphasize logging so much?\nIsn’t it enough to log only errors?\nAfter all, we have metrics that inform us about the performance of our clients.\nMetrics won’t provide us with the details of the communication, but logs will.\nThese details can turn out to be crucial in the analysis of incidents, which may reveal, for example, incorrect data produced by our service.</p>\n\n<p>Logs are like backups. We find out if we have them and how valuable they are only when they are needed,\neither because the business team requests an analysis of a particular case or when resolving an incident.</p>\n\n<h3 id=\"error-handling\">Error handling</h3>\n<p>When writing client code, we aim to highlight maximally how we send/retrieve data and hide the “noise“ that comes from error handling.\nIn the case of HTTP clients, error handling is quite extensive but generic enough that the resulting code can be written once and reused across all clients.\nIn our example, error handling mechanism is hidden inside <code class=\"language-plaintext highlighter-rouge\">executeHttpRequest</code> method.\nIt consists of two things: logging and throwing custom exceptions that encapsulate technical exceptions thrown by the underlying HTTP client.</p>\n\n<p>What are the benefits of using custom exceptions? The very name of such a custom exception tells us exactly what went wrong.\nFor comparison, <code class=\"language-plaintext highlighter-rouge\">ExternalServiceIncorrectResponseBodyException</code> seems to be more descriptive than <code class=\"language-plaintext highlighter-rouge\">DecodingException</code>.\nThey also help group various technical exceptions that lead to the same cause, for example, an incorrect response object structure.\nAdditionally, based on these exceptions, visualizations can be created to show the state of our integration.\nFor example, we can create a table that will show how many exceptions of any given type were thrown by our clients within a specified period.\nHaving custom exceptions, we are 100% certain that these exceptions were thrown only by our clients.</p>\n\n<h3 id=\"testing\">Testing</h3>\n<h4 id=\"stubs\">Stubs</h4>\n<p>To verify different scenarios of our HTTP client, it is necessary to appropriately stub the called endpoints in tests.\nFor this purpose, we will use the <a href=\"https://wiremock.org/\">WireMock</a> library.</p>\n\n<p>It is quite important that the technical details of created stubs do not leak into the tests.\nThe test should describe the behavior being tested and encapsulate technical details.\nFor example, changing the accept/content-type header or making minor modifications to the called URL should not affect the test itself.\nTo achieve this, for each service for which we write a service client, we create an object of type <code class=\"language-plaintext highlighter-rouge\">StubBuilder</code>.\nThe <code class=\"language-plaintext highlighter-rouge\">StubBuilder</code> allows hiding the details of stubbing and verification behind a readable API.\nIt takes on the impact of changes to the called API, protecting our test from modification.\nIt fulfills a similar role to the <a href=\"https://martinfowler.com/bliki/PageObject.html\">Page Object Pattern</a> in end-to-end tests for web apps.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">orderManagementServiceStub</span><span class=\"p\">.</span><span class=\"nf\">willReturnOrdersFor</span><span class=\"p\">(</span><span class=\"n\">clientId</span><span class=\"p\">,</span> <span class=\"n\">response</span> <span class=\"p\">=</span> <span class=\"nf\">ordersPlacedBySomeCustomer</span><span class=\"p\">())</span>\n</code></pre></div></div>\n\n<p>StubBuilders for services that return data come in two flavors - <a href=\"https://github.com/Klimiec/webclients/tree/591dddd1e61ea5d922f0402534d9a96a513f59b4/httpclient-webclientinterface/src/integration/kotlin/com/dev/sandbox/httpclientwebclientinterface/order/infrastructure/ordermanagementservice/stub/internal\">internal</a> and <a href=\"https://github.com/Klimiec/webclients/tree/591dddd1e61ea5d922f0402534d9a96a513f59b4/httpclient-webclientinterface/src/integration/kotlin/com/dev/sandbox/httpclientwebclientinterface/order/infrastructure/ordermanagementservice/stub/external\">external</a>.</p>\n\n<p><img alt=\"StubBuilder packages\" src=\"/img/articles/2024-06-04-rest-service-client-design-testing-monitoring/packages.png\" /></p>\n\n<p>When testing a service client, we want to have great flexibility in simulating responses.\nTherefore, <code class=\"language-plaintext highlighter-rouge\">StubBuilders</code> from the internal package will model response objects as a string. This allows us to simulate any scenario.\nIn end-to-end tests, where a given service is part of the bigger process, such flexibility is not necessary; in fact, it is not even recommended.\nTherefore, StubBuilders from the external package model responses using real objects.\nAll StubBuilders from the external packages are declared in the class <code class=\"language-plaintext highlighter-rouge\">ExternalServiceStubs</code>, to which a reference is located in the base class for\nall integration tests, <code class=\"language-plaintext highlighter-rouge\">BaseIntegrationTest</code>. This allows us to have very easy access to all external service stubs in our integration tests.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">stub</span><span class=\"p\">.</span><span class=\"nf\">orderManagementService</span><span class=\"p\">().</span><span class=\"nf\">willReturnOrdersFor</span><span class=\"p\">(</span><span class=\"n\">clientId</span><span class=\"p\">,</span> <span class=\"n\">response</span> <span class=\"p\">=</span> <span class=\"nf\">ordersPlacedBySomeCustomer</span><span class=\"p\">())</span>\n</code></pre></div></div>\n\n<p>Reading the code above, we immediately know <strong>which</strong> service is being interacted with (Order Management Service) and what will be returned from it (Orders).\nThe technical details of the stubbed endpoint have been hidden inside the StubBuilder object.\nTests should emphasize “what” and encapsulate “how.” This way, they can serve as documentation.</p>\n\n<h4 id=\"test-data\">Test Data</h4>\n\n<p>The data returned by our stubs can be prepared in three ways:</p>\n<ol type=\"a\">\n  <li>Read the entire response from a file/string.</li>\n  <li>Prepare the response using real objects used in the service for deserializing responses from called services.</li>\n  <li>Create a set of separate objects modeling the returned response from the service for testing purposes and use them to prepare the returned data.</li>\n</ol>\n\n<p>Which option to choose?\nTo answer this question, we should analyze the advantages and disadvantages of each approach.</p>\n\n<p>Option A — read response from a file/string. Response creation is very fast and simple.\nIt allows <strong>verifying the contract</strong> between the client and the supplier (at least at the time of writing the test).\nImagine that during refactoring, one of the fields in the response object accidentally changes.\nIn such a case, client tests using this approach will detect the defect before the code reaches production.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Test</span>\n<span class=\"k\">fun</span> <span class=\"nf\">`should</span> <span class=\"k\">return</span> <span class=\"n\">orders</span> <span class=\"k\">for</span> <span class=\"n\">a</span> <span class=\"n\">given</span> <span class=\"nf\">clientId`</span><span class=\"p\">():</span> <span class=\"nc\">Unit</span> <span class=\"p\">=</span> <span class=\"nf\">runBlocking</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// given</span>\n        <span class=\"kd\">val</span> <span class=\"py\">clientId</span> <span class=\"p\">=</span> <span class=\"nf\">anyClientId</span><span class=\"p\">()</span>\n        <span class=\"n\">orderManagementServiceStub</span><span class=\"p\">.</span><span class=\"nf\">willReturnOrdersFor</span><span class=\"p\">(</span><span class=\"n\">clientId</span><span class=\"p\">,</span> <span class=\"n\">response</span> <span class=\"p\">=</span> <span class=\"nf\">ordersPlacedBySomeCustomer</span><span class=\"p\">())</span>\n\n        <span class=\"c1\">// when</span>\n        <span class=\"kd\">val</span> <span class=\"py\">response</span><span class=\"p\">:</span> <span class=\"nc\">OrdersDto</span> <span class=\"p\">=</span> <span class=\"n\">orderManagementServiceClient</span><span class=\"p\">.</span><span class=\"nf\">getOrdersFor</span><span class=\"p\">(</span><span class=\"n\">clientId</span><span class=\"p\">)</span>\n\n        <span class=\"c1\">// then</span>\n        <span class=\"n\">response</span> <span class=\"n\">shouldBe</span> <span class=\"nc\">OrdersDto</span><span class=\"p\">(</span><span class=\"nf\">listOf</span><span class=\"p\">(</span><span class=\"nc\">OrderDto</span><span class=\"p\">(</span><span class=\"s\">\"7952a9ab-503c-4483-beca-32d081cc2446\"</span><span class=\"p\">)))</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>On the other hand, keeping data in files/strings is difficult to maintain and reuse.\nProgrammers often copy entire files for new tests, introducing only minimal changes.\nThere is a problem with naming these files and refactoring them when the called service introduces an incompatible change.</p>\n\n<p>Option B — Use real response objects.\nIt allows writing one-line, readable assertions and maximally reusing already created data, especially using <a href=\"https://www.natpryce.com/articles/000714.html\">test data builders</a>.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    <span class=\"nd\">@Test</span>\n    <span class=\"k\">fun</span> <span class=\"nf\">`should</span> <span class=\"k\">return</span> <span class=\"n\">orders</span> <span class=\"k\">for</span> <span class=\"n\">a</span> <span class=\"n\">given</span> <span class=\"nf\">clientId`</span><span class=\"p\">():</span> <span class=\"nc\">Unit</span> <span class=\"p\">=</span> <span class=\"nf\">runBlocking</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// given</span>\n        <span class=\"kd\">val</span> <span class=\"py\">clientId</span> <span class=\"p\">=</span> <span class=\"nf\">anyClientId</span><span class=\"p\">()</span>\n        <span class=\"kd\">val</span> <span class=\"py\">clientOrders</span> <span class=\"p\">=</span> <span class=\"nc\">OrderManagementServiceFixture</span><span class=\"p\">.</span><span class=\"nf\">ordersPlacedBySomeCustomer</span><span class=\"p\">()</span>\n        <span class=\"n\">orderManagementServiceStub</span><span class=\"p\">.</span><span class=\"nf\">willReturnOrdersFor</span><span class=\"p\">(</span><span class=\"n\">clientId</span><span class=\"p\">,</span> <span class=\"n\">response</span> <span class=\"p\">=</span> <span class=\"n\">clientOrders</span><span class=\"p\">)</span>\n\n        <span class=\"c1\">// when</span>\n        <span class=\"kd\">val</span> <span class=\"py\">response</span><span class=\"p\">:</span> <span class=\"nc\">OrdersDto</span> <span class=\"p\">=</span> <span class=\"n\">orderManagementServiceClient</span><span class=\"p\">.</span><span class=\"nf\">getOrdersFor</span><span class=\"p\">(</span><span class=\"n\">clientId</span><span class=\"p\">)</span>\n\n        <span class=\"c1\">// then</span>\n        <span class=\"n\">response</span> <span class=\"n\">shouldBe</span> <span class=\"n\">clientOrders</span>\n    <span class=\"p\">}</span>\n</code></pre></div></div>\n<p>However, accidental change of field name which results in the  <strong>contract violation</strong> between the client and supplier won’t be caught.\nAs a result, we might have perfectly tested communication in integration tests that will not work in production.</p>\n\n<p>Option C — create a set of separate response objects. It has all the advantages of options A and B, including maintainability, reusability, and\nverification of the contract between the client and the supplier. Unfortunately, maintaining a separate model for testing purposes comes with some overhead\nand requires discipline on the developers’ side, which can be challenging to maintain.</p>\n\n<p>Which option to choose? Personally, I prefer a hybrid of options A and B.\nFor the purpose of testing the “happy path“ in client tests, I return a response that is entirely stored as a string (alternatively, it can be read from a file).\nSuch a test allows not only to verify the contract but also the correctness of deserializing the received response into a response object.\nIn other tests (cache, adapter, end-to-end), I create responses returned by the stubbed endpoint using production response objects.</p>\n\n<p>It’s worthwhile to keep sample test data in dedicated classes, such as a Fixture class, for each integration (for example <code class=\"language-plaintext highlighter-rouge\">OrderManagementServiceFixture</code>).\nThis allows the reuse of test data and enhances the readability of the tests themselves.</p>\n\n<h3 id=\"test-scenarios\">Test Scenarios</h3>\n<h4 id=\"happy-path\">Happy Path</h4>\n<p><strong>Fetching a resource</strong> — verification whether the client can retrieve data from the previously stubbed endpoint and deserialize it into a response object.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Test</span>\n<span class=\"k\">fun</span> <span class=\"nf\">`should</span> <span class=\"k\">return</span> <span class=\"n\">orders</span> <span class=\"k\">for</span> <span class=\"n\">a</span> <span class=\"n\">given</span> <span class=\"nf\">clientId`</span><span class=\"p\">():</span> <span class=\"nc\">Unit</span> <span class=\"p\">=</span> <span class=\"nf\">runBlocking</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// given</span>\n        <span class=\"kd\">val</span> <span class=\"py\">clientId</span> <span class=\"p\">=</span> <span class=\"nf\">anyClientId</span><span class=\"p\">()</span>\n        <span class=\"n\">orderManagementServiceStub</span><span class=\"p\">.</span><span class=\"nf\">willReturnOrdersFor</span><span class=\"p\">(</span><span class=\"n\">clientId</span><span class=\"p\">,</span> <span class=\"n\">response</span> <span class=\"p\">=</span> <span class=\"nf\">ordersPlacedBySomeCustomer</span><span class=\"p\">())</span>\n\n        <span class=\"c1\">// when</span>\n        <span class=\"kd\">val</span> <span class=\"py\">response</span><span class=\"p\">:</span> <span class=\"nc\">OrdersDto</span> <span class=\"p\">=</span> <span class=\"n\">orderManagementServiceClient</span><span class=\"p\">.</span><span class=\"nf\">getOrdersFor</span><span class=\"p\">(</span><span class=\"n\">clientId</span><span class=\"p\">)</span>\n\n        <span class=\"c1\">// then</span>\n        <span class=\"n\">response</span> <span class=\"n\">shouldBe</span> <span class=\"nc\">OrdersDto</span><span class=\"p\">(</span><span class=\"nf\">listOf</span><span class=\"p\">(</span><span class=\"nc\">OrderDto</span><span class=\"p\">(</span><span class=\"s\">\"7952a9ab-503c-4483-beca-32d081cc2446\"</span><span class=\"p\">)))</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<p>An essential part of the test for the “happy path“ is verification of the contract between the client and the supplier.\nThe <code class=\"language-plaintext highlighter-rouge\">ordersPlacedBySomeCustomer</code> method returns a sample response guaranteed by the supplier (Order Management Service).\nOn the client side, in the assertion section, we check if this message has been correctly deserialized into a response object.\nInstead of comparing individual fields with the expected value, I highly recommend comparing entire objects (returned and expected).\nIt gives us confidence that all fields have been compared. In the case of regression, modern IDEs such as IntelliJ indicate exactly where the problem is.</p>\n\n<p><img alt=\"Test regression\" src=\"/img/articles/2024-06-04-rest-service-client-design-testing-monitoring/regression.png\" /></p>\n\n<p><strong>Sending a resource</strong> — verification whether the client sends data to the specified URL in a format acceptable by the previously stubbed endpoint.\nIn the following example, I test publishing an event to <a href=\"https://hermes.allegro.tech/\">Hermes</a>, a message broker built on top of Kafka widely used at Allegro.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Test</span>\n<span class=\"k\">fun</span> <span class=\"nf\">`should</span> <span class=\"n\">successfully</span> <span class=\"n\">publish</span> <span class=\"nc\">InvoiceCreatedEvent`</span><span class=\"p\">():</span> <span class=\"nc\">Unit</span> <span class=\"p\">=</span> <span class=\"nf\">runBlocking</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// given</span>\n        <span class=\"kd\">val</span> <span class=\"py\">invoiceCreatedEvent</span> <span class=\"p\">=</span> <span class=\"nc\">HermesFixture</span><span class=\"p\">.</span><span class=\"nf\">invoiceCreatedEvent</span><span class=\"p\">()</span>\n        <span class=\"n\">stub</span><span class=\"p\">.</span><span class=\"nf\">hermes</span><span class=\"p\">().</span><span class=\"nf\">willAcceptInvoiceCreatedEvent</span><span class=\"p\">()</span>\n\n        <span class=\"c1\">// when</span>\n        <span class=\"n\">hermesClient</span><span class=\"p\">.</span><span class=\"nf\">publish</span><span class=\"p\">(</span><span class=\"n\">invoiceCreatedEvent</span><span class=\"p\">)</span>\n\n        <span class=\"c1\">// then</span>\n        <span class=\"n\">stub</span><span class=\"p\">.</span><span class=\"nf\">hermes</span><span class=\"p\">().</span><span class=\"nf\">verifyInvoiceCreatedEventPublished</span><span class=\"p\">(</span><span class=\"n\">event</span> <span class=\"p\">=</span> <span class=\"n\">invoiceCreatedEvent</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>Stubbed endpoints for methods accepting request bodies (e.g., POST, PUT) should not verify the values of the received request body but only its <ins>structure</ins>.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">fun</span> <span class=\"nf\">willAcceptInvoiceCreatedEvent</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"nc\">WireMock</span><span class=\"p\">.</span><span class=\"nf\">stubFor</span><span class=\"p\">(</span>\n        <span class=\"nf\">invoiceCreatedEventTopic</span><span class=\"p\">()</span>\n            <span class=\"p\">.</span><span class=\"nf\">withRequestBody</span><span class=\"p\">(</span><span class=\"nc\">WireMock</span><span class=\"p\">.</span><span class=\"nf\">matchingJsonPath</span><span class=\"p\">(</span><span class=\"s\">\"$.invoiceId\"</span><span class=\"p\">))</span>\n            <span class=\"p\">.</span><span class=\"nf\">withRequestBody</span><span class=\"p\">(</span><span class=\"nc\">WireMock</span><span class=\"p\">.</span><span class=\"nf\">matchingJsonPath</span><span class=\"p\">(</span><span class=\"s\">\"$.orderId\"</span><span class=\"p\">))</span>\n            <span class=\"p\">.</span><span class=\"nf\">withRequestBody</span><span class=\"p\">(</span><span class=\"nc\">WireMock</span><span class=\"p\">.</span><span class=\"nf\">matchingJsonPath</span><span class=\"p\">(</span><span class=\"s\">\"$.timestamp\"</span><span class=\"p\">))</span>\n            <span class=\"p\">.</span><span class=\"nf\">willReturn</span><span class=\"p\">(</span>\n                <span class=\"nc\">WireMock</span><span class=\"p\">.</span><span class=\"nf\">aResponse</span><span class=\"p\">()</span>\n                    <span class=\"p\">.</span><span class=\"nf\">withFixedDelay</span><span class=\"p\">(</span><span class=\"n\">responseTime</span><span class=\"p\">)</span>\n                    <span class=\"p\">.</span><span class=\"nf\">withStatus</span><span class=\"p\">(</span><span class=\"nc\">HttpStatus</span><span class=\"p\">.</span><span class=\"nc\">OK</span><span class=\"p\">.</span><span class=\"nf\">value</span><span class=\"p\">())</span>\n            <span class=\"p\">)</span>\n    <span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>We verify the content of the request body in the assertion section.\nHere, we also want to hide the technical aspects of assertions behind a method.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">stubs</span><span class=\"p\">.</span><span class=\"nf\">hermes</span><span class=\"p\">().</span><span class=\"nf\">verifyInvoiceCreatedEventPublished</span><span class=\"p\">(</span><span class=\"n\">event</span> <span class=\"p\">=</span> <span class=\"n\">invoiceCreatedEvent</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">fun</span> <span class=\"nf\">verifyInvoiceCreatedEventPublished</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">:</span> <span class=\"nc\">InvoiceCreatedEventDto</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nc\">WireMock</span><span class=\"p\">.</span><span class=\"nf\">verify</span><span class=\"p\">(</span>\n        <span class=\"mi\">1</span><span class=\"p\">,</span>\n        <span class=\"nc\">WireMock</span><span class=\"p\">.</span><span class=\"nf\">postRequestedFor</span><span class=\"p\">(</span><span class=\"nc\">WireMock</span><span class=\"p\">.</span><span class=\"nf\">urlPathEqualTo</span><span class=\"p\">(</span><span class=\"nc\">INVOICE_CREATED_URL</span><span class=\"p\">))</span>\n            <span class=\"p\">.</span><span class=\"nf\">withRequestBody</span><span class=\"p\">(</span><span class=\"nc\">WireMock</span><span class=\"p\">.</span><span class=\"nf\">matchingJsonPath</span><span class=\"p\">(</span><span class=\"s\">\"$.invoiceId\"</span><span class=\"p\">,</span> <span class=\"nc\">WireMock</span><span class=\"p\">.</span><span class=\"nf\">equalTo</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">.</span><span class=\"n\">invoiceId</span><span class=\"p\">)))</span>\n            <span class=\"p\">.</span><span class=\"nf\">withRequestBody</span><span class=\"p\">(</span><span class=\"nc\">WireMock</span><span class=\"p\">.</span><span class=\"nf\">matchingJsonPath</span><span class=\"p\">(</span><span class=\"s\">\"$.orderId\"</span><span class=\"p\">,</span> <span class=\"nc\">WireMock</span><span class=\"p\">.</span><span class=\"nf\">equalTo</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">.</span><span class=\"n\">orderId</span><span class=\"p\">)))</span>\n            <span class=\"p\">.</span><span class=\"nf\">withRequestBody</span><span class=\"p\">(</span><span class=\"nc\">WireMock</span><span class=\"p\">.</span><span class=\"nf\">matchingJsonPath</span><span class=\"p\">(</span><span class=\"s\">\"$.timestamp\"</span><span class=\"p\">,</span> <span class=\"nc\">WireMock</span><span class=\"p\">.</span><span class=\"nf\">equalTo</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">.</span><span class=\"n\">timestamp</span><span class=\"p\">)))</span>\n    <span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>Combining stubbing and request verification in one method is not recommended.\nCreating stubs in this way makes their usage less convenient since not every test requires detailed verification of what is being sent in the request body.\nThe vast majority of tests will stub the endpoint based on the principle:\naccept a given request as long as its structure is preserved and will verify hypotheses other than the content of the request body (mainly end-to-end tests).</p>\n\n<h4 id=\"client-side-errors\">Client-side errors</h4>\n\n<p>For 4xx type errors, we want to verify the following cases:</p>\n<ul>\n  <li>The absence of the requested resource signaled by the response code 404 and a custom exception <code class=\"language-plaintext highlighter-rouge\">ExternalServiceResourceNotFoundException</code></li>\n  <li>Validation error signaled by the response code 422 and a custom exception <code class=\"language-plaintext highlighter-rouge\">ExternalServiceRequestValidationException</code></li>\n  <li>Any other 4xx type errors  should be cast to an <code class=\"language-plaintext highlighter-rouge\">ExternalServiceClientException</code></li>\n</ul>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@ParameterizedTest</span><span class=\"p\">(</span><span class=\"n\">name</span> <span class=\"p\">=</span> <span class=\"s\">\"{index}) http status code: {0}\"</span><span class=\"p\">)</span>\n<span class=\"nd\">@MethodSource</span><span class=\"p\">(</span><span class=\"s\">\"clientErrors\"</span><span class=\"p\">)</span>\n<span class=\"k\">fun</span> <span class=\"nf\">`when</span> <span class=\"n\">receive</span> <span class=\"n\">response</span> <span class=\"n\">with</span> <span class=\"mi\">4</span><span class=\"n\">xx</span> <span class=\"n\">status</span> <span class=\"n\">code</span> <span class=\"n\">then</span> <span class=\"k\">throw</span> <span class=\"nf\">exception`</span><span class=\"p\">(</span>\n    <span class=\"n\">exceptionClass</span><span class=\"p\">:</span> <span class=\"nc\">Class</span><span class=\"p\">&lt;</span><span class=\"nc\">Exception</span><span class=\"p\">&gt;,</span>\n    <span class=\"n\">statusCode</span><span class=\"p\">:</span> <span class=\"nc\">Int</span><span class=\"p\">,</span>\n    <span class=\"n\">responseBody</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">?</span>\n<span class=\"p\">):</span> <span class=\"nc\">Unit</span> <span class=\"p\">=</span> <span class=\"nf\">runBlocking</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// given</span>\n        <span class=\"kd\">val</span> <span class=\"py\">clientId</span> <span class=\"p\">=</span> <span class=\"nf\">anyClientId</span><span class=\"p\">()</span>\n        <span class=\"n\">orderManagementServiceStub</span><span class=\"p\">.</span><span class=\"nf\">willReturnOrdersFor</span><span class=\"p\">(</span><span class=\"n\">clientId</span><span class=\"p\">,</span> <span class=\"n\">status</span> <span class=\"p\">=</span> <span class=\"n\">statusCode</span><span class=\"p\">,</span> <span class=\"n\">response</span> <span class=\"p\">=</span> <span class=\"n\">responseBody</span><span class=\"p\">)</span>\n\n        <span class=\"c1\">// when</span>\n        <span class=\"kd\">val</span> <span class=\"py\">exception</span> <span class=\"p\">=</span> <span class=\"nf\">shouldThrowAny</span> <span class=\"p\">{</span>\n            <span class=\"n\">orderManagementServiceClient</span><span class=\"p\">.</span><span class=\"nf\">getOrdersFor</span><span class=\"p\">(</span><span class=\"n\">clientId</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n\n        <span class=\"c1\">// then</span>\n        <span class=\"n\">exception</span><span class=\"p\">.</span><span class=\"n\">javaClass</span> <span class=\"n\">shouldBeSameInstanceAs</span> <span class=\"n\">exceptionClass</span>\n        <span class=\"n\">exception</span><span class=\"p\">.</span><span class=\"n\">message</span> <span class=\"n\">shouldContain</span> <span class=\"n\">clientId</span><span class=\"p\">.</span><span class=\"n\">clientId</span><span class=\"p\">.</span><span class=\"nf\">toString</span><span class=\"p\">()</span>\n        <span class=\"n\">exception</span><span class=\"p\">.</span><span class=\"n\">message</span> <span class=\"n\">shouldContain</span> <span class=\"n\">properties</span><span class=\"p\">.</span><span class=\"n\">clientName</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>In distributed systems, a <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404\">404</a> response code is quite common and may result from temporary inconsistency across the entire system.\nIts occurrence is signaled by the <code class=\"language-plaintext highlighter-rouge\">ExternalServiceResourceNotFoundException</code> and a warning-level log.\nHere, we are more interested in the scale of occurrences, which is why we use metrics, than analyzing individual cases, hence we log such cases at the warning level.</p>\n\n<p>The situation looks a bit different in the case of responses with a code of <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/422\">422</a>.\nIf the request is rejected due to validation errors, either our service has a defect and produces incorrect data,\nor we receive incorrect data from external services (which is why it’s crucial to log what we receive from external services).\nAlternatively, the error may be on the recipient side in the logic validating the received request. It’s worth analyzing each such case, which is why\nerrors of this type are logged at the error level and signaled by the <code class=\"language-plaintext highlighter-rouge\">ExternalServiceRequestValidationException</code>.</p>\n\n<p>Other errors from the 4xx family occur less frequently.\nThey are all marked by the <code class=\"language-plaintext highlighter-rouge\">ExternalServiceClientException</code> exception and logged at the error level.</p>\n\n<h4 id=\"server-side-errors\">Server-side errors</h4>\n<p>Regardless of the reason for a 5xx error, all of them are logged at the warn level because we have no control over them.\nThey are signaled by the <code class=\"language-plaintext highlighter-rouge\">ExternalServiceServerException</code> exception. Similar to 404 errors, we are more interested in aggregate information\nabout the number of such errors rather than analyzing each case individually, hence the warn log level.</p>\n\n<p>In tests, we consider two cases because the response from the service may or may not have a body.\nIf the response has a body, we want to log it.</p>\n\n<h4 id=\"read-timeout\">Read Timeout</h4>\n<p>Our HTTP client should have a finite response timeout configured, so it’s worthwhile to write an integration test that verifies the client’s configuration.\nSimulating the delay of the stubbed endpoint can be achieved using the <code class=\"language-plaintext highlighter-rouge\">withFixedDelay</code> method from wiremock.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Test</span>\n<span class=\"k\">fun</span> <span class=\"nf\">`when</span> <span class=\"n\">service</span> <span class=\"n\">returns</span> <span class=\"n\">above</span> <span class=\"n\">timeout</span> <span class=\"n\">threshold</span> <span class=\"n\">then</span> <span class=\"k\">throw</span> <span class=\"nf\">exception`</span><span class=\"p\">():</span> <span class=\"nc\">Unit</span> <span class=\"p\">=</span> <span class=\"nf\">runBlocking</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// given</span>\n        <span class=\"kd\">val</span> <span class=\"py\">clientId</span> <span class=\"p\">=</span> <span class=\"nf\">anyClientId</span><span class=\"p\">()</span>\n\n        <span class=\"n\">orderManagementServiceStub</span>\n            <span class=\"p\">.</span><span class=\"nf\">withDelay</span><span class=\"p\">(</span><span class=\"n\">properties</span><span class=\"p\">.</span><span class=\"n\">readTimeout</span><span class=\"p\">.</span><span class=\"nf\">toInt</span><span class=\"p\">())</span>\n            <span class=\"p\">.</span><span class=\"nf\">willReturnOrdersFor</span><span class=\"p\">(</span>\n                <span class=\"n\">clientId</span><span class=\"p\">,</span>\n                <span class=\"n\">response</span> <span class=\"p\">=</span> <span class=\"nf\">ordersPlacedBySomeCustomer</span><span class=\"p\">()</span>\n            <span class=\"p\">)</span>\n\n        <span class=\"c1\">// when</span>\n        <span class=\"kd\">val</span> <span class=\"py\">exception</span> <span class=\"p\">=</span> <span class=\"n\">shouldThrow</span><span class=\"p\">&lt;</span><span class=\"nc\">ExternalServiceReadTimeoutException</span><span class=\"p\">&gt;</span> <span class=\"p\">{</span>\n            <span class=\"n\">orderManagementServiceClient</span><span class=\"p\">.</span><span class=\"nf\">getOrdersFor</span><span class=\"p\">(</span><span class=\"n\">clientId</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n        <span class=\"c1\">// then</span>\n        <span class=\"n\">exception</span><span class=\"p\">.</span><span class=\"n\">message</span> <span class=\"n\">shouldContain</span> <span class=\"n\">clientId</span><span class=\"p\">.</span><span class=\"n\">clientId</span><span class=\"p\">.</span><span class=\"nf\">toString</span><span class=\"p\">()</span>\n        <span class=\"n\">exception</span><span class=\"p\">.</span><span class=\"n\">message</span> <span class=\"n\">shouldContain</span> <span class=\"n\">properties</span><span class=\"p\">.</span><span class=\"n\">clientName</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>No, this is not testing properties in tests.\nThis test ensures that the configuration derived from properties has indeed been applied to the given client.\nEnsuring a response within a specified time frame might be part of non-functional requirements and requires verification.</p>\n\n<h4 id=\"invalid-response-body\">Invalid Response Body</h4>\n<p>Considered cases:</p>\n<ul>\n  <li>Response body does not contain required field.</li>\n  <li>Response body is empty.</li>\n  <li>Response has an incorrect format.</li>\n</ul>\n\n<p>Errors of this type are signaled through <code class=\"language-plaintext highlighter-rouge\">ExternalServiceIncorrectResponseBodyException</code> and logged at the error level.</p>\n\n<h3 id=\"metrics\">Metrics</h3>\n<p>When dealing with HTTP clients, it’s essential to monitor several aspects: response times, throughput, and error rates.\nTo differentiate metrics generated by different clients easily, it’s advisable to include a <code class=\"language-plaintext highlighter-rouge\">service.name</code> tag with the respective client’s name.</p>\n\n<p>In HTTP clients offered by the Spring framework (WebClient, RestClient),\nmetrics are enabled out-of-the-box if we create them using predefined builders (WebClient.Builder, RestClient.Builder).\nHowever, for other technologies, third-party solutions must be employed. In Allegro, we have a set of libraries that allows us to quickly create new\nHTTP clients in the most popular technologies that provide support for our infrastructure.\nAs a result, all clients generate consistent metrics by default tailored to our dashboards.</p>\n\n<h4 id=\"response-time\">Response Time</h4>\n<p>Measuring the response time of HTTP clients allows us to identify bottlenecks.\nAt which percentile should we set such a metric?\nGenerally, the more requests a client generates, the higher the percentile we should aim for.\nSometimes, issues become visible only at high percentiles (P99, P99.9) for a very high volume of requests.</p>\n\n<p><img alt=\"Response Time\" src=\"/img/articles/2024-06-04-rest-service-client-design-testing-monitoring/response_time.png\" /></p>\n\n<h4 id=\"throughput\">Throughput</h4>\n<p>Number of requests that our application sends to external services per second (RPS).\nAn auxiliary metric for the response time metric, where response time is always considered in the context of the generated traffic.</p>\n\n<p><img alt=\"Throughput\" src=\"/img/articles/2024-06-04-rest-service-client-design-testing-monitoring/rps.png\" /></p>\n\n<h4 id=\"error-rate\">Error Rate</h4>\n<p>Counting responses with codes 4xx/5xx.\nHere, we are interested in visualizing how many such errors occurred within a specific timeframe.\nThe number of errors we analyze depends on the overall traffic, therefore, both metrics should be expressed in the same units, usually requests per second.\nFor high traffic and a small number of errors, we can expect that the presented values will be on the order of thousandths.</p>\n\n<p><img alt=\"Error Rate\" src=\"/img/articles/2024-06-04-rest-service-client-design-testing-monitoring/errors.png\" /></p>\n\n<h2 id=\"summary\">Summary</h2>\n<p><a href=\"https://martinfowler.com/articles/microservices.html\">Microservices Architecture</a> relies heavily on network communication.\nThe most common method of communication is REST API calls between different services.\nWriting integration code involves more than just invoking a URL and parsing a response.\nLogs, error handling, and metrics are crucial for creating a stable and fault-tolerant microservices environment.\nDevelopers should have tools that take care of these aspects, enabling fast and reliable development of such integrations.\nHowever, tools alone are insufficient. We also need established rules and guidelines that allow us to write readable and maintainable code,\nboth in production and tests.</p>\n\n<h2 id=\"code-examples\">Code examples</h2>\n<p>To explore comprehensive examples, including the usage of WebClient and other HTTP clients, check out the GitHub <a href=\"https://github.com/Klimiec/webclients\">repository</a>.</p>\n","contentSnippet":"The purpose of this article is to present how to design, test, and monitor a REST service client.\nThe article includes a repository with clients written in Kotlin using various technologies such as WebClient,\nRestClient,\nKtor Client,\nRetrofit.\nIt demonstrates how to send and retrieve data from an external service, add a cache layer, and parse the received response into domain objects.\nMotivation\nWhy do we need objects in the project that encapsulate the HTTP clients we use?\nTo begin with, we want to separate the domain from technical details.\nThe way we retrieve/send data and handle errors, which can be quite complex in the case of HTTP clients, should not clutter business logic.\nNext, testability. Even if we do not use hexagonal architecture in our applications,\nit’s beneficial to separate the infrastructure from the service layer, as it improves testability.\nVerifying an HTTP service client is not a simple task and requires consideration of many cases — mainly at the integration level.\nHaving a separate “building block“ that encapsulates communication with the outside world makes testing much easier.\nFinally, reusability. A service client that has been written once can be successfully used in other projects.\nClient Design\nAs a case study, I will use an example implementation that utilizes WebClient for retrieving data from the Order Management Service,\nan example service that might appear in an e-commerce site such as Allegro.\nThe heart of our client is the executeHttpRequest method, which is responsible for executing the provided HTTP request, logging, and error handling.\nIt is not part of the WebClient library.\n\nclass OrderManagementServiceClient(\n    private val orderManagementServiceApi: OrderManagementServiceApi,\n    private val clientName: String\n) {\n    suspend fun getOrdersFor(clientId: ClientId): OrdersDto {\n        return executeHttpRequest(\n            initialLog = \"[$clientName] Get orders for a clientId= $clientId\",\n            request = { orderManagementServiceApi.getOrdersFor(clientId) },\n            successLog = \"[$clientName] Returned orders for a clientId= $clientId\",\n            failureMessage = \"[$clientName] Failed to get orders for clientId= $clientId\"\n        )\n    }\n}\n\n\n\nFull working example can be found here.\nClient name\nI like to name clients using the convention: name of the service we integrate with, plus the suffix Client.\nIn the case of integration with the Order Management Service, such a class will be named OrderManagementServiceClient.\nIf the technology we use employs an interface to describe the called REST API (RestClient, WebClient, Retrofit),\nwe can name such an interface OrderManagementServiceApi — following the general pattern of the service name with the suffix Api.\nThese names may seem intuitive and obvious, but without an established naming convention, we might end up with a project where\ndifferent integrations have the following suffixes: HttpClient, Facade, WebClient, Adapter, and Service.\nIt’s important to have a consistent convention and adhere to it throughout the project.\nAPI\nMethods of our clients should have names that reflect the communicative intention behind them.\nTo capture this intention, it is necessary to use a verb in the method’s name.\nTypically, the correct name will have a structure of verb + resource name, for example, getOrders  —  for methods that retrieve resources.\nIf we want to narrow down the number of returned resources using filters or return a particular resource, I recommend adding the suffix “For” before the list of parameters.\nTechnically, these parameters will be part of the query or path parameters.\n\nfun getOrdersFor(clientId: ClientId): OrdersDto\n\n\nFor methods responsible for creating resources, simply using the verb in the method name is enough,\nas the resource being passed as a parameter effectively conveys the intention of the method.\n\nfun publish(event: InvoiceCreatedEventDto)\n\n\nLogging\nWhen communicating with external service we’d like to log the beginning of the interaction, indicating our intention to fetch or send a resource,\nas well as its outcome. The outcome can be either a success, meaning receiving a response with a 2xx status code, or a failure.\nFailure can be signaled by status codes (3xx, 4xx, 5xx), resulting from the inability to deserialize the received response into an object,\nexceeding the response time, etc. Generally, many things can go wrong.\nDepending on the cause of failure, we may want to log the interaction result at different levels (warn/error).\nThere are critical errors that are worth distinguishing (error), and those that will occasionally occur (warn) and don’t require urgent intervention.\nTo filter logs related to a specific service while browsing through them, I like to include the client’s name within curly braces at the beginning of the logs.\nFor logging technical aspects of the communication, such as the URL called, HTTP method used, and response code,\nwe use filters (logRequestInfo, logResponseInfo) that are plugged in at the client configuration level in the createExternalServiceApi method.\n\ninline fun <reified T> createExternalServiceApi(\n    webClientBuilder: WebClient.Builder,\n    properties: ConnectionProperties\n): T =\n    webClientBuilder\n        .clientConnector(httpClient(properties))\n        .baseUrl(properties.baseUrl)\n        .defaultRequest { it.attribute(SERVICE_NAME, properties.clientName) }\n        .filter(logRequestInfo(properties.clientName))\n        .filter(logResponseInfo(properties.clientName))\n        .build()\n        .let { WebClientAdapter.create(it) }\n        .let { HttpServiceProxyFactory.builderFor(it).build() }\n        .createClient(T::class.java)\n\nfun logRequestInfo(clientName: String) = ExchangeFilterFunction.ofRequestProcessor { request ->\n    logger.info {\n        \"[$clientName] method=[${request.method().name()}] url=${request.url()}}\"\n    }\n    Mono.just(request)\n}\n\nfun logResponseInfo(clientName: String) = ExchangeFilterFunction.ofResponseProcessor { response ->\n    logger.info { \"[$clientName] service responded with a status code= ${response.statusCode()}\" }\n    Mono.just(response)\n}\n\n\nHere’s an example of logged interaction for successfully fetching a resource.\n\nTo prevent redundancy in logging code across multiple clients, it is centralized inside executeHttpRequest method.\nThe only thing the developer needs to do is to provide a business-oriented description for the beginning of the interaction and its outcome (parameters: initialLog, successLog, failureMessage).\nWhy do I emphasize logging so much?\nIsn’t it enough to log only errors?\nAfter all, we have metrics that inform us about the performance of our clients.\nMetrics won’t provide us with the details of the communication, but logs will.\nThese details can turn out to be crucial in the analysis of incidents, which may reveal, for example, incorrect data produced by our service.\nLogs are like backups. We find out if we have them and how valuable they are only when they are needed,\neither because the business team requests an analysis of a particular case or when resolving an incident.\nError handling\nWhen writing client code, we aim to highlight maximally how we send/retrieve data and hide the “noise“ that comes from error handling.\nIn the case of HTTP clients, error handling is quite extensive but generic enough that the resulting code can be written once and reused across all clients.\nIn our example, error handling mechanism is hidden inside executeHttpRequest method.\nIt consists of two things: logging and throwing custom exceptions that encapsulate technical exceptions thrown by the underlying HTTP client.\nWhat are the benefits of using custom exceptions? The very name of such a custom exception tells us exactly what went wrong.\nFor comparison, ExternalServiceIncorrectResponseBodyException seems to be more descriptive than DecodingException.\nThey also help group various technical exceptions that lead to the same cause, for example, an incorrect response object structure.\nAdditionally, based on these exceptions, visualizations can be created to show the state of our integration.\nFor example, we can create a table that will show how many exceptions of any given type were thrown by our clients within a specified period.\nHaving custom exceptions, we are 100% certain that these exceptions were thrown only by our clients.\nTesting\nStubs\nTo verify different scenarios of our HTTP client, it is necessary to appropriately stub the called endpoints in tests.\nFor this purpose, we will use the WireMock library.\nIt is quite important that the technical details of created stubs do not leak into the tests.\nThe test should describe the behavior being tested and encapsulate technical details.\nFor example, changing the accept/content-type header or making minor modifications to the called URL should not affect the test itself.\nTo achieve this, for each service for which we write a service client, we create an object of type StubBuilder.\nThe StubBuilder allows hiding the details of stubbing and verification behind a readable API.\nIt takes on the impact of changes to the called API, protecting our test from modification.\nIt fulfills a similar role to the Page Object Pattern in end-to-end tests for web apps.\n\norderManagementServiceStub.willReturnOrdersFor(clientId, response = ordersPlacedBySomeCustomer())\n\n\nStubBuilders for services that return data come in two flavors - internal and external.\n\nWhen testing a service client, we want to have great flexibility in simulating responses.\nTherefore, StubBuilders from the internal package will model response objects as a string. This allows us to simulate any scenario.\nIn end-to-end tests, where a given service is part of the bigger process, such flexibility is not necessary; in fact, it is not even recommended.\nTherefore, StubBuilders from the external package model responses using real objects.\nAll StubBuilders from the external packages are declared in the class ExternalServiceStubs, to which a reference is located in the base class for\nall integration tests, BaseIntegrationTest. This allows us to have very easy access to all external service stubs in our integration tests.\n\nstub.orderManagementService().willReturnOrdersFor(clientId, response = ordersPlacedBySomeCustomer())\n\n\nReading the code above, we immediately know which service is being interacted with (Order Management Service) and what will be returned from it (Orders).\nThe technical details of the stubbed endpoint have been hidden inside the StubBuilder object.\nTests should emphasize “what” and encapsulate “how.” This way, they can serve as documentation.\nTest Data\nThe data returned by our stubs can be prepared in three ways:\nRead the entire response from a file/string.\nPrepare the response using real objects used in the service for deserializing responses from called services.\nCreate a set of separate objects modeling the returned response from the service for testing purposes and use them to prepare the returned data.\nWhich option to choose?\nTo answer this question, we should analyze the advantages and disadvantages of each approach.\nOption A — read response from a file/string. Response creation is very fast and simple.\nIt allows verifying the contract between the client and the supplier (at least at the time of writing the test).\nImagine that during refactoring, one of the fields in the response object accidentally changes.\nIn such a case, client tests using this approach will detect the defect before the code reaches production.\n\n@Test\nfun `should return orders for a given clientId`(): Unit = runBlocking {\n        // given\n        val clientId = anyClientId()\n        orderManagementServiceStub.willReturnOrdersFor(clientId, response = ordersPlacedBySomeCustomer())\n\n        // when\n        val response: OrdersDto = orderManagementServiceClient.getOrdersFor(clientId)\n\n        // then\n        response shouldBe OrdersDto(listOf(OrderDto(\"7952a9ab-503c-4483-beca-32d081cc2446\")))\n}\n\n\nOn the other hand, keeping data in files/strings is difficult to maintain and reuse.\nProgrammers often copy entire files for new tests, introducing only minimal changes.\nThere is a problem with naming these files and refactoring them when the called service introduces an incompatible change.\nOption B — Use real response objects.\nIt allows writing one-line, readable assertions and maximally reusing already created data, especially using test data builders.\n\n    @Test\n    fun `should return orders for a given clientId`(): Unit = runBlocking {\n        // given\n        val clientId = anyClientId()\n        val clientOrders = OrderManagementServiceFixture.ordersPlacedBySomeCustomer()\n        orderManagementServiceStub.willReturnOrdersFor(clientId, response = clientOrders)\n\n        // when\n        val response: OrdersDto = orderManagementServiceClient.getOrdersFor(clientId)\n\n        // then\n        response shouldBe clientOrders\n    }\n\n\nHowever, accidental change of field name which results in the  contract violation between the client and supplier won’t be caught.\nAs a result, we might have perfectly tested communication in integration tests that will not work in production.\nOption C — create a set of separate response objects. It has all the advantages of options A and B, including maintainability, reusability, and\nverification of the contract between the client and the supplier. Unfortunately, maintaining a separate model for testing purposes comes with some overhead\nand requires discipline on the developers’ side, which can be challenging to maintain.\nWhich option to choose? Personally, I prefer a hybrid of options A and B.\nFor the purpose of testing the “happy path“ in client tests, I return a response that is entirely stored as a string (alternatively, it can be read from a file).\nSuch a test allows not only to verify the contract but also the correctness of deserializing the received response into a response object.\nIn other tests (cache, adapter, end-to-end), I create responses returned by the stubbed endpoint using production response objects.\nIt’s worthwhile to keep sample test data in dedicated classes, such as a Fixture class, for each integration (for example OrderManagementServiceFixture).\nThis allows the reuse of test data and enhances the readability of the tests themselves.\nTest Scenarios\nHappy Path\nFetching a resource — verification whether the client can retrieve data from the previously stubbed endpoint and deserialize it into a response object.\n\n@Test\nfun `should return orders for a given clientId`(): Unit = runBlocking {\n        // given\n        val clientId = anyClientId()\n        orderManagementServiceStub.willReturnOrdersFor(clientId, response = ordersPlacedBySomeCustomer())\n\n        // when\n        val response: OrdersDto = orderManagementServiceClient.getOrdersFor(clientId)\n\n        // then\n        response shouldBe OrdersDto(listOf(OrderDto(\"7952a9ab-503c-4483-beca-32d081cc2446\")))\n}\n\n\nAn essential part of the test for the “happy path“ is verification of the contract between the client and the supplier.\nThe ordersPlacedBySomeCustomer method returns a sample response guaranteed by the supplier (Order Management Service).\nOn the client side, in the assertion section, we check if this message has been correctly deserialized into a response object.\nInstead of comparing individual fields with the expected value, I highly recommend comparing entire objects (returned and expected).\nIt gives us confidence that all fields have been compared. In the case of regression, modern IDEs such as IntelliJ indicate exactly where the problem is.\n\nSending a resource — verification whether the client sends data to the specified URL in a format acceptable by the previously stubbed endpoint.\nIn the following example, I test publishing an event to Hermes, a message broker built on top of Kafka widely used at Allegro.\n\n@Test\nfun `should successfully publish InvoiceCreatedEvent`(): Unit = runBlocking {\n        // given\n        val invoiceCreatedEvent = HermesFixture.invoiceCreatedEvent()\n        stub.hermes().willAcceptInvoiceCreatedEvent()\n\n        // when\n        hermesClient.publish(invoiceCreatedEvent)\n\n        // then\n        stub.hermes().verifyInvoiceCreatedEventPublished(event = invoiceCreatedEvent)\n}\n\n\nStubbed endpoints for methods accepting request bodies (e.g., POST, PUT) should not verify the values of the received request body but only its structure.\n\nfun willAcceptInvoiceCreatedEvent() {\n    WireMock.stubFor(\n        invoiceCreatedEventTopic()\n            .withRequestBody(WireMock.matchingJsonPath(\"$.invoiceId\"))\n            .withRequestBody(WireMock.matchingJsonPath(\"$.orderId\"))\n            .withRequestBody(WireMock.matchingJsonPath(\"$.timestamp\"))\n            .willReturn(\n                WireMock.aResponse()\n                    .withFixedDelay(responseTime)\n                    .withStatus(HttpStatus.OK.value())\n            )\n    )\n}\n\n\nWe verify the content of the request body in the assertion section.\nHere, we also want to hide the technical aspects of assertions behind a method.\n\nstubs.hermes().verifyInvoiceCreatedEventPublished(event = invoiceCreatedEvent)\n\n\nfun verifyInvoiceCreatedEventPublished(event: InvoiceCreatedEventDto) {\n    WireMock.verify(\n        1,\n        WireMock.postRequestedFor(WireMock.urlPathEqualTo(INVOICE_CREATED_URL))\n            .withRequestBody(WireMock.matchingJsonPath(\"$.invoiceId\", WireMock.equalTo(event.invoiceId)))\n            .withRequestBody(WireMock.matchingJsonPath(\"$.orderId\", WireMock.equalTo(event.orderId)))\n            .withRequestBody(WireMock.matchingJsonPath(\"$.timestamp\", WireMock.equalTo(event.timestamp)))\n    )\n}\n\n\nCombining stubbing and request verification in one method is not recommended.\nCreating stubs in this way makes their usage less convenient since not every test requires detailed verification of what is being sent in the request body.\nThe vast majority of tests will stub the endpoint based on the principle:\naccept a given request as long as its structure is preserved and will verify hypotheses other than the content of the request body (mainly end-to-end tests).\nClient-side errors\nFor 4xx type errors, we want to verify the following cases:\nThe absence of the requested resource signaled by the response code 404 and a custom exception ExternalServiceResourceNotFoundException\nValidation error signaled by the response code 422 and a custom exception ExternalServiceRequestValidationException\nAny other 4xx type errors  should be cast to an ExternalServiceClientException\n\n@ParameterizedTest(name = \"{index}) http status code: {0}\")\n@MethodSource(\"clientErrors\")\nfun `when receive response with 4xx status code then throw exception`(\n    exceptionClass: Class<Exception>,\n    statusCode: Int,\n    responseBody: String?\n): Unit = runBlocking {\n        // given\n        val clientId = anyClientId()\n        orderManagementServiceStub.willReturnOrdersFor(clientId, status = statusCode, response = responseBody)\n\n        // when\n        val exception = shouldThrowAny {\n            orderManagementServiceClient.getOrdersFor(clientId)\n        }\n\n        // then\n        exception.javaClass shouldBeSameInstanceAs exceptionClass\n        exception.message shouldContain clientId.clientId.toString()\n        exception.message shouldContain properties.clientName\n}\n\n\nIn distributed systems, a 404 response code is quite common and may result from temporary inconsistency across the entire system.\nIts occurrence is signaled by the ExternalServiceResourceNotFoundException and a warning-level log.\nHere, we are more interested in the scale of occurrences, which is why we use metrics, than analyzing individual cases, hence we log such cases at the warning level.\nThe situation looks a bit different in the case of responses with a code of 422.\nIf the request is rejected due to validation errors, either our service has a defect and produces incorrect data,\nor we receive incorrect data from external services (which is why it’s crucial to log what we receive from external services).\nAlternatively, the error may be on the recipient side in the logic validating the received request. It’s worth analyzing each such case, which is why\nerrors of this type are logged at the error level and signaled by the ExternalServiceRequestValidationException.\nOther errors from the 4xx family occur less frequently.\nThey are all marked by the ExternalServiceClientException exception and logged at the error level.\nServer-side errors\nRegardless of the reason for a 5xx error, all of them are logged at the warn level because we have no control over them.\nThey are signaled by the ExternalServiceServerException exception. Similar to 404 errors, we are more interested in aggregate information\nabout the number of such errors rather than analyzing each case individually, hence the warn log level.\nIn tests, we consider two cases because the response from the service may or may not have a body.\nIf the response has a body, we want to log it.\nRead Timeout\nOur HTTP client should have a finite response timeout configured, so it’s worthwhile to write an integration test that verifies the client’s configuration.\nSimulating the delay of the stubbed endpoint can be achieved using the withFixedDelay method from wiremock.\n\n@Test\nfun `when service returns above timeout threshold then throw exception`(): Unit = runBlocking {\n        // given\n        val clientId = anyClientId()\n\n        orderManagementServiceStub\n            .withDelay(properties.readTimeout.toInt())\n            .willReturnOrdersFor(\n                clientId,\n                response = ordersPlacedBySomeCustomer()\n            )\n\n        // when\n        val exception = shouldThrow<ExternalServiceReadTimeoutException> {\n            orderManagementServiceClient.getOrdersFor(clientId)\n        }\n        // then\n        exception.message shouldContain clientId.clientId.toString()\n        exception.message shouldContain properties.clientName\n}\n\n\nNo, this is not testing properties in tests.\nThis test ensures that the configuration derived from properties has indeed been applied to the given client.\nEnsuring a response within a specified time frame might be part of non-functional requirements and requires verification.\nInvalid Response Body\nConsidered cases:\nResponse body does not contain required field.\nResponse body is empty.\nResponse has an incorrect format.\nErrors of this type are signaled through ExternalServiceIncorrectResponseBodyException and logged at the error level.\nMetrics\nWhen dealing with HTTP clients, it’s essential to monitor several aspects: response times, throughput, and error rates.\nTo differentiate metrics generated by different clients easily, it’s advisable to include a service.name tag with the respective client’s name.\nIn HTTP clients offered by the Spring framework (WebClient, RestClient),\nmetrics are enabled out-of-the-box if we create them using predefined builders (WebClient.Builder, RestClient.Builder).\nHowever, for other technologies, third-party solutions must be employed. In Allegro, we have a set of libraries that allows us to quickly create new\nHTTP clients in the most popular technologies that provide support for our infrastructure.\nAs a result, all clients generate consistent metrics by default tailored to our dashboards.\nResponse Time\nMeasuring the response time of HTTP clients allows us to identify bottlenecks.\nAt which percentile should we set such a metric?\nGenerally, the more requests a client generates, the higher the percentile we should aim for.\nSometimes, issues become visible only at high percentiles (P99, P99.9) for a very high volume of requests.\n\nThroughput\nNumber of requests that our application sends to external services per second (RPS).\nAn auxiliary metric for the response time metric, where response time is always considered in the context of the generated traffic.\n\nError Rate\nCounting responses with codes 4xx/5xx.\nHere, we are interested in visualizing how many such errors occurred within a specific timeframe.\nThe number of errors we analyze depends on the overall traffic, therefore, both metrics should be expressed in the same units, usually requests per second.\nFor high traffic and a small number of errors, we can expect that the presented values will be on the order of thousandths.\n\nSummary\nMicroservices Architecture relies heavily on network communication.\nThe most common method of communication is REST API calls between different services.\nWriting integration code involves more than just invoking a URL and parsing a response.\nLogs, error handling, and metrics are crucial for creating a stable and fault-tolerant microservices environment.\nDevelopers should have tools that take care of these aspects, enabling fast and reliable development of such integrations.\nHowever, tools alone are insufficient. We also need established rules and guidelines that allow us to write readable and maintainable code,\nboth in production and tests.\nCode examples\nTo explore comprehensive examples, including the usage of WebClient and other HTTP clients, check out the GitHub repository.","guid":"https://blog.allegro.tech/2024/06/rest-service-client-design-testing-monitoring.html","categories":["kotlin","testing","integration tests","rest","wiremock"],"isoDate":"2024-06-03T22:00:00.000Z"},{"title":"Unveiling bottlenecks of couchbase sub-documents operations","link":"https://blog.allegro.tech/2024/05/couchbase-subdocuments-bottleneck.html","pubDate":"Thu, 16 May 2024 00:00:00 +0200","authors":{"author":[{"name":["Tomasz Ziółkowski"],"photo":["https://blog.allegro.tech/img/authors/tomasz.ziolkowski.jpg"],"url":["https://blog.allegro.tech/authors/tomasz.ziolkowski"]}]},"content":"<p>This story shows our journey in addressing a platform stability issue related to autoscaling, which, paradoxically, added some additional overhead instead\nof reducing the load. A pivotal part of this narrative is how we used <a href=\"https://www.couchbase.com/\">Couchbase</a> — a distributed NoSQL database. If you find\nyourself intrigued by another enigmatic story involving Couchbase, don’t miss my\n<a href=\"/2024/02/couchbase-expired-docs-tuning.html\">blog post on tuning expired doc settings</a>.</p>\n\n<p>This post unfolds our quest to discover the root cause of the bottleneck. Initially, I will outline the symptoms of the issue. Subsequently, you will be\nintroduced to how Couchbase is utilized by the aforementioned service. Equipped with this knowledge, I will recount our attempts to diagnose the problem and\nindicate which observations raised our suspicions. The following section is dedicated to conducting benchmarks to verify our predictions using\na custom benchmarking tool. Ultimately, we will explore the source code of Couchbase to uncover how the problematic operations are executed. This section\naims to provide a deep understanding of Couchbase’s inner workings. I firmly believe that the knowledge shared in that part is its most valuable asset and may\nenable you to swiftly identify and address some of the potential performance issues when using Couchbase.</p>\n\n<h2 id=\"set-the-scene\">Set the scene</h2>\n\n<p>The service at the heart of the stability issues handles external HTTP traffic; for the purpose of this discussion, we’ll refer to it as\n“the gateway service”. The traffic routed to the gateway service reflects a pattern similar to organic traffic on <a href=\"https://allegro.tech\">Allegro</a>,\ncharacterized by significant fluctuations in throughput between day and night hours. To efficiently utilize resources, the gateway service employs an autoscaler\nto dynamically adjust the number of instances based on current demands. It’s also important to note that spawning a new instance involves a warm-up phase,\nduring which the instance retrieves some data from Couchbase to populate its in-memory cache. The gateway service relies on a Couchbase cluster\ncomprised of <strong>three</strong> nodes.</p>\n\n<h2 id=\"observations\">Observations</h2>\n\n<p>The team managing the service encountered a series of errors in communication with Couchbase. These errors indicated that 3-second timeouts occurred while\nfetching data from Couchbase:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>com. couchbase.client.core.error.UnambiguousTimeoutException: SubdocGetRequest, Reason: TIMEOUT {\n    \"cancelled\":true,\n    \"completed\":true,\n    ... IRRELEVANT METADATA ...\n    \"timeoutMs\":3000,\n    \"timings\":{\"totalMicros\":3004052}\n}\n</code></pre></div></div>\n<p>Interestingly, during these incidents, the Couchbase cluster did not exhibit high CPU or RAM usage. Furthermore, the traffic to Couchbase, measured in\noperations per second, was not exceptionally high. I mean that other Couchbase clients (different microservices) were generating an order of magnitude more\noperations per second without encountering stability issues.</p>\n\n<p>Additional key observations related to the issue include:</p>\n<ul>\n  <li>The instability primarily occurred during the service scaling-up process, initially triggered by the autoscaler.</li>\n  <li>Newly spawned instances were predominantly affected.</li>\n  <li>The issues were reported solely for operations directed to a specific node within the cluster.</li>\n  <li>A temporary mitigation of the problems involved repeatedly restarting the failing application instances.</li>\n  <li>There was a noticeable pattern on the driver side that preceded the widespread errors, including timeouts and the inability to send requests due to\na non-writable channel.</li>\n</ul>\n\n<h3 id=\"temporary-solution\">Temporary solution</h3>\n\n<p>As a temporary measure, the team overseeing the gateway service implemented the following workarounds:</p>\n\n<ul>\n  <li>Disabled certain types of requests to reduce the overall traffic volume directed to Couchbase.</li>\n  <li>Deactivated the autoscaler, and manually scaled up the application to manage peak traffic loads.</li>\n</ul>\n\n<p>These actions successfully halted the problems, but they also had repercussions, including business impacts and decreased efficiency in resource utilization.</p>\n\n<h2 id=\"raising-suspicions\">Raising suspicions</h2>\n\n<p>A pivotal aspect of this issue was the use of the <a href=\"https://docs.couchbase.com/go-sdk/2.4/concept-docs/subdocument-operations.html\">Couchbase sub-document API</a>\nwithin the gateway service, an approach not widely adopted across our internal microservice landscape, yet notable for its efficiency. According to\nthe documentation, this API significantly reduces traffic by allowing the fetching or mutating only specific parts of a Couchbase document.\nEssentially, it acts as a substitute for the concept of <a href=\"https://en.wikipedia.org/wiki/Projection_(relational_algebra)\">projection</a>, familiar to SQL users.</p>\n\n<p>In our investigation we closely examined the data collected on the Couchbase node, the operational dynamics of the gateway service’s cache, and insights\nfrom scrutinizing both the Couchbase driver and server code. We hypothesized that the crux of the problem might be linked to the cache warm-up process for\nnewly launched instances.</p>\n\n<p>Our investigation uncovered several indicators pointing toward the core of the issue:</p>\n\n<ul>\n  <li>A disproportionately large number of requests targeted a single document, inevitably directing traffic to a specific node.</li>\n  <li>The node hosting this heavily queried document corresponded with the one mentioned in timeout-related logs.</li>\n  <li>Instances that had been running for an extended period reported virtually no errors.</li>\n  <li>The volume of requests to Couchbase from the affected instances was extraordinarily high, not aligning with the number of requests registered on\nthe Couchbase side. This discrepancy suggested that if the cache warming process was at fault, the sheer magnitude of attempted requests was overwhelming\neven the local network buffers.</li>\n</ul>\n\n<p>However, these observations were merely pieces of a larger puzzle. We noticed a “snowball effect” where the system’s inability to process an initial set\nof requests for newly initiated instances triggered a cascade of failures. But the question remained: Why? What made these instances different,\nand why didn’t other clients on the same cluster experience similar issues? This was the crucial moment to take a closer examination of the sub-document\noperations to determine their efficiency and optimization.</p>\n\n<h2 id=\"lets-benchmark-it\">Let’s benchmark it</h2>\n\n<p>Despite an extensive search, we were unable to locate any tools capable of reliably testing our hypothesis—that sub-document operations executed during\nthe warm-up phase could significantly challenge Couchbase’s handling capabilities. As a result, we developed a simple tool and made it\n<a href=\"https://github.com/ziollek/cb-perf-tester\">available in on <em>GitHub</em></a>.\nThis tool is designed to create a sample document and then execute parallel sub-document fetch operations concurrently.\nThe sample document is structured as follows:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>{\n    \"key\": \"test-subdoc\",\n    \"data\": {\n        \"subkey-000000\": \"value-000000\",\n        \"subkey-000001\": \"value-000001\",\n        . . .\n        \"subkey-0….N\": \"value-0…..N\",\n    }\n}\n</code></pre></div></div>\n\n<p>The tool allows manipulating several knobs, which includes:</p>\n\n<ul>\n  <li><strong>Parallelism</strong>: Determines the number of parallel <a href=\"https://gobyexample.com/goroutines\">goroutines</a> that will attempt to fetch the same sub-documents concurrently.</li>\n  <li><strong>Document Size</strong>: Defined by the number of sub-keys, this directly affects the document’s binary size.</li>\n  <li><strong>Level of Search Difficulty</strong>: This essentially refers to how deep or how far into the main document the target sub-document is located.\nThe concept is illustrated in the diagram below:</li>\n</ul>\n\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-sub-difficulty.png\" alt=\"Difficulty of sub-document search\" /></p>\n\n<h3 id=\"caveats\">Caveats</h3>\n\n<p>The primary objective of this exercise was to identify potential bottlenecks, not to conduct a highly accurate performance assessment of Couchbase clusters.\nTherefore, we opted to run our experiments using a local Docker container (<code class=\"language-plaintext highlighter-rouge\">couchbase:community-6.6.0</code>), rather than on a dedicated, well-isolated cluster.\nWe acknowledge that hosting both the server and the benchmarking tool on the same machine may compromise the reliability and accuracy of the results.\nConsequently, we advise against using the findings from these tests for comprehensive assessments or comparisons with other technologies.</p>\n\n<h3 id=\"benchmark-steps\">Benchmark steps</h3>\n\n<p>The procedure for each experiment follows a similar framework, outlined in the steps below:</p>\n\n<ul>\n  <li><strong>Document Preparation</strong>: Initiate the document with the desired number of sub-documents, as dictated by one of the experimental variables.</li>\n  <li><strong>Document Storage</strong>: Save this document under a predetermined key.</li>\n  <li><strong>Goroutine Initialization</strong>: Launch a specified number of goroutines, the quantity of which is determined by another experimental variable.</li>\n  <li><strong>Fetch Operations</strong>: Each goroutine executes a series of fetch operations, which can be either regular (retrieving the entire sample document) or\nsub-document (accessing a set of sub-documents). It’s important to note that these requests are executed in a blocking manner; a new fetch operation is\nperformed only after the completion of the preceding one. In sub-document mode, the difficulty of the fetch operation is controlled through\nan experiment variable.</li>\n  <li><strong>Completion Wait</strong>: Await the termination of all goroutines.</li>\n  <li><strong>Results Reporting</strong>: Calculate and display the estimated RPS (requests per second).</li>\n</ul>\n\n<h3 id=\"estimate-baseline\">Estimate baseline</h3>\n\n<p>Prior to delving into sub-document operations, we sought to establish the maximum number of regular get operations that our local Couchbase Server instance\ncould handle. Through testing at various levels of concurrency, we determined the maximum throughput for our specific setup.\nIt was approximately 6,000 to 7,000 RPS, regardless of whether the requests were for small documents (less than 200 bytes)\nor for non-existent documents. These findings were further validated by the statistics available through the Couchbase UI.</p>\n\n<p>Benchmark Command: Attempting to fetch a non-existent document yielded a rate of <em>6388 RPS</em>.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>./cb-perf-tester regular  --parallel 200 --repeat 1000 --keys 5 --search-non-existent\nUsing config file: /Users/tomasz.ziolkowski/.cb-perf-tester.yaml\nbenchmark params: keys=5, not-existent=true, repeats=1000, parallel=200\nGenerated doc with subkeys: 5, byte size is: 195\n\nsearch for key: not-exists\n\nregular report: successes: 0, errors: 200000, duration: 31.306684977s, rps: 6388.411937, success rps: 0.000000\n</code></pre></div></div>\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-baseline-non-exitstent.png\" alt=\"Baseline - fetch a not-existent document\" /></p>\n\n<p>Benchmark Command: Fetching an existing small (195 bytes) document yielded a rate of <em>6341 rps</em>.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>./cb-perf-tester regular  --parallel 200 --repeat 1000 --keys 5\nUsing config file: /Users/tomasz.ziolkowski/.cb-perf-tester.yaml\nbenchmark params: keys=5, not-existent=false, repeats=1000, parallel=200\nGenerated doc with subkeys: 5, byte size is: 195\n\nsearch for key: test-regular\n\nregular report: successes: 200000, errors: 0, duration: 31.536538682s, rps: 6341.850068, success rps: 6341.850068\n</code></pre></div></div>\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-baseline-hits.png\" alt=\"Baseline - fetch an existing document\" /></p>\n\n<h3 id=\"testing-scenarios\">Testing scenarios</h3>\n\n<p>Now that we have a baseline for comparison, we’re set to evaluate it against the outcomes of various scenarios. To ensure the tests are comparable,\nwe’ll maintain constant parallelism across all tests, specifically using 200 goroutines. The variables that will differ across scenarios include:</p>\n\n<ul>\n  <li><strong>Total Number of Sub-Documents</strong>: This determines the overall size of the sample document, as the document’s size is directly related to the number\nof sub-documents it contains.</li>\n  <li><strong>Number of Searched Sub-Documents</strong>: This refers to how many sub-paths within the sample document will be targeted in a single fetch operation.</li>\n  <li><strong>Search Difficulty</strong>: This aspect dictates the difficulty of locating the searched sub-paths within the document.</li>\n</ul>\n\n<p>It’s important to highlight that in each scenario, we will manipulate only one variable at a time while keeping the other parameters constant.</p>\n\n<h4 id=\"scenario-a-the-impact-of-document-size-on-performance\">Scenario A: The impact of document size on performance</h4>\n\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-doc-size-vs-performance-all.png\" alt=\"Document size vs performance - aggregated\" /></p>\n\n<p>To better visualize the impact, let’s look at the diagram for HARD scenario:</p>\n\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-doc-size-vs-performance-hard.png\" alt=\"Document size vs performance - hard\" /></p>\n\n<p>It is clearly visible that there is a strict correlation between document size and performance.</p>\n\n<h4 id=\"scenario-b-the-impact-of-the-number-of-searched-sub-documents-on-performance\">Scenario B: The impact of the number of searched sub-documents on performance</h4>\n\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-subdocs-num-vs-performance-all.png\" alt=\"Number of searched sub-documents vs performance - aggregated\" /></p>\n\n<p>To better visualize the impact, let’s look at the diagram for HARD scenario:</p>\n\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-subdocs-num-vs-performance-hard.png\" alt=\"Number of searched sub-documents vs performance - hard\" /></p>\n\n<p>As observed in the previous scenario, there is a clear correlation between the number of sub-documents accessed and the system’s performance.</p>\n\n<h2 id=\"further-analysis\">Further analysis</h2>\n\n<p>Given the evident correlation between the document size/number of queried sub-paths and performance degradation, we delve into the mechanics to understand\nthe root cause of these test results. A notable observation during the tests relates to CPU utilization within the Docker environment, where, despite having\nsix cores available, only a single core was actively utilized. Intriguingly, this usage was monopolized by a single thread (<code class=\"language-plaintext highlighter-rouge\">mc:worker_X</code>).\nThis phenomenon directly stems from Couchbase’s handling of Key-Value (KV) connections. By default, the Couchbase driver initiates only a single connection to\neach cluster node for KV operations. However, this configuration can be adjusted in certain Software Development Kits (SDKs)—the Java SDK,\nfor instance, allows modification through <a href=\"https://docs.couchbase.com/java-sdk/current/ref/client-settings.html#io-options\">IoConfig.numKvConnections</a>.</p>\n\n<p>When a connection is established, Couchbase assigns it to\na <a href=\"https://github.com/couchbase/kv_engine/blob/master/docs/in-depth/C10k.md#current-approach-why-not-both\">specific worker thread</a>) using\na <a href=\"https://github.com/couchbase/kv_engine/blob/master/daemon/front_end_thread.h#L84\">Round-Robin (RR)</a>) algorithm. As a result, the Couchbase Server does not\nfully utilize available CPU power for a single connection, even when a lot of resources are free. This behavior can be seen as beneficial, serving to mitigate\nthe <a href=\"https://en.wikipedia.org/wiki/Cloud_computing_issues#Performance_interference_and_noisy_neighbors\">“noisy neighbor” effect</a>, provided there are sufficient\nspare cores available to manage new connections. This mechanism ensures balanced resource use across connections, as illustrated in the diagram below:</p>\n\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-dispatch-ok.png\" alt=\"Handling connections - free cores scenario\" /></p>\n\n<p>Conversely, one may encounter fluctuating performance due to instances of misfortune, where if other clients significantly burden certain worker threads,\nand your connection is allocated to one of these overloaded threads, performance inconsistencies arise. This scenario, where a client experiences higher than\nusual response times due to an imbalanced distribution of workload across worker threads, is depicted in the diagram below:</p>\n\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-dispatch-bad.png\" alt=\"Handling connections - overloaded core scenario\" /></p>\n\n<p>This behavior explains the apparent paradox observed during the stability issues: the Couchbase node showed no clear signs of being overloaded, yet certain\nanomalous symptoms were present, such as a metric indicating the minimum <a href=\"https://en.wikipedia.org/wiki/Idle_(CPU)\">idle</a> percentage across all cores plummeting\nto 0% during the disturbances. This leaves no doubt that operations on sub-documents have the potential to overburden worker threads within\nthe Couchbase Server. With this understanding we are now ready to delve deeper into the root cause of such behavior.</p>\n\n<h3 id=\"what-documentation-says\">What documentation says</h3>\n\n<p>The documentation for Couchbase, housed alongside the server’s source code, is notably comprehensive, including a dedicated section on\n<a href=\"https://github.com/couchbase/kv_engine/blob/master/docs/SubDocument.md\">sub-documents</a>. However, it falls short of providing detailed insights into\nthe internal workings of these operations. Additionally, there is a lack of discussion on the performance implications of sub-document operations,\nwith only a few remarks on data typing and float numbers that do not apply to the cases we tested. Attempts to find answers on the Couchbase forum were also\nunfruitful, yielding no substantial information on the performance issues we encountered. Despite this, there is confirmation from others in the community who\nhave observed\n<a href=\"https://www.couchbase.com/forums/t/frequent-timeouts-and-requests-over-threshold-for-subdocgetrequests-via-reactive-java-sdk/30211\">similar problems</a>.</p>\n\n<h3 id=\"what-source-code-says\">What source code says</h3>\n\n<p>A thorough analysis of the codebase reveals a definitive cause for the performance degradation observed. It’s important to note that Couchbase requires\n<a href=\"https://docs.couchbase.com/server/current/learn/buckets-memory-and-storage/compression.html\">decompression</a> of a document for any lookup or manipulation\noperation, whether the document is retrieved from RAM or disk. Let’s start from a point where Couchbase starts doing\n<a href=\"https://github.com/couchbase/kv_engine/blob/cf020888d2e09b132a02c90b99e160044ddabb11/daemon/subdocument.cc#L568\">lookups</a> on a decompressed object:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// 2. Perform each of the operations on document.\nfor (auto&amp; op : operations) {\n    switch (op.traits.scope) {\n    case CommandScope::SubJSON:\n        if (cb::mcbp::datatype::is_json(doc_datatype)) {\n            // Got JSON, perform the operation.\n            op.status = subdoc_operate_one_path(context, op, current.view);\n        }\n</code></pre></div></div>\n<p>A critical observation from our analysis is that each operation (lookup) is executed sequentially through the invocation of <code class=\"language-plaintext highlighter-rouge\">subdoc_operate_one_path</code>.\nTo understand the performance implications, let’s examine\n<a href=\"https://github.com/couchbase/kv_engine/blob/cf020888d2e09b132a02c90b99e160044ddabb11/daemon/subdocument.cc#L413C5-L414C76\">the implementation</a> of this lookup\nprocess:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// ... and execute it.\nconst auto subdoc_res = op.op_exec(spec.path.data(), spec.path.size());\n</code></pre></div></div>\n\n<p>The Investigation reveals that the lookup functionality is powered by a specialized library,\n<a href=\"https://github.com/couchbase/subjson/blob/4b93d966f791209209a0825e46f7049df0673e8f/subdoc/operations.cc#L757\">library <code class=\"language-plaintext highlighter-rouge\">subjson</code></a>, which in turn\n<a href=\"https://github.com/couchbase/subjson/blob/4b93d966f791209209a0825e46f7049df0673e8f/subdoc/match.cc#L371\">uses</a>\nthe <a href=\"https://github.com/mnunberg/jsonsl\"><code class=\"language-plaintext highlighter-rouge\">jsonsl</code> library</a> for parsing JSON in a streaming manner. An enlightening piece of information about performance can be found in\nthe README of the <code class=\"language-plaintext highlighter-rouge\">subjson</code> library, which is integral to Couchbase’s solution. The direct quote from the README is as follows:</p>\n\n<blockquote>\n  <p>Because the library does not actually build a JSON tree, the memory usage and CPU consumption is constant, regardless of the size of the actual JSON object\nbeing operated upon, and thus the only variable performance factor is the amount of actual time the library can seek to the location in the document to\nbe modified.</p>\n\n  <p>On a single Xeon E5520 core, this library can process about 150MB/s-300MB/s of JSON. This processing includes the search logic as well as any\nreplacement logic.</p>\n</blockquote>\n\n<p>This analysis clearly demonstrates that lookups targeting paths situated towards the end of a document are markedly slower compared to those aimed\nat the beginning. Moreover, each sequential lookup <strong>needs to repeat document parsing</strong>. The impact of this implementation on performance is significant.\nFor a more intuitive understanding of these effects, please refer to the diagram below:</p>\n\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-processing-sub-documents.png\" alt=\"Processing sub-documents in details\" /></p>\n\n<p>The performance characteristics we’ve outlined align with the outcomes observed in our experiments. To illustrate, consider a detailed examination of\na single <code class=\"language-plaintext highlighter-rouge\">HARD</code> test scenario—specifically, a case where the sub-documents targeted for search were positioned towards the end of the JSON document:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>./cb-perf-tester subdoc  --parallel 200 --repeat 50 --search-keys 10 --difficulty hard\nUsing config file: /Users/tomasz.ziolkowski/.cb-perf-tester.yaml\nbenchmark params: keys=10000, level=Hard, search-keys=10, repeats=50, parallel=200\nGenerated doc with subkeys: 10000, byte size is: 310043\n\nsearch for subkeys [level=Hard]: [data.subkey-009999 data.subkey-009998 data.subkey-009997 data.subkey-009996 data.subkey-009995 data.subkey-009994 data.subkey-009993 data.subkey-009992 data.subkey-009991 data.subkey-009990]\n\nsubdoc report: successes: 10000, errors: 0, duration: 1m19.784865193s, rps: 125.337055, success rps: 125.337055\n</code></pre></div></div>\n\n<p>By multiplying the size of the document by the number of sub-documents queried, we can determine the total stream size that the library must process, which,\nin this case, approximates to <code class=\"language-plaintext highlighter-rouge\">~3MB</code>. Further multiplying this figure by the RPS gives us an insight into the overall throughput of\nthe stream processing:</p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">3MB x 125 RPS ~= 375 MBps</code></p>\n\n<p>The calculated throughput slightly exceeds the benchmarks outlined in the README. Moreover, the estimated throughput remains nearly constant across\nvarious tests. For a comprehensive view of these findings, please refer to the diagram below, which displays the estimated throughput for tests conducted under\nthe HARD level with a document size of approximately <code class=\"language-plaintext highlighter-rouge\">300KB</code>:</p>\n\n<p><img src=\"/img/articles/2024-05-16-couchbase-subdocuments-bottleneck/cb-estimated-subdocs-throughput.png\" alt=\"Estimated throughput\" /></p>\n\n<h2 id=\"conclusions\">Conclusions</h2>\n\n<p>The Couchbase sub-document API, while designed to optimize network throughput, introduces significant performance trade-offs. Notably, even\n<em>under optimal conditions</em>, operations on sub-documents are noticeably slower compared to regular get operations fetching\nsmall documents—evidenced by a comparison of the baseline performance; approximately 4-5k RPS for sub-document operations vs. 6-7k RPS for\nregular get operations.</p>\n\n<p>The method Couchbase employs for executing lookups directly influences performance, manifesting declines as either the document size increases or the number of\nlookups per request raises. This slowdown affects all requests over the same connection due to the high CPU demand of sub-document lookup operations.\nParticularly in environments utilizing reactive/asynchronous clients, this can overload the Couchbase worker thread, leading to a halt in request servicing.\nImportantly, an overloaded worker may manage connections from multiple clients, potentially exacerbating the “noisy neighbor” effect.</p>\n\n<p>While there are strategies to mitigate these issues from the perspective of a client, such as the gateway service, these considerations warrant\na separate discussion, which I plan to address in a future blog post.</p>\n","contentSnippet":"This story shows our journey in addressing a platform stability issue related to autoscaling, which, paradoxically, added some additional overhead instead\nof reducing the load. A pivotal part of this narrative is how we used Couchbase — a distributed NoSQL database. If you find\nyourself intrigued by another enigmatic story involving Couchbase, don’t miss my\nblog post on tuning expired doc settings.\nThis post unfolds our quest to discover the root cause of the bottleneck. Initially, I will outline the symptoms of the issue. Subsequently, you will be\nintroduced to how Couchbase is utilized by the aforementioned service. Equipped with this knowledge, I will recount our attempts to diagnose the problem and\nindicate which observations raised our suspicions. The following section is dedicated to conducting benchmarks to verify our predictions using\na custom benchmarking tool. Ultimately, we will explore the source code of Couchbase to uncover how the problematic operations are executed. This section\naims to provide a deep understanding of Couchbase’s inner workings. I firmly believe that the knowledge shared in that part is its most valuable asset and may\nenable you to swiftly identify and address some of the potential performance issues when using Couchbase.\nSet the scene\nThe service at the heart of the stability issues handles external HTTP traffic; for the purpose of this discussion, we’ll refer to it as\n“the gateway service”. The traffic routed to the gateway service reflects a pattern similar to organic traffic on Allegro,\ncharacterized by significant fluctuations in throughput between day and night hours. To efficiently utilize resources, the gateway service employs an autoscaler\nto dynamically adjust the number of instances based on current demands. It’s also important to note that spawning a new instance involves a warm-up phase,\nduring which the instance retrieves some data from Couchbase to populate its in-memory cache. The gateway service relies on a Couchbase cluster\ncomprised of three nodes.\nObservations\nThe team managing the service encountered a series of errors in communication with Couchbase. These errors indicated that 3-second timeouts occurred while\nfetching data from Couchbase:\n\ncom. couchbase.client.core.error.UnambiguousTimeoutException: SubdocGetRequest, Reason: TIMEOUT {\n    \"cancelled\":true,\n    \"completed\":true,\n    ... IRRELEVANT METADATA ...\n    \"timeoutMs\":3000,\n    \"timings\":{\"totalMicros\":3004052}\n}\n\n\nInterestingly, during these incidents, the Couchbase cluster did not exhibit high CPU or RAM usage. Furthermore, the traffic to Couchbase, measured in\noperations per second, was not exceptionally high. I mean that other Couchbase clients (different microservices) were generating an order of magnitude more\noperations per second without encountering stability issues.\nAdditional key observations related to the issue include:\nThe instability primarily occurred during the service scaling-up process, initially triggered by the autoscaler.\nNewly spawned instances were predominantly affected.\nThe issues were reported solely for operations directed to a specific node within the cluster.\nA temporary mitigation of the problems involved repeatedly restarting the failing application instances.\nThere was a noticeable pattern on the driver side that preceded the widespread errors, including timeouts and the inability to send requests due to\na non-writable channel.\nTemporary solution\nAs a temporary measure, the team overseeing the gateway service implemented the following workarounds:\nDisabled certain types of requests to reduce the overall traffic volume directed to Couchbase.\nDeactivated the autoscaler, and manually scaled up the application to manage peak traffic loads.\nThese actions successfully halted the problems, but they also had repercussions, including business impacts and decreased efficiency in resource utilization.\nRaising suspicions\nA pivotal aspect of this issue was the use of the Couchbase sub-document API\nwithin the gateway service, an approach not widely adopted across our internal microservice landscape, yet notable for its efficiency. According to\nthe documentation, this API significantly reduces traffic by allowing the fetching or mutating only specific parts of a Couchbase document.\nEssentially, it acts as a substitute for the concept of projection, familiar to SQL users.\nIn our investigation we closely examined the data collected on the Couchbase node, the operational dynamics of the gateway service’s cache, and insights\nfrom scrutinizing both the Couchbase driver and server code. We hypothesized that the crux of the problem might be linked to the cache warm-up process for\nnewly launched instances.\nOur investigation uncovered several indicators pointing toward the core of the issue:\nA disproportionately large number of requests targeted a single document, inevitably directing traffic to a specific node.\nThe node hosting this heavily queried document corresponded with the one mentioned in timeout-related logs.\nInstances that had been running for an extended period reported virtually no errors.\nThe volume of requests to Couchbase from the affected instances was extraordinarily high, not aligning with the number of requests registered on\nthe Couchbase side. This discrepancy suggested that if the cache warming process was at fault, the sheer magnitude of attempted requests was overwhelming\neven the local network buffers.\nHowever, these observations were merely pieces of a larger puzzle. We noticed a “snowball effect” where the system’s inability to process an initial set\nof requests for newly initiated instances triggered a cascade of failures. But the question remained: Why? What made these instances different,\nand why didn’t other clients on the same cluster experience similar issues? This was the crucial moment to take a closer examination of the sub-document\noperations to determine their efficiency and optimization.\nLet’s benchmark it\nDespite an extensive search, we were unable to locate any tools capable of reliably testing our hypothesis—that sub-document operations executed during\nthe warm-up phase could significantly challenge Couchbase’s handling capabilities. As a result, we developed a simple tool and made it\navailable in on GitHub.\nThis tool is designed to create a sample document and then execute parallel sub-document fetch operations concurrently.\nThe sample document is structured as follows:\n\n{\n    \"key\": \"test-subdoc\",\n    \"data\": {\n        \"subkey-000000\": \"value-000000\",\n        \"subkey-000001\": \"value-000001\",\n        . . .\n        \"subkey-0….N\": \"value-0…..N\",\n    }\n}\n\n\nThe tool allows manipulating several knobs, which includes:\nParallelism: Determines the number of parallel goroutines that will attempt to fetch the same sub-documents concurrently.\nDocument Size: Defined by the number of sub-keys, this directly affects the document’s binary size.\nLevel of Search Difficulty: This essentially refers to how deep or how far into the main document the target sub-document is located.\nThe concept is illustrated in the diagram below:\n\nCaveats\nThe primary objective of this exercise was to identify potential bottlenecks, not to conduct a highly accurate performance assessment of Couchbase clusters.\nTherefore, we opted to run our experiments using a local Docker container (couchbase:community-6.6.0), rather than on a dedicated, well-isolated cluster.\nWe acknowledge that hosting both the server and the benchmarking tool on the same machine may compromise the reliability and accuracy of the results.\nConsequently, we advise against using the findings from these tests for comprehensive assessments or comparisons with other technologies.\nBenchmark steps\nThe procedure for each experiment follows a similar framework, outlined in the steps below:\nDocument Preparation: Initiate the document with the desired number of sub-documents, as dictated by one of the experimental variables.\nDocument Storage: Save this document under a predetermined key.\nGoroutine Initialization: Launch a specified number of goroutines, the quantity of which is determined by another experimental variable.\nFetch Operations: Each goroutine executes a series of fetch operations, which can be either regular (retrieving the entire sample document) or\nsub-document (accessing a set of sub-documents). It’s important to note that these requests are executed in a blocking manner; a new fetch operation is\nperformed only after the completion of the preceding one. In sub-document mode, the difficulty of the fetch operation is controlled through\nan experiment variable.\nCompletion Wait: Await the termination of all goroutines.\nResults Reporting: Calculate and display the estimated RPS (requests per second).\nEstimate baseline\nPrior to delving into sub-document operations, we sought to establish the maximum number of regular get operations that our local Couchbase Server instance\ncould handle. Through testing at various levels of concurrency, we determined the maximum throughput for our specific setup.\nIt was approximately 6,000 to 7,000 RPS, regardless of whether the requests were for small documents (less than 200 bytes)\nor for non-existent documents. These findings were further validated by the statistics available through the Couchbase UI.\nBenchmark Command: Attempting to fetch a non-existent document yielded a rate of 6388 RPS.\n\n./cb-perf-tester regular  --parallel 200 --repeat 1000 --keys 5 --search-non-existent\nUsing config file: /Users/tomasz.ziolkowski/.cb-perf-tester.yaml\nbenchmark params: keys=5, not-existent=true, repeats=1000, parallel=200\nGenerated doc with subkeys: 5, byte size is: 195\n\nsearch for key: not-exists\n\nregular report: successes: 0, errors: 200000, duration: 31.306684977s, rps: 6388.411937, success rps: 0.000000\n\n\n\nBenchmark Command: Fetching an existing small (195 bytes) document yielded a rate of 6341 rps.\n\n./cb-perf-tester regular  --parallel 200 --repeat 1000 --keys 5\nUsing config file: /Users/tomasz.ziolkowski/.cb-perf-tester.yaml\nbenchmark params: keys=5, not-existent=false, repeats=1000, parallel=200\nGenerated doc with subkeys: 5, byte size is: 195\n\nsearch for key: test-regular\n\nregular report: successes: 200000, errors: 0, duration: 31.536538682s, rps: 6341.850068, success rps: 6341.850068\n\n\n\nTesting scenarios\nNow that we have a baseline for comparison, we’re set to evaluate it against the outcomes of various scenarios. To ensure the tests are comparable,\nwe’ll maintain constant parallelism across all tests, specifically using 200 goroutines. The variables that will differ across scenarios include:\nTotal Number of Sub-Documents: This determines the overall size of the sample document, as the document’s size is directly related to the number\nof sub-documents it contains.\nNumber of Searched Sub-Documents: This refers to how many sub-paths within the sample document will be targeted in a single fetch operation.\nSearch Difficulty: This aspect dictates the difficulty of locating the searched sub-paths within the document.\nIt’s important to highlight that in each scenario, we will manipulate only one variable at a time while keeping the other parameters constant.\nScenario A: The impact of document size on performance\n\nTo better visualize the impact, let’s look at the diagram for HARD scenario:\n\nIt is clearly visible that there is a strict correlation between document size and performance.\nScenario B: The impact of the number of searched sub-documents on performance\n\nTo better visualize the impact, let’s look at the diagram for HARD scenario:\n\nAs observed in the previous scenario, there is a clear correlation between the number of sub-documents accessed and the system’s performance.\nFurther analysis\nGiven the evident correlation between the document size/number of queried sub-paths and performance degradation, we delve into the mechanics to understand\nthe root cause of these test results. A notable observation during the tests relates to CPU utilization within the Docker environment, where, despite having\nsix cores available, only a single core was actively utilized. Intriguingly, this usage was monopolized by a single thread (mc:worker_X).\nThis phenomenon directly stems from Couchbase’s handling of Key-Value (KV) connections. By default, the Couchbase driver initiates only a single connection to\neach cluster node for KV operations. However, this configuration can be adjusted in certain Software Development Kits (SDKs)—the Java SDK,\nfor instance, allows modification through IoConfig.numKvConnections.\nWhen a connection is established, Couchbase assigns it to\na specific worker thread) using\na Round-Robin (RR)) algorithm. As a result, the Couchbase Server does not\nfully utilize available CPU power for a single connection, even when a lot of resources are free. This behavior can be seen as beneficial, serving to mitigate\nthe “noisy neighbor” effect, provided there are sufficient\nspare cores available to manage new connections. This mechanism ensures balanced resource use across connections, as illustrated in the diagram below:\n\nConversely, one may encounter fluctuating performance due to instances of misfortune, where if other clients significantly burden certain worker threads,\nand your connection is allocated to one of these overloaded threads, performance inconsistencies arise. This scenario, where a client experiences higher than\nusual response times due to an imbalanced distribution of workload across worker threads, is depicted in the diagram below:\n\nThis behavior explains the apparent paradox observed during the stability issues: the Couchbase node showed no clear signs of being overloaded, yet certain\nanomalous symptoms were present, such as a metric indicating the minimum idle percentage across all cores plummeting\nto 0% during the disturbances. This leaves no doubt that operations on sub-documents have the potential to overburden worker threads within\nthe Couchbase Server. With this understanding we are now ready to delve deeper into the root cause of such behavior.\nWhat documentation says\nThe documentation for Couchbase, housed alongside the server’s source code, is notably comprehensive, including a dedicated section on\nsub-documents. However, it falls short of providing detailed insights into\nthe internal workings of these operations. Additionally, there is a lack of discussion on the performance implications of sub-document operations,\nwith only a few remarks on data typing and float numbers that do not apply to the cases we tested. Attempts to find answers on the Couchbase forum were also\nunfruitful, yielding no substantial information on the performance issues we encountered. Despite this, there is confirmation from others in the community who\nhave observed\nsimilar problems.\nWhat source code says\nA thorough analysis of the codebase reveals a definitive cause for the performance degradation observed. It’s important to note that Couchbase requires\ndecompression of a document for any lookup or manipulation\noperation, whether the document is retrieved from RAM or disk. Let’s start from a point where Couchbase starts doing\nlookups on a decompressed object:\n\n// 2. Perform each of the operations on document.\nfor (auto& op : operations) {\n    switch (op.traits.scope) {\n    case CommandScope::SubJSON:\n        if (cb::mcbp::datatype::is_json(doc_datatype)) {\n            // Got JSON, perform the operation.\n            op.status = subdoc_operate_one_path(context, op, current.view);\n        }\n\n\nA critical observation from our analysis is that each operation (lookup) is executed sequentially through the invocation of subdoc_operate_one_path.\nTo understand the performance implications, let’s examine\nthe implementation of this lookup\nprocess:\n\n// ... and execute it.\nconst auto subdoc_res = op.op_exec(spec.path.data(), spec.path.size());\n\n\nThe Investigation reveals that the lookup functionality is powered by a specialized library,\nlibrary subjson, which in turn\nuses\nthe jsonsl library for parsing JSON in a streaming manner. An enlightening piece of information about performance can be found in\nthe README of the subjson library, which is integral to Couchbase’s solution. The direct quote from the README is as follows:\nBecause the library does not actually build a JSON tree, the memory usage and CPU consumption is constant, regardless of the size of the actual JSON object\nbeing operated upon, and thus the only variable performance factor is the amount of actual time the library can seek to the location in the document to\nbe modified.\nOn a single Xeon E5520 core, this library can process about 150MB/s-300MB/s of JSON. This processing includes the search logic as well as any\nreplacement logic.\nThis analysis clearly demonstrates that lookups targeting paths situated towards the end of a document are markedly slower compared to those aimed\nat the beginning. Moreover, each sequential lookup needs to repeat document parsing. The impact of this implementation on performance is significant.\nFor a more intuitive understanding of these effects, please refer to the diagram below:\n\nThe performance characteristics we’ve outlined align with the outcomes observed in our experiments. To illustrate, consider a detailed examination of\na single HARD test scenario—specifically, a case where the sub-documents targeted for search were positioned towards the end of the JSON document:\n\n./cb-perf-tester subdoc  --parallel 200 --repeat 50 --search-keys 10 --difficulty hard\nUsing config file: /Users/tomasz.ziolkowski/.cb-perf-tester.yaml\nbenchmark params: keys=10000, level=Hard, search-keys=10, repeats=50, parallel=200\nGenerated doc with subkeys: 10000, byte size is: 310043\n\nsearch for subkeys [level=Hard]: [data.subkey-009999 data.subkey-009998 data.subkey-009997 data.subkey-009996 data.subkey-009995 data.subkey-009994 data.subkey-009993 data.subkey-009992 data.subkey-009991 data.subkey-009990]\n\nsubdoc report: successes: 10000, errors: 0, duration: 1m19.784865193s, rps: 125.337055, success rps: 125.337055\n\n\nBy multiplying the size of the document by the number of sub-documents queried, we can determine the total stream size that the library must process, which,\nin this case, approximates to ~3MB. Further multiplying this figure by the RPS gives us an insight into the overall throughput of\nthe stream processing:\n3MB x 125 RPS ~= 375 MBps\nThe calculated throughput slightly exceeds the benchmarks outlined in the README. Moreover, the estimated throughput remains nearly constant across\nvarious tests. For a comprehensive view of these findings, please refer to the diagram below, which displays the estimated throughput for tests conducted under\nthe HARD level with a document size of approximately 300KB:\n\nConclusions\nThe Couchbase sub-document API, while designed to optimize network throughput, introduces significant performance trade-offs. Notably, even\nunder optimal conditions, operations on sub-documents are noticeably slower compared to regular get operations fetching\nsmall documents—evidenced by a comparison of the baseline performance; approximately 4-5k RPS for sub-document operations vs. 6-7k RPS for\nregular get operations.\nThe method Couchbase employs for executing lookups directly influences performance, manifesting declines as either the document size increases or the number of\nlookups per request raises. This slowdown affects all requests over the same connection due to the high CPU demand of sub-document lookup operations.\nParticularly in environments utilizing reactive/asynchronous clients, this can overload the Couchbase worker thread, leading to a halt in request servicing.\nImportantly, an overloaded worker may manage connections from multiple clients, potentially exacerbating the “noisy neighbor” effect.\nWhile there are strategies to mitigate these issues from the perspective of a client, such as the gateway service, these considerations warrant\na separate discussion, which I plan to address in a future blog post.","guid":"https://blog.allegro.tech/2024/05/couchbase-subdocuments-bottleneck.html","categories":["tech","couchbase","sub-documents","performance","bottlenecks"],"isoDate":"2024-05-15T22:00:00.000Z"}],"jobs":[{"id":"743999994499625","name":"Software Engineer (.NET) - Product Team - Allegro Pay","uuid":"a427e05d-f51e-44a3-9e18-27f5c2fa9c80","jobAdId":"57040109-b330-495b-aa0d-247de3ea2066","defaultJobAd":false,"refNumber":"REF4748E","company":{"identifier":"Allegro","name":"Allegro"},"releasedDate":"2024-06-17T07:58:16.666Z","location":{"city":"Warsaw","region":"Masovian Voivodeship","country":"pl","remote":false,"latitude":"52.2296756","longitude":"21.0122287"},"industry":{"id":"internet","label":"Internet"},"department":{"id":"2572770","label":"IT - Software Development"},"function":{"id":"information_technology","label":"Information Technology"},"typeOfEmployment":{"id":"permanent","label":"Full-time"},"experienceLevel":{"id":"mid_senior_level","label":"Mid-Senior Level"},"customField":[{"fieldId":"61583054f15cea434e0be36f","fieldLabel":"Career Level","valueId":"3c97f53f-19c2-4a25-9eb1-513f9fb38b80","valueLabel":"3-5"},{"fieldId":"61582f70e72a6b6d239c9857","fieldLabel":"Area","valueId":"76599a72-f283-4550-9303-52e2e0eb6e32","valueLabel":"Technology"},{"fieldId":"58c15608e4b01d4b19ddf790","fieldLabel":"Recruitment Process","valueId":"b3da614a-1ddb-441b-a557-5acfdb6fcb90","valueLabel":"NEW Technology CL 1-6"},{"fieldId":"6406f92e638cbb2f415a94a9","fieldLabel":"Job Area","valueId":"e8731ea4-48a9-476d-ab1d-9a40eb3426f1","valueLabel":"Technology"},{"fieldId":"COUNTRY","fieldLabel":"Country","valueId":"pl","valueLabel":"Poland"},{"fieldId":"58c13159e4b01d4b19ddf729","fieldLabel":"Department","valueId":"2572770","valueLabel":"IT - Software Development"},{"fieldId":"58c13159e4b01d4b19ddf728","fieldLabel":"Brands","valueId":"9c8396d4-11a6-443c-897c-15f29221a3fd","valueLabel":"Allegro Pay sp. z o.o."}],"visibility":"PUBLIC","ref":"https://api.smartrecruiters.com/v1/companies/allegro/postings/743999994499625","creator":{"name":"Martyna Stafa"},"language":{"code":"en","label":"English","labelNative":"English (US)"}},{"id":"743999994263391","name":"Senior Salesforce Software Engineer","uuid":"2742b4d4-eabb-48dd-9b0c-399cdb0afd6b","jobAdId":"274a39ab-ebda-4c9c-a9bd-5cd21a08a275","defaultJobAd":false,"refNumber":"REF4747J","company":{"identifier":"Allegro","name":"Allegro"},"releasedDate":"2024-06-14T13:42:56.357Z","location":{"city":"Warsaw","country":"pl","remote":false},"industry":{"id":"internet","label":"Internet"},"department":{"id":"2572770","label":"IT - Software Development"},"function":{"id":"information_technology","label":"Information Technology"},"typeOfEmployment":{"id":"permanent","label":"Full-time"},"experienceLevel":{"id":"mid_senior_level","label":"Mid-Senior Level"},"customField":[{"fieldId":"61583054f15cea434e0be36f","fieldLabel":"Career Level","valueId":"26b58095-3c5f-4596-937f-27547fb80b07","valueLabel":"5"},{"fieldId":"61582f70e72a6b6d239c9857","fieldLabel":"Area","valueId":"76599a72-f283-4550-9303-52e2e0eb6e32","valueLabel":"Technology"},{"fieldId":"58c15608e4b01d4b19ddf790","fieldLabel":"Recruitment Process","valueId":"ed4682c7-33c9-41c2-8d13-428ed39046f5","valueLabel":"Tech. Engineer - IC"},{"fieldId":"6406f92e638cbb2f415a94a9","fieldLabel":"Job Area","valueId":"e8731ea4-48a9-476d-ab1d-9a40eb3426f1","valueLabel":"Technology"},{"fieldId":"COUNTRY","fieldLabel":"Country","valueId":"pl","valueLabel":"Poland"},{"fieldId":"58c13159e4b01d4b19ddf729","fieldLabel":"Department","valueId":"2572770","valueLabel":"IT - Software Development"},{"fieldId":"58c13159e4b01d4b19ddf728","fieldLabel":"Brands","valueId":"4ccb4fab-6c3f-4ed0-9140-8533fe17447f","valueLabel":"Allegro sp. z o.o."}],"visibility":"PUBLIC","ref":"https://api.smartrecruiters.com/v1/companies/allegro/postings/743999994263391","creator":{"name":"Agnieszka Adamus"},"language":{"code":"pl","label":"Polish","labelNative":"polski"}},{"id":"743999994260676","name":"Senior Salesforce Software Engineer","uuid":"d487ff86-8cfc-4076-818f-505afe848fd1","jobAdId":"d0b08f39-f02c-4e32-ad36-475f900ddfc1","defaultJobAd":true,"refNumber":"REF4747J","company":{"identifier":"Allegro","name":"Allegro"},"releasedDate":"2024-06-14T13:42:31.056Z","location":{"city":"Warsaw","country":"pl","remote":false},"industry":{"id":"internet","label":"Internet"},"department":{"id":"2572770","label":"IT - Software Development"},"function":{"id":"information_technology","label":"Information Technology"},"typeOfEmployment":{"id":"permanent","label":"Full-time"},"experienceLevel":{"id":"mid_senior_level","label":"Mid-Senior Level"},"customField":[{"fieldId":"61583054f15cea434e0be36f","fieldLabel":"Career Level","valueId":"26b58095-3c5f-4596-937f-27547fb80b07","valueLabel":"5"},{"fieldId":"61582f70e72a6b6d239c9857","fieldLabel":"Area","valueId":"76599a72-f283-4550-9303-52e2e0eb6e32","valueLabel":"Technology"},{"fieldId":"58c15608e4b01d4b19ddf790","fieldLabel":"Recruitment Process","valueId":"ed4682c7-33c9-41c2-8d13-428ed39046f5","valueLabel":"Tech. Engineer - IC"},{"fieldId":"6406f92e638cbb2f415a94a9","fieldLabel":"Job Area","valueId":"e8731ea4-48a9-476d-ab1d-9a40eb3426f1","valueLabel":"Technology"},{"fieldId":"COUNTRY","fieldLabel":"Country","valueId":"pl","valueLabel":"Poland"},{"fieldId":"58c13159e4b01d4b19ddf729","fieldLabel":"Department","valueId":"2572770","valueLabel":"IT - Software Development"},{"fieldId":"58c13159e4b01d4b19ddf728","fieldLabel":"Brands","valueId":"4ccb4fab-6c3f-4ed0-9140-8533fe17447f","valueLabel":"Allegro sp. z o.o."}],"visibility":"PUBLIC","ref":"https://api.smartrecruiters.com/v1/companies/allegro/postings/743999994260676","creator":{"name":"Agnieszka Adamus"},"language":{"code":"en","label":"English","labelNative":"English (US)"}},{"id":"743999994187830","name":"Contractor Software Engineer (Java/Kotlin)","uuid":"a4a96698-9b67-415f-a1c8-dd917f0e0980","jobAdId":"eba60e1f-3a45-4af9-a9e7-2b36917ce3eb","defaultJobAd":true,"refNumber":"REF4956T","company":{"identifier":"Allegro","name":"Allegro"},"releasedDate":"2024-06-14T08:16:05.358Z","location":{"city":"Warsaw, Poznań, Cracow","country":"pl","remote":false},"industry":{"id":"internet","label":"Internet"},"department":{"id":"2572770","label":"IT - Software Development"},"function":{"id":"information_technology","label":"Information Technology"},"typeOfEmployment":{"id":"contract","label":"Contract"},"experienceLevel":{"id":"mid_senior_level","label":"Mid-Senior Level"},"customField":[{"fieldId":"58c15608e4b01d4b19ddf790","fieldLabel":"Recruitment Process","valueId":"e543c79f-6df9-499f-8ba8-237c3c331cc1","valueLabel":"NEW B2B Technology CL 1-6"},{"fieldId":"6406f92e638cbb2f415a94a9","fieldLabel":"Job Area","valueId":"e8731ea4-48a9-476d-ab1d-9a40eb3426f1","valueLabel":"Technology"},{"fieldId":"COUNTRY","fieldLabel":"Country","valueId":"pl","valueLabel":"Poland"},{"fieldId":"61583054f15cea434e0be36f","fieldLabel":"Career Level","valueId":"3c97f53f-19c2-4a25-9eb1-513f9fb38b80","valueLabel":"3-5"},{"fieldId":"58c13159e4b01d4b19ddf729","fieldLabel":"Department","valueId":"2572770","valueLabel":"IT - Software Development"},{"fieldId":"58c13159e4b01d4b19ddf728","fieldLabel":"Brands","valueId":"f7af19b5-5d6a-43a0-9a2b-1e99277515c7","valueLabel":"Opennet.pl Sp. z o.o."},{"fieldId":"61582f70e72a6b6d239c9857","fieldLabel":"Area","valueId":"76599a72-f283-4550-9303-52e2e0eb6e32","valueLabel":"Technology"}],"visibility":"PUBLIC","ref":"https://api.smartrecruiters.com/v1/companies/allegro/postings/743999994187830","creator":{"name":"Magdalena Szetelnicka"},"language":{"code":"en","label":"English","labelNative":"English (US)"}},{"id":"743999994187205","name":"Software Engineer (Java) - Platform Team","uuid":"7bcc877a-15ce-456b-983b-143acd0d62e6","jobAdId":"e667c7ae-00a8-4611-b5aa-85fd155a5c54","defaultJobAd":true,"refNumber":"REF5039L","company":{"identifier":"Allegro","name":"Allegro"},"releasedDate":"2024-06-14T08:06:22.659Z","location":{"city":"Warsaw","region":"Masovian Voivodeship","country":"pl","remote":false,"latitude":"52.2296756","longitude":"21.0122287"},"industry":{"id":"internet","label":"Internet"},"department":{"id":"2572770","label":"IT - Software Development"},"function":{"id":"information_technology","label":"Information Technology"},"typeOfEmployment":{"id":"permanent","label":"Full-time"},"experienceLevel":{"id":"mid_senior_level","label":"Mid-Senior Level"},"customField":[{"fieldId":"61583054f15cea434e0be36f","fieldLabel":"Career Level","valueId":"3976147c-fe25-42a8-8c97-78273250960b","valueLabel":"4"},{"fieldId":"61582f70e72a6b6d239c9857","fieldLabel":"Area","valueId":"76599a72-f283-4550-9303-52e2e0eb6e32","valueLabel":"Technology"},{"fieldId":"58c15608e4b01d4b19ddf790","fieldLabel":"Recruitment Process","valueId":"b3da614a-1ddb-441b-a557-5acfdb6fcb90","valueLabel":"NEW Technology CL 1-6"},{"fieldId":"6406f92e638cbb2f415a94a9","fieldLabel":"Job Area","valueId":"e8731ea4-48a9-476d-ab1d-9a40eb3426f1","valueLabel":"Technology"},{"fieldId":"COUNTRY","fieldLabel":"Country","valueId":"pl","valueLabel":"Poland"},{"fieldId":"58c13159e4b01d4b19ddf729","fieldLabel":"Department","valueId":"2572770","valueLabel":"IT - Software Development"},{"fieldId":"58c13159e4b01d4b19ddf728","fieldLabel":"Brands","valueId":"9c8396d4-11a6-443c-897c-15f29221a3fd","valueLabel":"Allegro Pay sp. z o.o."}],"visibility":"PUBLIC","ref":"https://api.smartrecruiters.com/v1/companies/allegro/postings/743999994187205","creator":{"name":"Magdalena Szetelnicka"},"language":{"code":"en","label":"English","labelNative":"English (US)"}}],"events":[{"created":1715716710000,"duration":7200000,"id":"301022703","name":"Allegro Tech Talks #43 - Wszystko o programie e-Xperience","date_in_series_pattern":false,"status":"past","time":1716393600000,"local_date":"2024-05-22","local_time":"18:00","updated":1716406648000,"utc_offset":7200000,"waitlist_count":0,"yes_rsvp_count":14,"venue":{"id":27570147,"name":"Allegro Office - Poznań (Nowy Rynek)","lat":52.40021514892578,"lon":16.92083168029785,"repinned":false,"address_1":"Wierzbięcice 1B - budynek D","city":"Poznań","country":"pl","localized_country_name":"Poland"},"is_online_event":false,"eventType":"PHYSICAL","group":{"created":1425052059000,"name":"allegro Tech","id":18465254,"join_mode":"open","lat":52.2599983215332,"lon":21.020000457763672,"urlname":"allegrotech","who":"Techs","localized_location":"Warsaw, Poland","state":"","country":"pl","region":"en_US","timezone":"Europe/Warsaw"},"link":"https://www.meetup.com/allegrotech/events/301022703/","description":"**➡ Rejestracja:** [https://app.evenea.pl/event/allegro-tech-talk-43/](https://app.evenea.pl/event/allegro-tech-talk-43/) Zapraszamy Was na #43 wydarzenie z serii Allegro Tech Talk, podczas których dzielimy się wiedzą, wzajemnie inspirujemy oraz integrujemy przy dobrej kawie☕, napojach🥤…","how_to_find_us":"Biuro Allegro znajduje się w kompleksie Nowy Rynek. Szukaj budynku D i kieruj się do wejścia od ul. Wierzbięcice. Komunikacja miejska: najbliższy przystanek to Wierzbięcice i kursują tu linie tramwajowe numer 2, 5, 6, 10, 12, 18 Spacerem - z dworca Poznań Główny przejście zajmie Ci około 5 minut.","visibility":"public","member_pay_fee":false},{"created":1702979844000,"duration":187200000,"id":"298027809","name":"UX Research Confetti - IV edycja","date_in_series_pattern":false,"status":"past","time":1716202800000,"local_date":"2024-05-20","local_time":"13:00","updated":1716392955000,"utc_offset":7200000,"waitlist_count":0,"yes_rsvp_count":82,"venue":{"id":27549223,"name":"Allegro Warsaw Office","lat":52.23224639892578,"lon":20.992111206054688,"repinned":true,"address_1":"ul. Żelazna 51/53","city":"Warszawa","country":"pl","localized_country_name":"Poland"},"is_online_event":false,"eventType":"PHYSICAL","group":{"created":1425052059000,"name":"allegro Tech","id":18465254,"join_mode":"open","lat":52.2599983215332,"lon":21.020000457763672,"urlname":"allegrotech","who":"Techs","localized_location":"Warsaw, Poland","state":"","country":"pl","region":"en_US","timezone":"Europe/Warsaw"},"link":"https://www.meetup.com/allegrotech/events/298027809/","description":"**🎉 Przedstawiamy 4. edycję UX Research Confetti - bezpłatną, polską konferencję poświęconą badaniom UX, organizowaną przez zespół badaczy z Allegro.** ✨ Konferencja odbędzie się w…","visibility":"public","member_pay_fee":false},{"created":1712583756000,"duration":14400000,"id":"300288303","name":"DDD & EventStorming na luzie - unconference na 2 lata gildii w Allegro","date_in_series_pattern":false,"status":"past","time":1714129200000,"local_date":"2024-04-26","local_time":"13:00","updated":1714146607000,"utc_offset":7200000,"waitlist_count":0,"yes_rsvp_count":103,"venue":{"id":27549223,"name":"Allegro Warsaw Office","lat":52.23224639892578,"lon":20.992111206054688,"repinned":true,"address_1":"ul. Żelazna 51/53","city":"Warszawa","country":"pl","localized_country_name":"Poland"},"is_online_event":false,"eventType":"PHYSICAL","group":{"created":1425052059000,"name":"allegro Tech","id":18465254,"join_mode":"open","lat":52.2599983215332,"lon":21.020000457763672,"urlname":"allegrotech","who":"Techs","localized_location":"Warsaw, Poland","state":"","country":"pl","region":"en_US","timezone":"Europe/Warsaw"},"link":"https://www.meetup.com/allegrotech/events/300288303/","description":"**➡ Rejestracja:** **[https://app.evenea.pl/event/allegro-tech-talk-ddd/](https://app.evenea.pl/event/allegro-tech-talk-ddd/)** Dobrze Was widzieć! Allegro Tech to miejsce, w którym dzielimy się wiedzą, dobrymi praktykami i case study z różnych projektów prowadzonych w…","how_to_find_us":"Biuro Allegro znajduje się w kompleksie Fabryki Norblina. Szukaj wejścia Plater 3, od ul. Żelaznej. \n\nKomunikacja miejska: najbliższe przystanki to Norblin 05 i 06 z liniami: 109, 178, 157. Dojedziecie do nas również tramwajami numer 10 i 11 oraz metrem (Rondo ONZ lub Rondo Daszyńskiego).","visibility":"public","member_pay_fee":false},{"created":1712756447000,"duration":7200000,"id":"300327359","name":"Allegro Tech Talks #42 - Kariera Product Managera","date_in_series_pattern":false,"status":"past","time":1713888000000,"local_date":"2024-04-23","local_time":"18:00","updated":1713900030000,"utc_offset":7200000,"waitlist_count":0,"yes_rsvp_count":37,"venue":{"id":27549223,"name":"Allegro Warsaw Office","lat":52.23224639892578,"lon":20.992111206054688,"repinned":true,"address_1":"ul. Żelazna 51/53","city":"Warszawa","country":"pl","localized_country_name":"Poland"},"is_online_event":false,"eventType":"PHYSICAL","group":{"created":1425052059000,"name":"allegro Tech","id":18465254,"join_mode":"open","lat":52.2599983215332,"lon":21.020000457763672,"urlname":"allegrotech","who":"Techs","localized_location":"Warsaw, Poland","state":"","country":"pl","region":"en_US","timezone":"Europe/Warsaw"},"link":"https://www.meetup.com/allegrotech/events/300327359/","description":"**➡ Rejestracja:** [https://app.evenea.pl/event/allegro-tech-talk-42/ ](https://app.evenea.pl/event/allegro-tech-talk-42/) Zapraszamy Was na #42 wydarzenie z serii Allegro Tech Talk, podczas których dzielimy się wiedzą, wzajemnie inspirujemy oraz integrujemy przy dobrej…","how_to_find_us":"Biuro Allegro znajduje się w kompleksie Fabryki Norblina. Szukaj wejścia Plater 3, od ul. Żelaznej. \n\nKomunikacja miejska: najbliższe przystanki to Norblin 05 i 06 z liniami: 109, 178, 157. Dojedziesz do nas również tramwajami numer 10 i 11 oraz metrem (Rondo ONZ lub Rondo Daszyńskiego).","visibility":"public","member_pay_fee":false}],"podcasts":[{"title":"O pracy analityków w obszarze technologii i przetwarzaniu danych w dużej skali","link":"https://podcast.allegro.tech/o-pracy-analitykow-w-obszarze-technologii-i-przetwarzaniu-danych-w-duzej-skali/","pubDate":"Thu, 29 Feb 2024 00:00:00 GMT","content":"Na czym polega praca analityków w obszarze technologii w Allegro? Jakich narzędzi i technologii na co dzień używają osoby pracujące na tych stanowiskach? Jak efekty pracy analityków wpływają na naszą platformę, produkty i funkcjonalności? Czym zajmuje się Data Product Manager w Allegro Pay? Dlaczego monety są ważnym elementem ekosystemu Allegro? Posłuchajcie kolejnego odcinka Allegro Tech Podcast tym razem z udziałem Adrianny Napiórkowskiej - Data Product Managerki w Allegro Pay oraz Kaya Akcelikli - Senior Managera w obszarze Data w Allegro.","contentSnippet":"Na czym polega praca analityków w obszarze technologii w Allegro? Jakich narzędzi i technologii na co dzień używają osoby pracujące na tych stanowiskach? Jak efekty pracy analityków wpływają na naszą platformę, produkty i funkcjonalności? Czym zajmuje się Data Product Manager w Allegro Pay? Dlaczego monety są ważnym elementem ekosystemu Allegro? Posłuchajcie kolejnego odcinka Allegro Tech Podcast tym razem z udziałem Adrianny Napiórkowskiej - Data Product Managerki w Allegro Pay oraz Kaya Akcelikli - Senior Managera w obszarze Data w Allegro.","guid":"https://podcast.allegro.tech/o-pracy-analitykow-w-obszarze-technologii-i-przetwarzaniu-danych-w-duzej-skali/","isoDate":"2024-02-29T00:00:00.000Z"},{"title":"Programowanie - co liczy się w nim najbardziej?","link":"https://podcast.allegro.tech/programowanie-co-liczy-sie-w-nim-najbardziej/","pubDate":"Thu, 01 Feb 2024 00:00:00 GMT","content":"Jaką ścieżkę trzeba przejść, aby dobrze programować? Gdzie zdobywać wiedzę, doświadczenie i szlifować swoje umiejętności? Ile czasu potrzeba aby nabrać doświadczenia i jak zadbać o swój dalszy rozwój? Na czym w praktyce polegają role (Senior) Software Engineer oraz Engineering Manager w Allegro i kto najlepiej sprawdza się w naszych zespołach? Posłuchajcie nowego odcinka Allegro Tech Podcast z udziałem Rafała Schmidta (Senior Software Engineer) i Waldemara Panasa (Manager, Engineering) z Allegro.","contentSnippet":"Jaką ścieżkę trzeba przejść, aby dobrze programować? Gdzie zdobywać wiedzę, doświadczenie i szlifować swoje umiejętności? Ile czasu potrzeba aby nabrać doświadczenia i jak zadbać o swój dalszy rozwój? Na czym w praktyce polegają role (Senior) Software Engineer oraz Engineering Manager w Allegro i kto najlepiej sprawdza się w naszych zespołach? Posłuchajcie nowego odcinka Allegro Tech Podcast z udziałem Rafała Schmidta (Senior Software Engineer) i Waldemara Panasa (Manager, Engineering) z Allegro.","guid":"https://podcast.allegro.tech/programowanie-co-liczy-sie-w-nim-najbardziej/","isoDate":"2024-02-01T00:00:00.000Z"},{"title":"MBox: server-driven UI dla aplikacji mobilnych","link":"https://podcast.allegro.tech/mbox-server-driven-ui-dla-aplikacji-mobilnych/","pubDate":"Thu, 16 Nov 2023 00:00:00 GMT","content":"Czym jest i jak powstał MBox: wewnętrzna platforma server-driven UI dla aplikacji mobilnych w Allegro? Skąd wziął się pomysł na to rozwiązanie i na jakie bolączki odpowiada? Dlaczego zdecydowaliśmy się na budowanie tego typu rozwiązania in-house i z jakimi wyzwaniami mierzyliśmy się w procesie tworzenia? Co wyróżnia zespoły pracujące nad tym narzędziem i jak pracuje im się bez Product Ownera? Posłuchajcie siódmego odcinka Allegro Tech Podcast z udziałem Pauliny Sadowskiej i Tomasza Gębarowskiego - Managerów w obszarze Technical Platform Services w Allegro.","contentSnippet":"Czym jest i jak powstał MBox: wewnętrzna platforma server-driven UI dla aplikacji mobilnych w Allegro? Skąd wziął się pomysł na to rozwiązanie i na jakie bolączki odpowiada? Dlaczego zdecydowaliśmy się na budowanie tego typu rozwiązania in-house i z jakimi wyzwaniami mierzyliśmy się w procesie tworzenia? Co wyróżnia zespoły pracujące nad tym narzędziem i jak pracuje im się bez Product Ownera? Posłuchajcie siódmego odcinka Allegro Tech Podcast z udziałem Pauliny Sadowskiej i Tomasza Gębarowskiego - Managerów w obszarze Technical Platform Services w Allegro.","guid":"https://podcast.allegro.tech/mbox-server-driven-ui-dla-aplikacji-mobilnych/","isoDate":"2023-11-16T00:00:00.000Z"},{"title":"O chatbotach i ich wpływie na Allegro","link":"https://podcast.allegro.tech/o-chatbotach-i-ich-wplywie-na-allegro/","pubDate":"Wed, 11 Oct 2023 00:00:00 GMT","content":"Jakie procesy automatyzujemy w Allegro i co warto o nich wiedzieć w kontekście obszaru Customer Experience? W czym pomagają nam chatboty, jak je rozwijamy i dbamy o ich jakość? Kim są Allina oraz Albert i co mają wspólnego z automatyzacją? Za jakie rozwiązania otrzymaliśmy nagrodę hiperautomatyzacji? O tym wszystkim posłuchacie w odcinku z udziałem Rafała Gajewskiego - Managera w obszarze IT Services w Allegro.","contentSnippet":"Jakie procesy automatyzujemy w Allegro i co warto o nich wiedzieć w kontekście obszaru Customer Experience? W czym pomagają nam chatboty, jak je rozwijamy i dbamy o ich jakość? Kim są Allina oraz Albert i co mają wspólnego z automatyzacją? Za jakie rozwiązania otrzymaliśmy nagrodę hiperautomatyzacji? O tym wszystkim posłuchacie w odcinku z udziałem Rafała Gajewskiego - Managera w obszarze IT Services w Allegro.","guid":"https://podcast.allegro.tech/o-chatbotach-i-ich-wplywie-na-allegro/","isoDate":"2023-10-11T00:00:00.000Z"}]},"__N_SSG":true}